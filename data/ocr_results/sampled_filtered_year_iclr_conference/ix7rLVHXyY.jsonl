{"id": "ix7rLVHXyY", "page_num": 22, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"We show results using low-rank adaptors for finetuning in Table 10. We hypothesize that this gap may be because performance optimization examples do not occur naturally in the training data. Recent work has shown that the effectiveness of parameter-efficient methods depends on the training data. For example, He et al. (2021) find that \u201cPEFT techniques are slower to converge than full tuning in low/medium-resource scenarios,\u201d and Niederfahrenhorst et al. (2023) find that LoRA is least effective for challenging tasks like mathematical reasoning. Together, these works indicate that the performance of PEFT may be heavily task-dependent. Our hypothesis is based on the fact that LoRA only changes a small subset of the model\u2019s parameters, and is likely most helpful when the base model has some proficiency for the task (due to pre-training), and LoRA can help adapt the model of the task further. Given that LLMs generally struggled in program optimization without retrieval or full fine-tuning, we hypothesize that the challenging nature of the problem and a potential lack of pre-trained proficiency pose challenges for LoRA.\\n\\nTable 10: LoRA Experiments: Results for fine-tuning\\n\\n| Dataset | Model | %Opt | Speedup | %Correct | Speedup |\\n|---------|-------|------|---------|----------|---------|\\n| All     | CODELLAMA 7B | 1.12 | 1.01\u00d7 | 45.82% | 9.57% |\\n| All     | CODELLAMA 13B | 0.41% | 1.01\u00d7 | 59.47% | 9.67% |\\n| HQ      | CODELLAMA 13B | 0.92% | 1.02\u00d7 | 59.57% | 10.69% |\\n\\nGiven the program below, improve its performance:\\n\\n### Program:\\n\\n```python\\n# src_code\\n```\\n\\n### Optimized Version:\\n\\nFigure 12: Instruction-prompting for adapting LLMs. The model is provided with direct instructions to improve the performance of the given program.\"}"}
{"id": "ix7rLVHXyY", "page_num": 23, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"### Program:\\n```\\nslow1 \u2192 fast1 || slow2 \u2192 fast2 || slow3 \u2192 fast3 || ... || slowN \u2192 fastN,\\n```\\n\\n### Optimized Version:\\n```\\n```\\n\\nFigure 13: Few-shot prompting for in-context learning. The format \\\"slow \u2192 fast\\\" is used for adaptation. A test program is appended for inference.\\n\\n### sl...\"}"}
{"id": "ix7rLVHXyY", "page_num": 24, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Below is a program. Optimize the program and provide a more efficient version.\\n\\n### Program:\\n```\\n{src_code}\\n```\\n\\n### Optimized Version:\\n```\\n{fast_code}\\n```\\n\\n(a) Training Prompt.\\n\\n(b) Inference Prompt.\\n\\nFigure 16: Standard training and inference prompts with PIE.\"}"}
{"id": "ix7rLVHXyY", "page_num": 25, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 17: Example of retrieval-based prompting. To optimized the program in Figure 17(c), our dynamic prompting method retrieves the closest source program from the training set (Figure 17(a)), where the similarity is measured using CodeBertScore (Zhou et al., 2023b). The slow program and the corresponding fast program (Figure 17(b)) from the training set are used as prompts.\"}"}
{"id": "ix7rLVHXyY", "page_num": 1, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"ABSTRACT\\n\\nWith the waning of Moore's law, optimizing program performance has become a major focus of software research. However, high-level optimizations such as API and algorithm changes remain elusive due to the difficulty of understanding the semantics of code. Simultaneously, pretrained large language models (LLMs) have demonstrated strong capabilities at solving a wide range of programming tasks. To that end, we introduce a framework for adapting LLMs to high-level program optimization. First, we curate a dataset of performance-improving edits made by human programmers of over 77K competitive C++ programming submission pairs, accompanied by extensive unit tests. A major challenge is the significant variability of measuring performance on commodity hardware, which can lead to spurious \\\"improvements\\\". To isolate and reliably evaluate the impact of program optimizations, we design an environment based on the gem5 full system simulator, the de facto simulator used in academia and industry. Next, we propose a broad range of adaptation strategies for code optimization; for prompting, these include retrieval-based few-shot prompting and chain-of-thought, and for finetuning, these include performance-conditioned generation and synthetic data augmentation based on self-play. A combination of these techniques achieves a mean speedup of \\\\( 6.86 \\\\times \\\\) with eight generations, higher than average optimizations from individual programmers (3.66 \\\\( \\\\times \\\\)). Using our model's fastest generations, we set a new upper limit on the fastest speedup possible for our dataset at 9.64 \\\\( \\\\times \\\\) compared to using the fastest human submissions available (9.56 \\\\( \\\\times \\\\)).\\n\\nINTRODUCTION\\n\\nDespite the impressive progress of optimizing compilers and other tools for performance engineering (Aho et al., 2007), programmers are still largely responsible for high-level performance considerations such as algorithms and API choices. Recent work has demonstrated the promise of deep learning for automating performance optimization (Garg et al., 2022; Mankowitz et al., 2023). However, these techniques are either narrow or difficult to build on due to the lack of open datasets and lack of reliable performance measurement techniques, which has stymied research in this direction. Recently, pre-trained large language models (LLMs) have demonstrated impressive performance at a wide range of programming tasks (Chen et al., 2021b; Fried et al., 2022; Xu et al., 2022; Nijkamp et al., 2022). Yet, the effectiveness of large, pre-trained LLMs for program optimization remains an open research question. We study whether such LLMs can be adapted for performance optimization. To this end, we introduce a novel benchmark for performance optimization.\"}"}
{"id": "ix7rLVHXyY", "page_num": 14, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"We study the kinds of edits LLMs make that lead to our performance gains, focusing on our best-performing model, GPT-3.5 fine-tuned with synthetic data. We manually analyze a randomly sampled set of 120 (source, optimized) program pairs to understand the algorithmic and structural changes responsible for the performance gains. We find that the transformations can be broadly categorized into four kinds: Algorithmic changes (complex modifications, such as changing recursive methods to dynamic programming, and unexpected ones, such as omitting Binary Indexed Trees for simpler constructs) are most common, comprising ~34.15% of changes; Input/Output operations (e.g., changing 'cin/cout' to 'scanf/printf', efficiently reading strings) comprised ~26.02%; Data Structure modifications (e.g., switching from vectors to arrays) comprised ~21.14%, and Miscellaneous adjustments (e.g., code cleanups and constant optimizations) comprised ~18.70%. These findings show the LLM's capability to perform sophisticated optimizations while preserving functionality.\\n\\nIn Appendix A.2, we show several examples to demonstrate the nature of optimizations made by our model. In these examples, we highlight the removal of a wasteful nested loop (Figure 4), eliminating the need to sort (Figure 3), avoiding unnecessary precomputations (Figure 5), use of simple modular arithmetic properties for optimization (Figure 6), and restructuring loops to improve performance (Figure 7).\\n\\nAlgorithmic Transformations (34.15%). The most dominant transformation, representing approximately 34.15% of the changes, is the Algorithmic category. Edits in this category exhibited sophisticated code restructuring. A frequent transformation was the shift from recursive methodologies to dynamic programming approaches, which can significantly enhance running time for specific problem types. Other examples include replacing Binary Indexed Trees with more straightforward constructs, removing redundant conditional checks, bit manipulations, and in some cases, using identities from number theory and algebra to replace complex computation with a formula.\\n\\nInput/Output Operations (26.02%). The Input/Output operations category, accounting for roughly 26.02% of the changes, primarily centered on transitioning from C++ standard I/O methods ('cin/cout') to the faster C-standard methods ('scanf/printf'). Other examples include reading a string character-by-character vs. reading in one go. This transformation is particularly beneficial for problems dealing with extensive datasets, where I/O operations can be a bottleneck.\\n\\nData Structure Modifications (21.14%). Changes in the Data Structures category, which constituted about 21.14% of the transformations, showcased the model's adeptness in selecting optimal data structures for the task. A recurring modification was the transition from vectors to traditional arrays, leading to enhanced access times and reduced overhead. Additionally, the changes include removal of pointers in favor of direct access, and using hashmaps when appropriate.\\n\\nMiscellaneous Optimizations (18.70%). The Miscellaneous category, encompassing approximately 18.70% of changes, captured a myriad of optimizations. These ranged from code cleanups, such as omitting unnecessary initializations, to replacing computationally intensive functions with predefined constants.\\n\\nWhile our analysis showcases a variety of optimizations, it is essential to address certain speedup sources that may be considered spurious. Specifically, in 10 out of the 120 cases we examined, the speedup stemmed from reducing the constants used to allocate arrays. These speedups might not always reflect genuine algorithmic improvements, and indicate that the test cases may not perfectly cover all the cases, an open problem in code synthesis (Li et al., 2022). Thus, while they contribute to the overall speedup metrics, they should be interpreted with caution. Nevertheless, our analysis shows that the vast majority of speedups do not suffer from this issue, supporting our strong empirical results.\"}"}
{"id": "ix7rLVHXyY", "page_num": 15, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"main() {\\n  int n, m, a, b;\\n  vector<int> v, v1;\\n  cin >> n >> m;\\n  for (int i = 0; i < m; i++) {\\n    cin >> a >> b;\\n    v.push_back(a);\\n    v1.push_back(b);\\n  }\\n  sort(v.begin(), v.end());\\n  sort(v1.begin(), v1.end());\\n  if (v.back() > v1[0]) {\\n    cout << 0 << endl;\\n  } else {\\n    cout << v1[0] - v.back() + 1 << endl;\\n  }\\n  return 0;\\n}\\n\\n(a) Slower Code.\\n\\nmain() {\\n  int n, m, a, b, max = -1, min = 1e9;\\n  scanf(\"%d%d\", &n, &m);\\n  for (int i = 0; i < m; i++) {\\n    scanf(\"%d%d\", &a, &b);\\n    if (a > max) max = a;\\n    if (b < min) min = b;\\n  }\\n  ans = min - max + 1;\\n  if (ans < 0) ans = 0;\\n  printf(\"%d\\n\", ans);\\n  return 0;\\n}\\n\\n(b) Faster Code.\\n\\nFigure 3: Comparison of two programs for determining the range between the maximum and minimum values from a set of input pairs. The faster code (right) generated by PIE directly computes the maximum start and minimum end of the ranges in a single pass ($O(n)$), eliminating the need for sorting ($O(n \\\\log n)$).\\n\\nA.2 EXAMPLES OF OPTIMIZATIONS\\n\\nWe show several examples to demonstrate the nature of optimizations made by our model. In these examples, we highlight the removal of a wasteful nested loop (Figure 4), eliminating the need to sort (Figure 3), avoiding unnecessary precomputations (Figure 5), use of simple modular arithmetic properties for optimization (Figure 6), and restructuring loops to improve performance (Figure 7).\\n\\nmain() {\\n  int k, x;\\n  cin >> k >> x;\\n  for (int i = -1000000; i < 1000001; i++) {\\n    if (i == x) {\\n      for (i = x - (k - 1); i < x + k; i++) {\\n        cout << i << \\\" \\\";\\n      }\\n    }\\n  }\\n  return 0;\\n}\\n\\n(a) Slower Code.\\n\\nmain() {\\n  int k, x;\\n  scanf(\"%d %d\", &k, &x);\\n  for (int i = x - k + 1; i <= x + k - 1; i++) {\\n    printf(\"%d \", i);\\n  }\\n  return 0;\\n}\\n\\n(b) Faster Code.\\n\\nFigure 4: Comparison of two code implementations for printing $2k - 1$ consecutive numbers centered around the input $x$. The faster code (right) optimizes the process by directly computing the range without the need for nested loops, resulting in a more efficient and concise solution. The red highlighted portion in the slower code (left) indicates the wasteful nested loop that was eliminated in the optimized version. This loop unnecessarily iterates over a large range of numbers, only to perform a meaningful operation for a tiny fraction of those iterations.\"}"}
{"id": "ix7rLVHXyY", "page_num": 16, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"```c\\nint main()\\n{\\n    int i, n;\\n    long long num[100005] = {0,1};\\n    for (i = 2; i <= 100004; i++)\\n        num[i] = (num[i-1] * i) % (1000000007);\\n    scanf(\"%d\", &n);\\n    printf(\"%lld\\n\", num[n]);\\n    return 0;\\n}\\n```\\n\\n(a) Slower Code.\\n\\n```c\\nlong long a=1, mod = 1e9 + 7;\\nint n;\\nint main()\\n{\\n    scanf(\"%d\", &n);\\n    for (int i = 1; i <= n; i++)\\n        a = (a * i) % mod;\\n    printf(\"%lld\", a);\\n}\\n```\\n\\n(b) Faster Code.\\n\\nFigure 5: Comparison of two code implementations for computing factorial modulo $10^9 + 7$. The slower code (left) precomputes the factorial for all numbers up to $10^5$, storing them in an array. The faster code (right) computes the factorial only for the given input, resulting in a more memory-efficient and faster solution. The red highlighted portion in the slower code indicates the precomputation step that was eliminated in the optimized version.\\n\\n```c\\nint main() {\\n    int A, B, C;\\n    scanf(\"%d %d %d\", &A, &B, &C);\\n    bool isYes = false;\\n    for (int i = 0; i < 1000; i++) {\\n        for (int j = 0; j < 1000; j++) {\\n            if ((A * i) - (B * j) == C)\\n                isYes = true;\\n        }\\n    }\\n    printf(\"%s\\n\", isYes ? \"YES\" : \"NO\");\\n    return 0;\\n}\\n```\\n\\n(a) Slower Code with Nested Loops.\\n\\n```c\\nint main() {\\n    int A, B, C;\\n    scanf(\"%d %d %d\", &A, &B, &C);\\n    bool isYes = false;\\n    for (int i = 0; i < B; i++) {\\n        if ((A * i) % B == C)\\n            isYes = true;\\n    }\\n    printf(\"%s\\n\", isYes ? \"YES\" : \"NO\");\\n    return 0;\\n}\\n```\\n\\n(b) Optimized Code.\\n\\nFigure 6: Optimization of a modular arithmetic problem. The slower code naively checks all possible combinations of $i$ and $j$ leading to a complexity of $O(10^6)$. The faster code leverages the property of modular arithmetic, reducing the complexity to $O(B)$. By directly computing the modulo operation for each $i$ in the range $[0, B-1]$, it efficiently determines if the condition $(A \\\\times i) \\\\mod B = C$ is satisfied. Note that the example on the right is faster, but the generated code could have been even faster if it included a break statement.\"}"}
{"id": "ix7rLVHXyY", "page_num": 17, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"```c\\nmain()\\n{\\n    int i, n, m;\\n    cin >> n >> m;\\n    for (i = m - n + 1; i < m + n; i++)\\n        cout << i;\\n    if (i != m + n - 1)\\n        cout << \\\" \\\";\\n}\\n```\\n\\n(a) Slower Code.\\n\\n```c\\nmain() {\\n    int n, m;\\n    scanf(\\\"%d%d\\\", &n, &m);\\n    for (int i = m - n + 1; i < m; i++)\\n        printf(\\\"%d \\\", i);\\n    printf(\\\"%d\\\", m);\\n    for (int i = m + 1; i < m + n; i++)\\n        printf(\\\" %d\\\", i);\\n    printf(\\\"\\\\n\\\");\\n    return 0;\\n}\\n```\\n\\n(b) Optimized Code.\\n\\nFigure 7: Comparison of the slower code (left) with its optimized version (right). The optimized code avoids an additional conditional check inside the loop by restructuring the loop.\\n\\nA.3 CONVERGENCE OF GPT3.5 FINE-TUNED MODELS WITH ADDITIONAL GENERATIONS\\n\\nThe data in Section 4.2 shows that the gap between GPT-3.5 fine-tuned on HQ data and HQ + Self-Play seems to diminish with more generations. Training with HQ data helps increase the model's coverage, allowing it to optimize a large number of programs with just a single greedy sample. However, as more samples are drawn, the performance of HQ and HQ + Self-play gradually converge to a similar level of performance. We include the plots of the performance improvements as the number of samples gradually increases in Figure 8 and Figure 9.\\n\\nAdditionally, there is a slight drop in correctness after training with Self-Play; however, the speedup and correctness increase from 6.74 \u2192 6.86 and 86.71 \u2192 87.63. This reveals a precision-recall style trade-off: the model trained on synthetic data learns to try novel optimization strategies, but that comes at the cost of making more mistakes. We will add this analysis to the revision.\\n\\n![Figure 8: Performance in % Opt over generations comparison of GPT-3.5 fine-tuned with HQ Data Only vs. HQ + Self-Play.](image1.png)\\n\\n![Figure 9: Speedup over generations comparison of GPT-3.5 fine-tuned with HQ Data Only vs. HQ + Self-Play.](image2.png)\"}"}
{"id": "ix7rLVHXyY", "page_num": 18, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 5: Error analysis of GPT-3.5 fine-tuned with synthetic data.\\n\\n| Result Description                                                                 | Percentage |\\n|----------------------------------------------------------------------------------|------------|\\n| Failed to compile (syntax/type errors)                                           | 12.51%     |\\n| Compiled, but got [95-100%] of test cases wrong                                   | 27.59%     |\\n| Compiled, but got (75, 95%] of test cases wrong                                   | 12.08%     |\\n| Compiled, but got (25, 75%] of test cases wrong                                   | 10.84%     |\\n| Compiled, but got (0-25%] of test cases wrong (at least 1 test case was wrong)    | 6.90%      |\\n| Ran all test cases, but the program was slower than the original                  | 9.93%      |\\n| Ran all test cases, but the program was the same speed as the original            | 9.40%      |\\n| Ran all test cases, the program was faster, but not 1.1 \u00d7 speedup or higher      | 10.75%     |\\n\\nWe performed error analysis on the GPT-3.5 fine-tuned with Self-Play. We analyzed the generated programs that it fails to optimize and the cause of each failure. Table 5 shows that a large fraction \\\\( \\\\sim 60\\\\% \\\\) of the failures happen because the proposed changes break a unit test. In about 30% of the cases, the model produces a correct, but the generated program is either slower (10%) or doesn't meet our threshold for speedup (10%). Finally, in about 10% of the cases, the generated program has a syntax error. Additionally, with test cases, we find that when the model gets the program wrong, it seems to most often get it quite wrong by missing most test cases.\\n\\nAdditionally, we conduct additional analysis to investigate the properties of programs that PIE fails to optimize. The results show a mild negative correlation between the problem description length and average accuracy (-0.15) and between the source program length and average accuracy (-0.26), suggesting longer inputs slightly reduce accuracy. Additionally, the average speedup has a mild negative correlation with both the problem description length (-0.16) and the source program length (-0.11), indicating a minimal impact of length on speedup compared to correctness. Overall, this analysis reveals that language models struggle to generate a correct program when faced with larger source programs and challenging problems, but their ability to optimize programs is minimally impacted. This motivates a future work direction where techniques from program repair may be combined with PIE for better results.\\n\\nWhy does Performance-Conditioning Degrade the Ability to Produce Correct Code?\\n\\nWe believe that conditioning the model only to generate programs with a 10/10 optimization rate may constrain the number of optimizations available for any given input. To investigate this, we experimented using the first 6 generations from the 7b Performance-Conditioned model when conditioned on 10/10 versus combining the first 2 generations when conditioned on 10/10, 9/10, and 8/10 (i.e. comparing 6 total generations from one strategy vs. 6 total generations across difference strategies). When we did this, we saw a %Correct increase from 59.95% to 64.36%. These results support the explanation that performance labels may restrict the set of generated programs that are correct.\"}"}
{"id": "ix7rLVHXyY", "page_num": 19, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2024\\n\\nA.5 PIE D\\n\\nATASET\\n\\nDATASETS\\n\\nTable 6: Number of unique problem ids.\\n\\n|        | Train | Val | Test |\\n|--------|-------|-----|------|\\n|        | 1,474 | 77  | 41   |\\n\\nTable 7: Number of pairs.\\n\\n|        | Train | Val | Test |\\n|--------|-------|-----|------|\\n|        | 77,967| 2,544| 978  |\\n\\nTable 8: GPT-2 Tokenizer lengths.\\n\\n|        | Train | Val | Test |\\n|--------|-------|-----|------|\\n|        | 675.00| 616.44| 417 |\\n|        | 644.74| 471.47| 180 |\\n|        | 427.85| 399.15| 362 |\\n\\nA.6 SELF-PLAY DATA GENERATION DETAILS\\n\\nWe use the template in Figure 10 for prompting GPT-3.5 in the self-play scenario. For the prompt, we sample natural language descriptions of programming problems as well as accepted solutions to fill in the template. For generation, we use a temperature of 1.0 and use top-p sampling with $p = 0.9$.\\n\\nFor each prompt, we try attempt to take $n = 5$ samples. We chose these samples after doing a sweep of 6 configurations of generation parameters, each attempting to generate 200 programs. We found this configuration to be the most cost-effective per new-sample with relatively promising rates of novelty.\\n\\nWe found that after attempting to generate 10,000 new programs through the prompting strategy, 6,553 were not in the training/validation/test set of PIE. We keep track of equivalent programs of the ones generated, and of these 6,553 generations we found 3,314 equivalence sets. In total, this required executing over 1.4 million binary input pairs. Parallelized on a 24-core Intel 13900k processor with 64GB of RAM, this took less than 72 hours to complete.\\n\\nA.7 ABSTRACTION OF RETRIEVAL-BASED FRESH PROMPTING CONFIGURATION\\n\\nFor our retrieval-based prompting experiment we tried multiple configurations for the number of retrieved prompts where $K = \\\\{1, 2, 4\\\\}$ of the $K$ closest retrieved prompts.\\n\\nA.8 TRAINING DETAILS\\n\\nWe fine-tuned the 7B and 13B variants using the HuggingFace Transformers library with FSDP to distribute the training process across $8 \\\\times 48$GB GPUs (NVIDIA RTX A6000/NVIDIA L40). For our high-quality\"}"}
{"id": "ix7rLVHXyY", "page_num": 20, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2024\\n\\nFigure 10: The prompt template used for prompting GPT-3.5 for generating synthetic data for self-play.\\n\\nTable 9: Retrieval-based few-shot prompting ablation over different K examples for retrieval and over various models.\\n\\n| Method                | Model  | %Opt | Speedup | %Correct | Speedup | %Correct |\\n|-----------------------|--------|------|---------|----------|---------|----------|\\n| Dynamic Retrieval, K=1| CODELLAMA 7B | 3.27% | 1.09\u00d7 | 16.67% | 15.64% | 1.50\u00d7 | 50.51% |\\n| Dynamic Retrieval, K=1| CODELLAMA 13B | 5.32% | 1.16\u00d7 | 21.68% | 22.29% | 1.72\u00d7 | 62.99% |\\n| Dynamic Retrieval, K=1| CODELLAMA 34B | 10.02% | 1.25\u00d7 | 30.67% | 34.25% | 2.21\u00d7 | 69.73% |\\n| Dynamic Retrieval, K=2| CODELLAMA 7B | 4.40% | 1.13\u00d7 | 20.55% | 16.87% | 1.51\u00d7 | 55.32% |\\n| Dynamic Retrieval, K=2| CODELLAMA 13B | 9.10% | 1.35\u00d7 | 28.73% | 28.02% | 1.97\u00d7 | 64.72% |\\n| Dynamic Retrieval, K=2| CODELLAMA 34B | 10.22% | 1.27\u00d7 | 25.87% | 34.25% | 2.28\u00d7 | 63.19% |\\n| Dynamic Retrieval, K=2| GPT3.5 | 26.18% | 1.58\u00d7 | 80.37% | 48.06% | 2.14\u00d7 | 97.85% |\\n| Dynamic Retrieval, K=2| GPT4 | 50.00% | 2.61\u00d7 | 80.57% | 74.74% | 3.95\u00d7 | 97.85% |\\n| Dynamic Retrieval, K=4| CODELLAMA 7B | 6.34% | 1.19\u00d7 | 23.11% | 21.06% | 1.66\u00d7 | 57.98% |\\n| Dynamic Retrieval, K=4| CODELLAMA 13B | 9.30% | 1.29\u00d7 | 26.99% | 28.12% | 2.04\u00d7 | 62.58% |\\n| Dynamic Retrieval, K=4| CODELLAMA 34B | 11.66% | 1.34\u00d7 | 30.57% | 42.54% | 2.43\u00d7 | 73.62% |\\n| Dynamic Retrieval, K=4| GPT3.5 | 28.02% | 1.55\u00d7 | 79.65% | 51.64% | 2.19\u00d7 | 95.71% |\\n| Dynamic Retrieval, K=4| GPT4 | 51.02% | 2.53\u00d7 | 79.35% | 76.07% | 3.93\u00d7 | 95.71% |\\n\\ndataset, which consists of approximately 4,000 examples, the models were fine-tuned until convergence was achieved, which can be done under 12 hours with 8 GPUs. For tasks related to full data fine-tuning and performance-conditioned fine-tuning, we only train for 1 epoch, which takes 24 to 36 hours, depending on the model of GPU used. All experiments were conducted using the AdamW optimizer (Loshchilov & Hutter, 2017). For the 7B and 13B variants of CODELLAMA, we used a batch size of 32 and a learning rate of $1e^{-5}$ for all of the experiments.\"}"}
{"id": "ix7rLVHXyY", "page_num": 21, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"A.9 Example of Duplicate Code in Codenet with Different Measured Times\\n\\nFigure 11 contains an example of code we found duplicated across the Project Codenet Dataset with variance in the dataset\u2019s report of CPUTime. For problem number p03160 and between submission s766827701 and s964782197 a speedup of $2.44 \\\\times$ is reported, despite the programs and environments being identical.\\n\\nWe note that multiple submissions existed, because it was template code. For brevity, we remove the macros, imports, and comments.\\n\\n```cpp\\nusing namespace std;\\ntypedef long long ll;\\ninline void getInt(int* p);\\nconst int maxn=1000010;\\nconst int inf=0x3f3f3f3f;\\nll n;\\nll dp[maxn];\\nll a[maxn];\\nint main()\\n{\\n    gbtb;\\ncin>>n;\\n    repd(i,1,n)\\n    {\\n        cin>>a[i];\\n    }\\n    dp[1]=0;\\n    dp[0]=0;\\n    dp[2]=abs(a[2]-a[1]);\\n    repd(i,3,n)\\n    {\\n        dp[i]=min(dp[i-2]+abs(a[i]-a[i-2]),dp[i-1]+abs(a[i]-a[i-1]));\\n    }\\n    cout<<dp[n];\\n    return 0;\\n}\\ninline void getInt(int* p) {\\n    char ch;\\ndo\\n    {\\n        ch = getchar();\\n    }while (ch == ' ');\\n    if (ch == '-') {\\n        *p = -(getchar() - '0');\\n        while ((ch = getchar()) >= '0' && ch <= '9') {\\n            *p = *p * 10 - ch + '0';\\n        }\\n    } else {\\n        *p = ch - '0';\\n        while ((ch = getchar()) >= '0' && ch <= '9') {\\n            *p = *p * 10 + ch - '0';\\n        }\\n    }\\n}\\n```\\n\\nFigure 11: An example of a C++ program we found multiple submissions for as it is template code. Across these submissions, we found variance in the reported CPU runtime despite the code and competitive programming environment being identical.\"}"}
{"id": "ix7rLVHXyY", "page_num": 2, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2024\\n\\nFigure 1: An example of a program that solves the problem of \\\"compute the sum of the numbers from 1 to $N$\\\". The program on the left runs in $O(N)$, whereas the program on the right runs in constant time. The goal of PIE is to enable LLMs to perform these kinds of program optimizations.\\n\\nFirst, we construct a dataset of Performance-Improving Edits (PIE). We collect C++ programs written to solve competitive programming problems, where we track a single programmer's submissions as they evolve over time, filtering for sequences of edits that correspond to performance improvements.\\n\\nNext, a major challenge is the significant variability of measuring performance on real hardware due to server workload and configuration issues. Indeed, we find that benchmarking on real hardware can lead to large, phantom performance \\\"improvements\\\" due only to random chance. To address this challenge, we evaluate performance using the gem5 CPU simulator (Binkert et al., 2011), the gold standard CPU simulator in academia and industry, and models state-of-the-art general-purpose processors. This evaluation strategy is entirely deterministic, ensuring both reliability and reproducibility.\\n\\nBased on this benchmark, we evaluate a variety of techniques for adapting pre-trained code LLMs for performance optimization. First, we consider baseline prompting approaches, including techniques such as chain-of-thought (Wei et al., 2022b) (CoT). We find that LLMs are limited in the challenging task of code optimization. Without data-driven methods that leverage PIE, our strongest baseline CoT only warrants a $1.60 \\\\times$ average speedup over 8 submissions vs. the $3.66 \\\\times$ human reference. Next we consider a retrieval-based prompting approach where retrieval is used to select examples most similar to the current one (Liu et al., 2021; Poesia et al., 2021). Lastly, we consider several finetuning strategies: these include using synthetic data generated via self-play (Haluptzok et al., 2022), where synthetic training examples are generated by an LLM without the need for direct human examples, as well as performance-conditioned generation, where we condition generation on the performance of the generated program.\\n\\nWe find that data-driven methods using PIE, like retrieval-based few-shot prompting and fine-tuning, are highly effective at achieving strong optimization abilities in LLMs. When allowing a model to take 8 samples and filtering for correctness and execution time, our fine-tuned performance-conditioned version of CODELLAMA 13B can achieve an average speedup of $5.65 \\\\times$ on our test set, and a fine-tuned version of GPT-3.5 augmented with synthetic data via self-play achieves an average speedup of $6.86 \\\\times$, the average individual human sampled in our test set achieved an average speedup of $3.66 \\\\times$. Aggregating over all human submissions in the test set with a higher sampling budget, GPT-3.5 achieved a speedup of $9.64 \\\\times$ and surpassed the best human submissions across all programmers with a speedup of $9.56 \\\\times$. In summary, our contributions are:\"}"}
{"id": "ix7rLVHXyY", "page_num": 3, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"We introduce a new code dataset of more than 77K C++ program pairs, named PIE, with execution time annotations collected from the gem5 simulator. PIE enables reproducible evaluation of LLMs for program optimization and reliable performance annotations for training.\\n\\nEnabled by our benchmark, we evaluate different prompting and fine-tuning approaches for adapting pre-trained LLMs to optimize programs. Our results indicate that pre-trained code LLMs are limited in their ability to optimize code without a dataset like PIE.\\n\\nWe develop three effective strategies for adapting LLMs for code optimization: retrieval-based prompting, performance-conditioning, and self-play. Overall, our best model, GPT-3.5 augmented with synthetic data obtained from self-play, achieves an average speedup of 6.86\u00d7, and optimizes 87.63% of the test set by at least 10%.\\n\\nWe construct a dataset targeted at adapting code LLMs to performance optimization, focusing on optimizing program execution time. Our dataset is constructed based on performance-improving edits (PIE) made by human programmers in a range of competitive programming tasks from CodeNet (Puri et al., 2021). We exclusively focus on C++ programs since it is a performance-oriented language compatible with the gem5 simulator. Given a problem, programmers typically write an initial solution and iteratively improve it. Let \\\\( Y_u = [y_{u1}, y_{u2}, \\\\ldots] \\\\) be a chronologically sorted series of programs, written by user \\\\( u \\\\) for problem \\\\( x \\\\). From \\\\( Y_u \\\\), we remove programs that were not accepted by the automated system, eliminating incorrect programs (fail one or more unit tests) or take more than the allowed time to run, resulting in a trajectory of programs \\\\( Y^* = [y^*_1, y^*_2, \\\\ldots, y^*_n] \\\\).\\n\\nFor each trajectory \\\\( Y^* \\\\), we construct pairs \\\\( P_i = (y_1, y_2), (y_1, y_3), (y_2, y_3) \\\\ldots \\\\), and keep only pairs for which \\\\( \\\\text{time}(y_i) - \\\\text{time}(y_{i+1}) > 10\\\\% \\\\) where \\\\( \\\\text{time}(y) \\\\) is the measured latency of program \\\\( y \\\\) (i.e., the relative time improvement is more than 10%). The CodeNet dataset includes CPU time, but we found the information to be inconsistent (see Appendix A.9). Thus, we relabel the execution time using gem5 as described below; to create these annotated runtimes, we performed over 42.8 million simulations in our gem5 environment.\\n\\nWe split the resulting dataset of pairs \\\\( P \\\\) into train/validation/test sets, ensuring that any particular competitive programming problem only appears in one of them. We obtain a training set of 77,967 pairs from 1,474 problems, a validation set of 2,544 pairs from 77 problems, and a test set of 978 pairs from 41 problems.\\n\\nFor each pair in the test set, we also record the fastest human submission execution time for that problem; in Section 4, we include this running time as a comparison point.\\n\\nTest cases. Our goal is to improve performance while ensuring correctness. We evaluate correctness through unit tests; we reject the program if a single test fails. CodeNet includes an average of 4 test cases per problem. To improve coverage, we include additional test cases from AlphaCode (Li et al., 2022) generated with a fine-tuned LLM. A small set of test cases would lead to substantial timeouts above 2 minutes in gem5; after excluding them, we obtain a median of 82.5 test cases per problem in our training set, 75 test cases per problem in our validation set, and 104 test cases per problem for our test set (Appendix A.5).\\n\\nPerformance measurement using gem5. Benchmarking program performance is notoriously difficult. For instance, code instrumentation introduces overhead, and there is substantial variance across executions due to factors such as server load and idiosyncrasies introduced by the operating system. If benchmarking is not performed carefully, it is easy to mistakenly over-report program optimization results. With enough samples and variance, benchmarking the same exact program can easily lead us to report significant optimizations.\\n\\nTo illustrate the challenges, consider HYPERFINE (Peter, 2023), a Rust library designed to precisely benchmark binaries. We benchmarked 500 programs \u201cpairs\u201d where the \u201cslow\u201d and \u201cfast\u201d programs are identical. Ideally, we should have \\\\( \\\\text{source time} = \\\\text{target time} = 1 \\\\) (i.e., the two programs have identical performance). However, we\"}"}
{"id": "ix7rLVHXyY", "page_num": 4, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"observed a mean speedup of $1.12 \\\\times$, with a standard deviation of 0.36, and the top 5% of pairs exhibited a speedup of $1.91 \\\\times$. These results underscore the significant challenges in performance measurement.\\n\\nTo address this challenge, we measure program performance using the gem5 (Binkert et al., 2011) full system simulator, which provides detailed microarchitectural emulation of modern processors. Executing deterministic programs in gem5 provides deterministic performance results. This enables reproducibility in research and denoised performance measurements.\\n\\nWe use the Verbatim configuration of the Intel Skylake architecture from gem5. An advantage of this approach is that our framework can be applied to other platforms like ARM or RISC-V without having access to hardware for those platforms.\\n\\n### 3.1 Few-Shot Prompting\\n\\nInstruction-prompting.\\n\\nWe use prompts instructing the LLM to improve the performance of the given program, an approach commonly referred to as instruction prompting (Mishra et al., 2021; Gupta et al., 2022; Longpre et al., 2023); details on the prompt are in Figure 12 in Appendix A.11.\\n\\n**Few-shot prompting.**\\n\\nNext, we use few-shot prompting (Brown et al., 2020). In particular, we create a prompt with the format \\\"slow $1 \\\\rightarrow$ fast $1 ||$ slow $2 \\\\rightarrow$ fast $2 || \\\\ldots\\\". A slow test set program is appended to this prompt during inference and supplied to the model. We create the prompts by randomly sampling two (fast, slow) pairs from the training set (Examples of prompts in Figure 13 in Appendix A.11).\\n\\n**Chain-of-thought prompting.**\\n\\nInspired by COT (Wei et al., 2022b), we designed prompts that ask the LLM to think about how to optimize the program before actually producing the optimized program. This strategy is used in conjunction with few-shot prompting (Examples of prompts in Figure 14 in Appendix A.11).\\n\\n**Dynamic retrieval-based few-shot prompting.**\\n\\nRecent work has demonstrated that retrieval-based mechanisms can improve language models for various tasks requiring factual or procedural knowledge (Liu et al., 2021; Poesia et al., 2021; Rubin et al., 2022; Madaan et al., 2022; Shrivastava et al., 2023). Program optimization is a non-trivial task requiring knowledge of algorithms, data structures, and programming grounded in performance; thus, retrieving highly relevant examples may improve an LLM's optimization ability. For example, a solution optimized for a knapsack problem in dynamic programming could inform strategies for the coin change problem. Through dynamic retrieval-based prompts, we aim to match tasks with analogous structures or challenges, allowing models to better harness the patterns in PIE. We use the CodeBertScore models trained for C++ (Zhou et al., 2023b) to embed both the program to be optimized and the programs in PIE. We use FAISS (Johnson et al., 2019) to retrieve $K$ closest programs from the training set; and to construct a \\\"slow $1 \\\\rightarrow$ fast $1 || \\\\ldots\\\" style prompt on the fly (See Figure 15 in Appendix A.11).\\n\\n### 3.2 Finetuning\\n\\nWe also consider fine-tuning to improve pretrained code LLMs using our PIE dataset. In addition to standard fine-tuning on the entire dataset, we describe additional strategies we used.\\n\\n**Dataset imbalance.**\\n\\nWhile we have tens of thousands of slow-fast pairs in the PIE training dataset, these submissions target just 1,474 problems, which may limit the learned model's ability to generalize to new programs. Furthermore, submissions are not uniformly distributed across problems. To address this imbalance, we additionally fine-tune with a subset of 4,085 \\\"high-quality\\\" slow-fast pairs\u2014in particular, we take\\n\\n2 This assumes gem5 terminates. Our experiments use a two-minute timeout, which may introduce slight variability. Note that altering this timeout could change the results.\\n\\n3 https://github.com/darchr/gem5-skylake-config\"}"}
{"id": "ix7rLVHXyY", "page_num": 5, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"examples with the highest speedup and disallow more than 4 submission pairs per problem, for an average of 2.77 pairs per problem. Given the high costs of training models through the OpenAI API, we also use this dataset as a base for fine-tuning experiments with GPT-3.5.\\n\\nPerformance-conditioned generation. Programs can typically be written in many ways with different performance profiles. Consequently, when training a model to predict performance-improving edits with a large dataset like PIE, it is trained on a mix of large and small improvements, without any information on which improvements are more desirable than others. Inspired by recent prompting strategies (Zhang et al., 2023) and offline-rl (Chen et al., 2021a), we introduce performance tags during training by associating each \u201cfast\u201d program with a tag indicating the optimal achievable performance across all solutions in the dataset. Specifically, the tag indicates how close that program is to peak performance on a binned-scale \\\\{1, 2, \\\\ldots, 10\\\\}. We instantiate our tags by categorizing the top 10% of optimized solutions in the dataset for a given task as \u201c10/10\u201d, the next 10% as \u201c9/10\u201d, and so on. These tags enable the model to discern the relationship between specific problem attributes and their corresponding high-performance solutions (Figure 2, left). During inference, we prompt the model with a test input and a maximal score tag \u201c10/10\u201d, directing it to generate a highly-optimized solution (Figure 2, right).\\n\\nThis is a slow program we want to optimize to score \\\\{score_tag\\\\}/10.\\n\\n### Program:\\n\\n```\\n{src_code}\\n```\\n\\n### Optimized Version with score \\\\{score_tag\\\\}/10:\\n\\n```\\n{fast_code}\\n```\\n\\nThis is a slow program we want to optimize to score 10/10.\\n\\n### Program:\\n\\n```\\n{src_code}\\n```\\n\\n### Optimized Version:\\n\\n```\\n{fast_code}\\n```\\n\\nFigure 2: Training (left) and inference (right) prompts for Goal-Conditioned optimization with PIE.\\n\\nSynthetic data. Given the high cost of obtaining human-written programs, we also augment our dataset with synthetic examples through a multi-stage process. First, we prompt OpenAI\u2019s GPT-3.5 with examples from the PIE dataset, instructing it to produce novel competitive programming problems. After filtering out programs with input/output behavior identical to those in PIE and tracking semantic duplicates among those generated, we obtain 3,314 unique synthetic programs and many thousand more duplicates. Using these novel programs, we then generate an optimized version for each synthetic program using a GPT-3.5 model that has been fine-tuned on the original PIE dataset. Finally, we keep pairs where the optimized program is at least 5 \\\\times faster and limit semantic duplicates to three, resulting in 1,485 optimized synthetic examples. This methodology aligns with self-play and self-instruct approachs in neural program synthesis (Haluptzok et al., 2022; Rozi\u00e8re et al., 2023). We provide additional details on the generation process in Appendix A.6.\\n\\n4 EXPERIMENTS\\n\\nModels. We evaluate and adapt models from the CODELLAMA models (Rozi\u00e8re et al., 2023) and models from OpenAI available through their API. We also used pretrained checkpoints of (Rozi\u00e8re et al., 2023): CODELLAMA{7B,13B,34B} obtained via HuggingFace (Wolf et al., 2020). For the CODELLAMA family of models, we use the base set of models that have not been instruction-tuned, as the authors of the paper note that instruction-tuning diminished the performance on code generation. We provide training details.\"}"}
{"id": "ix7rLVHXyY", "page_num": 10, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"ACKNOWLEDGEMENTS\\n\\nWe extend our gratitude towards Herman Schmit, Chandu Thekkath, James Laudon, Cliff Young, and Stella Aslibekyan for reviewing the paper and providing insightful feedback. We also thank the extended team at Google DeepMind who enabled and supported this research direction. This material is partly based on research sponsored in part by the Air Force Research Laboratory (agreement number FA8750-19-2-0200 and award W911NF-20-1-0080). The U.S. Gov't is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the Air Force Research Laboratory or the U.S. Government.\\n\\nREFERENCES\\n\\nMansi Agnihotri and Anuradha Chug. A Systematic Literature Survey of Software Metrics, Code Smells and Refactoring Techniques. Journal of Information Processing Systems, 2020.\\n\\nAlfred V Aho, Ravi Sethi, and Jeffrey D Ullman. Compilers: Principles, Techniques, and Tools, volume 2. Addison-wesley Reading, 2007.\\n\\nDavid F Bacon, Susan L Graham, and Oliver J Sharp. Compiler Transformations for High-Performance Computing. CSUR, 1994.\\n\\nNathan Binkert, Bradford Beckmann, Gabriel Black, Steven K. Reinhardt, Ali Saidi, Arkaprava Basu, Joel Hestness, Derek R. Hower, Tushar Krishna, Somayeh Sardashti, Rathijit Sen, Korey Sewell, Muhammad Shoaib, Nilay Vaish, Mark D. Hill, and David A. Wood. The gem5 Simulator. SIGARCH Comput. Archit. News, 2011.\\n\\nAymeric Blot and Justyna Petke. MAGPIE: Machine Automated General Performance Improvement via Evolution of Software. arXiv preprint arXiv:2208.02811, 2022.\\n\\nTom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. Language Models are Few-shot Learners. NeurIPS, 2020.\\n\\nBinghong Chen, Daniel Tarlow, Kevin Swersky, Martin Maas, Pablo Heiber, Ashish Naik, Milad Hashemi, and Parthasarathy Ranganathan. Learning to Improve Code Efficiency. arXiv preprint arXiv:2208.05297, 2022.\\n\\nLichang Chen, Shiyang Li, Jun Yan, Hai Wang, Kalpa Gunaratna, Vikas Yadav, Zheng Tang, Vijay Srinivasan, Tianyi Zhou, Heng Huang, et al. AlpaGasus: Training A Better Alpaca with Fewer Data. arXiv preprint arXiv:2307.08701, 2023.\\n\\nLili Chen, Kevin Lu, Aravind Rajeswaran, Kimin Lee, Aditya Grover, Misha Laskin, Pieter Abbeel, Aravind Srinivas, and Igor Mordatch. Decision Transformer: Reinforcement Learning via Sequence Modeling. NeurIPS, 2021a.\\n\\nMark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, Alex Ray, Raul Puri, Gretchen Krueger, Michael Petrov, Heidy Khlaaf, Girish Sastry, Pamela Mishkin, Brooke Chan, Scott Gray, Nick Ryder, Mikhail Pavlov, Alethea Power, Lukasz Kaiser, Mohammad Bavarian, Clemens Winter, Philippe Tillet, Felipe Petroski Such, Dave Cummings, Matthias Plappert, Fotios Chantzis, Elizabeth Barnes, Ariel Herbert-Voss, William Hebgen Guss, Alex Nichol, Alex Paino, Nikolas Tezak, Jie Tang, Igor Babuschkin, 10\"}"}
{"id": "ix7rLVHXyY", "page_num": 11, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":null}"}
{"id": "ix7rLVHXyY", "page_num": 12, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":null}"}
{"id": "ix7rLVHXyY", "page_num": 13, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":null}"}
{"id": "ix7rLVHXyY", "page_num": 6, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 1: Summary of Results\\n\\nThis table reports our strongest performing models by SPEEDUP across different adaptation regimes covered in subsequent sections. We report results for Open-access CODELLAMA (O) and black-box or private OpenAI models (P). The highest number in each column is bolded and the second-highest is underscored.\\n\\n| Scenario       | Model                  | %Opt | Speedup | %Correct |\\n|----------------|------------------------|------|---------|----------|\\n| Human reference| 100.00%                |      | 3.66 \u00d7 100.00% | 100.00% |\\n| Prompt (O)     | CODELLAMA 34B, CoT     | 19.63%| 1.30 \u00d7 78.73% | 106%     |\\n| Prompt (P)     | GPT-3.5, CoT           | 43.05%| 1.60 \u00d7 91.72% | 107%     |\\n| Retrieval (O)  | CODELLAMA 34B          | 42.54%| 2.43 \u00d7 73.62% | 104%     |\\n| Retrieval (P)  | GPT 4                 | 76.07%| 3.93 \u00d7 95.71% | 102%     |\\n| FineTune (O)   | CODELLAMA 13B-PC       | 66.56%| 5.65 \u00d7 70.96% | 103%     |\\n| FineTune (P)   | GPT-3.5, SP            | 87.63%| 6.86 \u00d7 95.09% | 103%     |\\n\\nAs described in Section 2, we count a program as functionally correct if it passes every test case in our dataset. Though correctness is not our primary focus, we include it to help interpret our results. In addition, we report our SPEEDUP as the average speedup across all test set examples. For generations that are either incorrect or slower than the original program, we use a speedup of 1.0 for that example, given that, in the worst case, the original program has a speedup of 1.0. We benchmark performance using our gem5 environment and all test cases mentioned in Section 2. We compile all C++ programs with GCC version 9.3.0 and C++17 as well as the -O3 optimization flag; therefore, any reported improvements would be those on top of the optimizing compiler.\\n\\n4.1 RESULTS FOR FEW-SHOT PROMPTING\\n\\nBaseline few-shot prompting. Table 2 shows results on few-shot prompting techniques (Section 3.1, prompts in appendix A.11). We find that few-shot prompts often yield similar results compared to simple...\"}"}
{"id": "ix7rLVHXyY", "page_num": 7, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 2: Baselines: Results for baseline prompting strategies and models for Best@1 and Best@8.\\n\\n| Method       | Model    | %Opt Speedup | %Correct | %Opt Speedup | %Correct |\\n|--------------|----------|--------------|----------|--------------|----------|\\n| Instruction-Only | CODELLAMA 7B  | 0.92%       | 1.01\u00d7    | 23.52%       | 68.30%   |\\n| Instruction-Only | CODELLAMA 13B  | 0.41%       | 1.00\u00d7    | 10.02%       | 40.49%   |\\n| Instruction-Only | CODELLAMA 34B  | 2.86%       | 1.05\u00d7    | 44.27%       | 84.97%   |\\n| Instruction-Only | GPT -3.5  | 16.26%       | 1.20\u00d7    | 80.67%       | 98.77%   |\\n| Instruction-Only | GPT -4  | 8.49%        | 1.15\u00d7    | 93.25%       | 98.77%   |\\n| Few-Shot     | CODELLAMA 7B  | 2.15%       | 1.02\u00d7    | 43.46%       | 85.07%   |\\n| Few-Shot     | CODELLAMA 13B  | 2.25%       | 1.02\u00d7    | 40.29%       | 83.03%   |\\n| Few-Shot     | CODELLAMA 34B  | 2.66%       | 1.02\u00d7    | 43.97%       | 82.62%   |\\n| Few-Shot     | GPT -3.5  | 11.45%       | 1.13\u00d7    | 80.98%       | 95.91%   |\\n| Few-Shot     | GPT -4  | 18.92%       | 1.25\u00d7    | 82.82%       | 98.98%   |\\n| COT          | CODELLAMA 7B  | 0.82%       | 1.01\u00d7    | 27.40%       | 73.31%   |\\n| COT          | CODELLAMA 13B  | 2.25%       | 1.04\u00d7    | 32.92%       | 79.24%   |\\n| COT          | CODELLAMA 34B  | 3.99%       | 1.08\u00d7    | 30.27%       | 78.73%   |\\n| COT          | GPT -3.5  | 21.37%       | 1.25\u00d7    | 65.95%       | 91.72%   |\\n| COT          | GPT -4  | 26.99%       | 1.32\u00d7    | 63.09%       | 84.87%   |\\n\\nFor instance, when prompted with instructions alone, both GPT -3.5 and CODELLAMA 34B demonstrated better %Opt Speedup and %Correct metrics. This observation aligns with the findings of Zhao et al. (2021), which highlighted that few-shot examples can sometimes bias the model and lead to an incorrect understanding of the task. In the context of our study, the consistent use of the same fixed prompt might constrain the model to only apply optimization techniques present in the prompt, thereby resulting in sub-optimal performance. Finally, in line with the findings of Wei et al. (2022a) that identified COT prompting as an emergent capability, we observe improvements with this approach over both instruction-tuned and fixed prompt setups, but notably only for the larger CODELLAMA (13B and 34B) and GPT -3.5 models. For CoT prompting, we note that GPT -4 outperforms GPT -3.5 Best@1 and under-performs GPT -3.5 Best@8: this may demonstrate a lack of output diversity from GPT 4 despite using the same sampling hyper-parameters.\\n\\nRetrieval-based few-shot prompting. Table 2 (bottom) shows results using our dynamic retrieval-based few-shot prompting strategy, with a preferable setting at K = 4 retrieved prompts. Extended results for K \u2208 {1, 2, 4} are detailed in Appendix A.7. The results show that dynamic few-shot prompting outperforms all the baseline variants, showing that PIE effectively adapts LLMs for program optimization in few-shot settings. We note that increased speedup may, however, come with some cost of correctness.\\n\\nTable 3: Dynamic retrieval-based few-shot prompting: Results for dynamic retrieval-based few-shot prompting across models for Best@1 and Best@8.\\n\\n| Method               | Model    | %Opt Speedup | %Correct | %Opt Speedup | %Correct |\\n|----------------------|----------|--------------|----------|--------------|----------|\\n| Dynamic Retrieval, K=4 | CODELLAMA 7B  | 6.34%       | 1.19\u00d7    | 23.11%       | 57.98%   |\\n| Dynamic Retrieval, K=4 | CODELLAMA 13B  | 9.30%       | 1.29\u00d7    | 26.99%       | 62.58%   |\\n| Dynamic Retrieval, K=4 | CODELLAMA 34B  | 11.66%      | 1.34\u00d7    | 30.57%       | 73.62%   |\\n| Dynamic Retrieval, K=4 | GPT -3.5  | 28.02%       | 1.55\u00d7    | 79.65%       | 95.71%   |\\n| Dynamic Retrieval, K=4 | GPT -4  | 51.02%       | 2.53\u00d7    | 79.35%       | 95.71%   |\"}"}
{"id": "ix7rLVHXyY", "page_num": 8, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Fine-tuning with PIE substantially improves all models. We fine-tune CODELLAMA and GPT-3.5 models on our PIE dataset. Due to the cost of fine-tuning and sampling models through the OpenAI API, we were only able to train GPT-3.5 on the smaller, high-quality dataset (HQ) in Section 3.2. The top of Table 4 shows results for traditional fine-tuning on all models. We see substantially stronger results when fine-tuning on the smaller, high-quality dataset. These results reflect the observation that to adapt LLMs, a small set of high-quality examples can elicit strong performance (Zhou et al., 2023a; Chen et al., 2023).\\n\\nPerformance-conditioned training outperforms fine-tuning. Table 4 shows results for performance-conditioned (PERF-COND) generation (Section 3.2). Both fine-tuned CODELLAMA models (7B and 13B) show significant improvements in %OPT and SPEEDUP. These gains highlight how the performance improvement information (Figure 2) can enable models to distinguish optimal and sub-optimal solutions, leading to more effective optimizations.\\n\\nSynthetic data from self-play marginally improves generalization. Next, we fine-tuned both CODELLAMA and GPT-3.5 using our PIE dataset augmented with our synthetic examples. We show results at the bottom of Table 4. For CODELLAMA and GPT-3.5, compared to using no synthetic data, the additional data improves both %OPT and often SPEEDUP, particularly with BEST@1. We believe the small set of synthetic examples helped generalize the fine-tuned model, as evidenced by the higher %OPT.\\n\\nModel vs. Human Fastest Possible Speedup. We compared the fastest human submissions in CodeNet for the test set with our model's fastest generation per problem. The comparison involved 39,129 model generations against 118,841 human accepted solutions (or 197,921 including incorrect or timed-out submissions). For the PIE dataset, the best human speedup achieved was 9.56\u00d7, while our model achieved a slightly higher speedup of 9.64\u00d7, setting a new upper limit.\\n\\nTable 4:\\n\\n| Dataset  | Model       | %Opt | Speedup | %Correct | Speedup | %Correct |\\n|----------|-------------|------|---------|----------|---------|----------|\\n| All      | CODELLAMA 7B| 9.20%| 1.31\u00d7   | 55.21%   | 2.21\u00d7   | 74.03%   |\\n| All      | CODELLAMA 13B| 12.78%| 1.52\u00d7  | 55.42%   | 2.71\u00d7   | 75.46%   |\\n| HQ       | CODELLAMA 7B| 10.33%| 1.40\u00d7  | 76.38%   | 3.14\u00d7   | 87.63%   |\\n| HQ       | CODELLAMA 13B| 11.55%| 1.43\u00d7  | 70.55%   | 3.43\u00d7   | 85.07%   |\\n| HQ + Self-Play | CODELLAMA 7B| 15.34%| 1.59\u00d7  | 75.77%   | 3.32\u00d7   | 87.42%   |\\n| HQ + Self-Play | CODELLAMA 13B| 14.31%| 1.61\u00d7  | 76.28%   | 3.51\u00d7   | 86.20%   |\\n| HQ + Self-Play | GPT-3.5       | 45.50%| 3.02\u00d7  | 87.63%   | 6.86\u00d7   | 95.09%   |\\n\\nFor GPT-3.5, to be sure the increases came from the type of data and not the quantity of data, we performed an ablation by fine-tuning on the top 5,793 examples from PIE with a maximum of 8 duplicates (instead of the 5,570 pairs that included synthetic programs), and we saw BEST@1 performance degrade by 8%.\"}"}
{"id": "ix7rLVHXyY", "page_num": 9, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"4.3 DISCUSSION AND KEY TAKEAWAYS\\n\\nCODELLAMA vs. GPT-3.5. Our results demonstrate that openly available models such as CODELLAMA can be competitive with GPT-3.5. For prompting, CODELLAMA 34B with dynamic retrieval (42.54% %OPT, 2.43\u00d7 SPEEDUP for BEST@8) roughly matched the performance of GPT-3.5 with dynamic retrieval (51.64% %OPT, 2.19\u00d7 SPEEDUP for BEST@8). With fine-tuning, CODELLAMA 13B with performance-conditioned generation (66.56% %OPT, 5.65\u00d7 SPEEDUP for BEST@8) approached the performance of GPT-3.5 with synthetic data (87.63% %OPT, 6.86\u00d7 SPEEDUP for BEST@8); indeed, we may expect that fine-tuning CODELLAMA 34B using the same strategy would further bridge this gap. These results demonstrate that with the right adaptation strategies, open models can be competitive with private ones.\\n\\nPrompting vs. fine-tuning. Our results demonstrate that while prompting can be an effective way to adapt models (with retrieval), fine-tuning significantly outperforms prompting for models of the same size.\\n\\nEffectiveness of retrieval-based few-shot learning. Our results show that dynamic retrieval provides enormous gains over all other prompting approaches; for instance, it improved the performance of CODELLAMA 34B from 19.63% %OPT, 1.30\u00d7 SPEEDUP to 34.25% %OPT, 2.28\u00d7 SPEEDUP for BEST@8.\\n\\nEffectiveness of performance-conditioned generation. We find that performance-conditioned generation is incredibly effective for achieving good performance; in particular, it improved the performance of CODELLAMA 13B from 47.75% %OPT, 3.43\u00d7 SPEEDUP to 66.56% %OPT, 5.65\u00d7 SPEEDUP for BEST@8.\\n\\n5 RELATED WORK\\n\\nMachine learning has been applied to improve performance by refactoring code (Mens & Tourw\u00e9, 2004; Agnihotri & Chug, 2020), identify compiler transformations (Bacon et al., 1994; Talaashrafi, 2022), perform parameter search (Hamadi, 2013; Huang et al., 2019; Kaufman et al., 2021; Seshadri et al., 2022; Kumar et al., 2022), auto-vectorize code (Nuzman et al., 2006; Mendis et al., 2019), optimize GPU code (Liou et al., 2020; Cummins et al., 2021), and automatically select algorithms (Kotthoff, 2016; Kerschke et al., 2019) and room at the top (Leiserson et al., 2020; Sherry & Thompson, 2021). DeepPERF (Garg et al., 2022) uses a transformer-based model fine-tuned to generate performance improvement patches for C# applications. Additionally, Chen et al. (2022) uses a discrete variational auto-encoder, each latent representation maps to a different category of code edits, and canonicalized code representations to automatically suggest performance improvements, Shypula et al. (2021) trains seq2seq models from scratch on optimization data to superoptimize assembly programs after compilation, Shi et al. (2019) trains tree-LSTM from scratch with RL to superoptimize halide IR, and MAGPIE (Blot & Petke, 2022) uses genetic algorithms for tasks including optimization. AlphaCode (Li et al., 2022) leverages language models to generate solutions to competitive programming problems in natural language, but it does not attempt to improve the performance of existing solutions. In contrast, we focus on adapting pre-trained LLMs (Chen et al., 2021b; Nijkamp et al., 2022; Tunstall et al., 2022; Xu et al., 2022; Fried et al., 2022) to performance optimization.\\n\\n6 CONCLUSION\\n\\nOur work is an initial step towards unlocking the potential of LLMs in leveraging the opportunities at the \u201ctop\u201d of the computing stack. In particular, we improve algorithmic efficiency and, given a correctness oracle, enable automatic code optimization beyond optimizing compilers. Our results pave an exciting path for improving computing efficiency post Moore\u2019s law.\"}"}

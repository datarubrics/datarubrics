{"id": "Bo7eeXm6An8", "page_num": 13, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":null}"}
{"id": "Bo7eeXm6An8", "page_num": 14, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. CoRR, abs/1706.03762, 2017. URL http://arxiv.org/abs/1706.03762.\\n\\nYue Wang, Weishi Wang, Shafiq R. Joty, and Steven C. H. Hoi. Codet5: Identifier-aware unified pre-trained encoder-decoder models for code understanding and generation. CoRR, abs/2109.00859, 2021. URL https://arxiv.org/abs/2109.00859.\\n\\nZhiruo Wang, Grace Cuenca, Shuyan Zhou, Frank F Xu, and Graham Neubig. Mconala: A benchmark for code generation from multiple natural languages. arXiv preprint arXiv:2203.08388, 2022.\\n\\nPengcheng Yin, Bowen Deng, Edgar Chen, Bogdan Vasilescu, and Graham Neubig. Learning to mine aligned code and natural language pairs from stack overflow. In International Conference on Mining Software Repositories, MSR, pp. 476\u2013486. ACM, 2018. doi: https://doi.org/10.1145/3196398.3196408.\\n\\nJiyang Zhang, Sheena Panthaplackel, Pengyu Nie, Junyi Jessy Li, and Milos Gligoric. Coditt5: Pre-training for source code and natural language editing. arXiv preprint arXiv:2208.05446, 2022a.\\n\\nSusan Zhang, Stephen Roller, Naman Goyal, Mikel Artetxe, Moya Chen, Shuohui Chen, Christopher Dewan, Mona Diab, Xian Li, Xi Victoria Lin, Todor Mihaylov, Myle Ott, Sam Shleifer, Kurt Shuster, Daniel Simig, Punit Singh Koura, Anjali Sridhar, Tianlu Wang, and Luke Zettlemoyer. Opt: Open pre-trained transformer language models, 2022b. URL https://arxiv.org/abs/2205.01068.\\n\\nMing Zhu, Aneesh Jain, Karthik Suresh, Roshan Ravindran, Sindhu Tipirneni, and Chandan K Reddy. Xlcost: A benchmark dataset for cross-lingual code intelligence. arXiv preprint arXiv:2206.08474, 2022.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 15, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"A Extended Discussion\\n\\nA.1 Implication of findings\\nA.2 Implication of Evaluation Data at Scale\\nA.3 Possibilities of true generalization\\nA.4 Potential proxy for general coding capabilities\\nA.5 Limitations\\nA.6 Generation tendency versus generation ability\\n\\nB Other Related Work\\n\\nC Evaluation Setup\\n\\nC.1 Sample Generation\\nC.2 Stopping Criteria\\nC.3 Code Execution\\n\\nD Evaluation Results on Additional Datasets\\n\\nD.1 Multi-lingual MathQA\\nD.2 Multi-lingual HumanEval\\n\\nE Language \\\"Spillover\\\" in Training Data\\n\\nE.1 Types of Cross-Language Data Spillover\\nE.2 Example 1: Embedded JavaScript in Python files\\nE.3 Example 2: Java and Python integration as Jython\\n\\nF Execution-Based Function Completion Results\\n\\nF.1 Performance Trend with Respect to Model Size\\nF.2 Comprehensive Sampling Results\\n\\nG Few-Shot Prompting\\n\\nG.1 Evaluation Results\\nG.2 Qualitative Examples\\n\\nH Translation\\n\\nH.1 Translation Results from Various Language Sources\\nH.2 Comparing translation performance of multi-lingual and mono-lingual models\\nH.3 Generated Translation Examples\\n\\nI Analysis: Effects of few-shot and translation prompts\\n\\nI.1 Test case error versus non-assertion error\\nI.2 Solve rate per problem due to few-shot prompting and translation\\n\\nJ Robustness Evaluation: r-MBXP\\n\\nJ.1 Dataset Preparation and Evaluation Setup\\nJ.2 Evaluation Results\\nJ.3 Qualitative Examples\\n\\nK Code Insertion: i-MBXP\\n\\nK.1 Dataset Preparation\\nK.2 Evaluation Setup\\nK.3 Evaluation Results\"}"}
{"id": "Bo7eeXm6An8", "page_num": 16, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"K.4 Qualitative examples for i-MBXP.\\n\\nL. Code Summarization: s-MBXP\\n\\nL.1 Dataset Preparation and Evaluation Setup\\n\\nL.2 Evaluation Results\\n\\nL.3 Qualitative Examples\\n\\nM. Evaluating Public Models\\n\\nN. Training\\n\\nN.1 Model architecture and training details\\n\\nN.2 Observations on validation losses versus performance\\n\\nO. Dataset Conversion Framework\\n\\nO.1 Language Conversion of Prompts and Test Cases\\n\\nO.2 Potential Use of Transcoder for Dataset Construction\\n\\nP. Synthetic Canonical Solutions\\n\\nP.1 Multi-stage data bootstrapping\\n\\nP.2 Discussion: Ground truth assumptions of test cases\\n\\nQ. Quality Check of Converted Datasets\\n\\nR. Datasets\\n\\nR.1 MBXP\\n\\nR.2 Multi-lingual HumanEval\\n\\nR.3 Multi-lingual MathQA\"}"}
{"id": "Bo7eeXm6An8", "page_num": 1, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"We present two new benchmarks, MBXP and Multilingual HumanEval, designed to evaluate code generation models in over 10 programming languages. These datasets are generated using a conversion framework that transpiles prompts and test cases from the original MBPP and HumanEval datasets into the corresponding data in the target language. By using these benchmarks, we are able to assess the performance of code generation models in a multi-lingual fashion, and discovered generalization ability of language models on out-of-domain languages, advantages of multi-lingual models over mono-lingual, the ability of few-shot prompting to teach the model new languages, and zero-shot translation abilities. In addition, we use our code generation model to perform large-scale bootstrapping to obtain synthetic canonical solutions in several languages, which can be used for other code-related evaluations such as code insertion, robustness, or summarization tasks.\\n\\n1 INTRODUCTION\\n\\nCode completion by machine-learning models has great potential to improve developer productivity (Barke et al., 2022). This line of research has seen tremendous progress with several models recently proposed such as Codex (Chen et al., 2021), CodeGen (Nijkamp et al., 2022), PaLM (Chowdhery et al., 2022), BLOOM (Mitchell et al., 2022), and InCoder (Fried et al., 2022).\\n\\nOne key component for code generation research is how to evaluate such program synthesis abilities. In the literature, two primary evaluation approaches emerged, namely, the match-based and the execution-based evaluations. For both approaches, each problem contains a prompt which a model uses as input to generate a candidate body of code. The match-based evaluation compares the candidate code against reference source code using n-gram metrics such as BLEU, whereas the execution-based evaluation executes the candidate code against test cases and calculates success rate. The execution-based evaluation has benefits over the n-gram evaluation in that it permits solutions that are functionally correct but might not be equivalent to the reference solution in terms of the exact implementation. Since the release of datasets such as HumanEval (Chen et al., 2021) or MBPP (Austin et al., 2021), the community has been widely adopting the execution-based approach as a primary tool to evaluate program generation capabilities. However, creating execution-based evaluation datasets is time-consuming since it requires careful construction of test cases to check the correctness of the code's functionality. Such difficulty leads to limited available of execution-based evaluation data. For instance, to date, many execution-based datasets contain only problems in Python.\\n\\n\u2020 Corresponding authors {benathi,skgouda,zijwan,xiaopel,tiayuche,bxiang}@amazon.com\\n\\n* We release the data and evaluation code at https://github.com/amazon-research/mbxp-exec-eval.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 2, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"In this work, we propose a scalable framework for dataset conversion from Python to many different languages. While translating code from one language to another is typically a non-trivial task, it is possible to convert existing execution-based datasets to another language by transforming only prompts and test statements (see Figure 1 part A and Figure 2). That is, the purpose of evaluating function completion ability, we do not need the canonical solution since it is not used during evaluation. The function signature prompts and test cases of basic programming problems involve sufficiently simple data structures that can be analyzed to synthesize datasets in new languages. Without having to translate the generic function body of code to another language, the conversion process becomes possible via a rule-based transpiler.\\n\\nThe result of such conversion are two benchmarks, MBXP (Most Basic X [Python/Java/Go/Ruby, etc.] Programming Problems) and Multilingual HumanEval, which are derived from the original Python dataset MBPP (Austin et al., 2021) and HumanEval (Chen et al., 2021). We provide the evaluation data in many languages besides the original Python, namely, Java, JavaScript, TypeScript, Go, Ruby, Kotlin, PHP, C#, Scala, C++, Swift, and Perl, with plans for more language expansion in the future. Along with these datasets, we also release a code package to perform execution in all supported languages. In addition, our conversion framework is easily extensible and allows us to obtain the multi-lingual version of other existing datasets such as MathQA (Schubotz et al., 2019). In the main paper, we provide results and analyses mostly on MBXP where the results on Multilingual HumanEval and MathQA can also be found in Appendix D.\\n\\nOur benchmarks also support other code completion tasks such as code insertion or translation in many languages. This extension is made possible by performing large-scale bootstrapping to synthesize solutions (Section O.1.11). The result of our dataset conversion framework and the solution synthesis process is, to date, the first multi-lingual execution-based evaluation benchmark equipped with canonical solutions, which can be adapted for many code-related evaluations. In this paper, we process MBXP for multiple use cases, namely, for zero-shot translation t-MBXP, prompt robustness r-MBXP, code insertion i-MBXP, and the summarization s-MBXP.\\n\\nOverall, the constructed datasets provides us new opportunities to explore many facets of code generation abilities. In this work, we conduct a large scale evaluation where we train models of various sizes spanning three orders of magnitude (from $\\\\sim 100M$ to $\\\\sim 10B$ parameters) in both multi-lingual and mono-lingual settings. We analyze results from hundreds of thousands of code generation samples to investigate the models' code generation abilities with respect to in-domain versus out-of-domain languages, the effectiveness of few-shot prompting, zero-shot translation abilities, robustness to prompt perturbation, code summarization, and code insertion.\\n\\n### FINDING HIGHLIGHTS\\n\\nWe provide the highlights of our findings below.\\n\\n1. Given the same model size, a multi-lingual model often outperforms the best of mono-lingual models trained with equivalent training resources, especially when the models are sufficiently large. This observation indicates that it is beneficial to train a single model on all programming languages, and provided that the model size has enough capacity, the performance will be better than the best of monolingual models.\\n\\n2. Language models are able to generate code with correct syntax and pass unit tests in programming languages they are not intentionally trained on. We hypothesize that the data \\\"spillover\\\" effect, where code in one language is present in other languages through code\"}"}
{"id": "Bo7eeXm6An8", "page_num": 3, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"def binomial_coeff(n, k):\\n    \"\"\"Write a Python function to find binomial coefficient.\\n    >>> binomial_coeff(5,2)\\n    10\\n    \"\"\"\\n    if k > n:\\n        return 0\\n    if k == 0 or k == n:\\n        return 1\\n    return binomial_coeff(n - 1, k - 1) + binomial_coeff(n - 1, k)\\n\\nassert binomial_coeff(5,2) == 10\\nassert binomial_coeff(4,3) == 4\\nassert binomial_coeff(3,2) == 3\\n\\nclass BinomialCoeff{\\n    /* Write a Java function to find binomial coefficient.\\n     * > BinomialCoeff.binomialCoeff(5, 2)\\n     * 10\\n     */\\n    public static int binomialCoeff(int n, int k)\\n    {\\n        class Main\\n        {\\n            public static void main(String [] args)\\n            throws Exception\\n            {\\n                int x0 = BinomialCoeff.binomialCoeff(5, 2);\\n                if (!x0.equals(10))\\n                {\\n                    throw new java.lang.Exception(\\\"Exception -- test case 0 did not pass. x0 =\\\");\\n                }\\n                if (n < k)\\n                return 0;\\n                int res = 1;\\n                for (int i = 1; i <= k; i ++)\\n                {\\n                    res *= (n + 1 - i);\\n                    res /= i;\\n                }\\n                return res;\\n            }\\n        }\\n    }\\n\\nFigure 2: Conversion of formatted MBPP (Python) to MBJP (Java).\\n\\n3. The occurrences of multi-lingual data in natural data also explains the superior performance of multi-lingual over mono-lingual models. That is, the multi-lingual model can perform better on language A since it can pick up and combine all knowledge of language A from the training data in languages A, B, C, etc. in the multi-lingual setting.\\n\\n4. Few-shot prompting can effectively help teach provide knowledge on a new language the model has not seen, significantly improving out-of-domain code generation abilities. Through error analysis, few-shot prompting helps reduce compilation or parsing errors that are the major sources of errors when it comes to a programming language the model is not familiar with.\\n\\n5. Language models have zero-shot code translation abilities; that is, even though they are not specifically trained to perform translation, they are able to use reference code in one language to improve code generation in another language. Problems that are difficult can become much easier with access to another language\u2019s solution. This observation holds for mono-lingual as well as multi-lingual models.\\n\\n6. Multi-lingual models are also more robust to prompt perturbation and better at summarizing code.\\n\\n3 CONVERSION OF EXECUTION-BASED EVALUATION DATASETS\\n\\nIn this section, we provide high-level details on the data conversion process. Figure 2 illustrates the mapping of the original Python prompt, consisting of a function signature and a docstring, to an equivalent prompt in Java (which we call a target prompt). The target prompt is a valid code including a function signature from which the model can use to complete the function body. In the case of Java or typed languages, constructing the target prompt requires inferring input and output types. We perform such type inference by parsing the original test cases, taking into account heterogeneous data types. For instance, if the first argument includes values of types int and float, we deduce it to have the most general type of all types encountered. The converted prompt also needs to work in harmony with the converted test cases. For instance, the Java test case in Figure 2 refers to the defined class BinomialCoeff and the defined method binomialCoeff in the converted prompt with appropriate function call based on the defined argument list. For more details including data validation and generated solutions via bootstrapping, see Appendix O.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 4, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"From the previous section, we have established a framework to perform dataset conversion, from which we obtain a collection of execution-based evaluation datasets in 10+ programming languages. These evaluation datasets contain rich information in the prompts including natural language description as well as appropriate function signatures that help steer a model to generate code in a particular language. Most importantly, they also contain test cases in the respective language that can be used to check code correctness, which is applicable for most types of evaluation in MBXP+.\\n\\nThis section describes the training, evaluation setup, and findings from each evaluation task.\\n\\n4.1 DATA AND MODELS\\n\\nFor the purpose of this work, we collected training data in three primary programming languages, namely, Python, Java, and JavaScript, containing permissively licensed code data from GitHub. Following Chen et al. (2021); Nijkamp et al. (2022), we perform filtering, deduplication, and remove data that contains a significant amount of non-English text or is not parsable with respect to that language's syntax parser. We also ensure the original MBPP and HumanEval datasets are not included in data. After all the post processing steps, our dataset contains 101 GB Python, 177 GB Java, and 216 GB JavaScript data.\\n\\nWe use a decoder-only transformers as the model architecture and train the models via next-token prediction loss (Vaswani et al., 2017; Brown et al., 2020). We design our training to compare multi-lingual versus mono-lingual settings by using the same compute budget for each language in both cases. In particular, we train mono-lingual models on 210 billion tokens with their respective languages (Python, Java, and JavaScript) and train multi-lingual models on 210 billion tokens from each language, with 630 billion tokens in total. To study effects of model sizes, we train models of various number of parameters, namely, 125M, 672M, 2.7B and 13B. For the synthetic canonical solution process, we use a separate 13B multi-lingual model which we refer to as the 13B model.\\n\\n4.2 EXECUTION-BASED FUNCTION COMPLETION\\n\\nWe use pass@k scores (Kulal et al., 2019) with the unbiased estimate presented in (Chen et al., 2021) as the metrics for our evaluation, where each task is considered successful if any of the k samples are correct. We generate up until the end of the function, such as end of indented function block for Python or until the closing curly brace for PHP or Go, for example (see Appendix C.2 for end of scope details). We refer to an evaluation language that the model is not specifically trained on as out-of-domain with respect to that model. Otherwise, the language is considered in-domain. For instance, Java is out-of-domain for a Python-only model and PHP is out-of-domain for our multi-lingual model trained on Python, Java, and JavaScript.\\n\\n4.2.1 ACCURACY VS. SAMPLING BUDGET\\n\\nOverall, we observe sigmoid-like relationships between pass@k and sampling budget across all datasets in MBXP where the performance increases smoothly as k increases (Figure 3, and Appendix F.2). This trend is consistent with the original MBPP and HumanEval which are manually-annotated. This sigmoid-like performance with respect to sampling budget indicates that problems vary in terms of difficulty, where certain problems require many more attempts to get them right. We do not find a degenerate case in any evaluation language where all problems are either trivial to solve (pass@k saturated near 100%), or impossible (pass@k all zeros). The consistency of the observed performance trend across all programming languages in the MBXP benchmark provides reassurance regarding the benchmark's applicability as a multi-lingual evaluation tool for assessing a model's capabilities at different levels.\\n\\n4.2.2 GENERALIZATION TO OUT-OF-DOMAIN LANGUAGES\\n\\nAs demonstrated in Figure 3, our model can achieve non-zero pass@k scores for out-of-domain languages. We emphasize that our models are not specifically trained on out-of-domain languages since we filter languages based on file extensions and verify that the data have correct syntax with respect to each language (refer to Section 4.1). However, we hypothesize that cross-language data\"}"}
{"id": "Bo7eeXm6An8", "page_num": 5, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 3: \\\\( k \\\\) versus sampling budget for various datasets across MBXP. We observe generalization behavior where the model can write valid code on languages not trained on, as indicated by the non-zero execution scores on out-of-domain evaluation. Model performance also tends to be sigmoid-like; that is, when the performance is on the lower end such as in the out-of-domain case, the curve breaks out upward, similar to the earlier part of the sigmoid function. The behavior also applies for models of other sizes as well as mono-lingual models (not shown in this figure).\\n\\nSpillover are quite typical, since there can be data related to other languages mentioned in code comments, natural texts, or intentionally embedded in cross-lingual code projects. Examples of such projects are Django or Flask, where JavaScript pieces of code can be embedded in Python files for web development, or mixed use of Java and Python code in projects such as Jython. We provide further discussion of types and examples of cross-lingual data occurrences in Appendix E.\\n\\nIn Figure 4a, we also observe that the out-of-domain scores are not symmetric for a given language pair; i.e., Python models perform well on Java but Java models have negligible performance on Python. The data spillover hypothesis supports this observation where it is likely that there are many languages embedded in, e.g., Python files, whereas not as many languages are embedded in Java files. We provide further analyses related to data spillover hypothesis in Section 4.2.3.\\n\\n4.2.3 Multilingual versus Monolingual Models\\n\\nFigure 4a shows a plot of pass \\\\( @k \\\\) scores versus model sizes for multi- and mono-lingual models, where we observe approximate log-linear relationships similar to those found in the literature (Chowdhery et al., 2022; Chen et al., 2021; Nijkamp et al., 2022; Austin et al., 2021; Li et al., 2022a). For small model sizes, we see that multi-lingual models can perform slightly sub-par or on-par to mono-lingual models. For instance, at size 125M and 672M, mono-lingual models outperform multi-lingual models in some evaluation languages such as Python and Ruby. However, once we reach a certain size such as 2.7B or 13B parameters, a large multi-lingual model begins to outperform the best of mono-lingual models in all evaluation languages. The performance gains of multi-lingual over mono-lingual models are particularly significant for out-of-domain languages such as MBPHP and also noticeable for in-domain ones such as MBJSP and MBJP.\\n\\nWe observe that for MBPP, the mono-lingual Java and JavaScript models obtain close to zero pass \\\\( @k \\\\), suggesting that the amount of spillover Python code in Java or JavaScript training data is likely low. This finding coincides with the Python and multi-lingual models achieving near identical MBPP scores in Figure 4a, suggesting that both Python and multi-lingual models observed similar amount of Python code during training. This evidence is consistent with the previous observation that there is little Python code in Java or JavaScript training data.\\n\\nIn contrast, for the JavaScript evaluation (MBJSP) shown in Figure 4a, each of the mono-lingual models obtain reasonable pass \\\\( @k \\\\) scores, suggesting that the spillover of JavaScript code is prevalent (at least in Python and Java data). This finding also explains why the multi-lingual model performs significantly better to the JS model on JS evaluation (MBJSP), as the multi-lingual model learn JS knowledge from other sources, while the mono-lingual JS model's source of knowledge is more limited.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 6, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 4: (a) We observe log-linear relationships between model sizes and scores, with multi-lingual models outperforming mono-lingual ones. This trend persists across all evaluation datasets in MBXP, including out-of-domain languages such as PHP, Ruby, and Kotlin. Interestingly, the performance of MBRBP (Ruby) breaks out of this log-linear trend, as the multi-lingual 13B model performs significantly better than the extrapolated performance would suggest. (b) Despite having higher validation losses for each in-domain language compared to their mono-lingual counterparts, multi-lingual models consistently outperform mono-lingual models in all evaluation datasets in MBXP. On languages such as PHP, Ruby, Kotlin which are outside of the core training data (Python, Java, JS), multi-lingual models are also more capable of learning such languages, as demonstrated in Figure 4a. Overall, the performance in the multi-lingual setting tends to improve more rapidly as they are able to draw knowledge from many sources at once, as observed by higher slopes in the plots (Figure 4a).\\n\\nInterestingly, we note that even though the multi-lingual models perform better during evaluation, the validation losses per language for multi-lingual models are higher than those of mono-lingual models (See Figure 4b). We provide further discussion on validation losses in Appendix N.2.\\n\\n4.3 Zero-Shot Code Translation\\nOur dataset conversion framework yields parallel data in many different languages. These parallel datasets provide a valuable resource for studying the translation abilities of code generation models, as we can evaluate how well the models generate code in any other supported language using the canonical solutions in our source language. For this study, we prepend the function in a source language to the beginning of the function-completion prompt of the target language (Figure 5). We can also think of this setup as a function completion with augmented information, where we provide a reference solution in another language. Therefore, we also refer to the usual function completion setup as the non-translation setting.\\n\\nZero-shot translation abilities\\nFigure 6a showcases the ability of language models to perform translation by using reference solutions in a different language to aid in function completion. Examples in Figures 5 and 8 illustrate how the models are able to produce code that retains the same underlying logic as the reference solution in Python, while conforming to the syntax of the target language, such as PHP (e.g., using $ before variable names). Specifically, the generated code in the translation mode mimics the content of the reference solution, including the same loop and control flow structures, as shown in the upper part of Figure 8. Additionally, the generated code can exhibit similar semantics, such as sorting by the summation, as illustrated in the lower part of Figure 8.\\n\\nInterestingly, our analysis in Figure 7c suggests that the translation setting can enable the models to solve problems that are otherwise difficult without the aid of reference solutions. For instance, on the MathQA dataset, which requires complex reasoning but has solutions with simple arithmetic syntax, our models are able to translate to a different language with near-perfect accuracy, achieving almost 100% pass@100 scores (see Appendix D.1).\"}"}
{"id": "Bo7eeXm6An8", "page_num": 7, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"if ($n == 0) return 1;     if ($s == \"\") return 0;     $res = 0;     for ($i=0; $i<strlen($s)-$n+1; $i++){         $c = 1;   ... mode Function completion without translation\\nSolution in source language (Python)\\nPrompt in target language (PHP)\"}"}
{"id": "Bo7eeXm6An8", "page_num": 8, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"(a) Non-assertion errors\\n\\n(b) Few-shot solve rate\\n\\n(c) Translation solve rate\\n\\nFigure 7: (a): Few-shot prompts result in lower non-assertion (compile, parsing, syntax) errors on out-of-domain (ood) evaluation but has no effect on in-domain (id).\\n\\nFor each task, we show a fraction of generations that pass the tests over the total number of samples (solve rate), where the task indices are ranked to show increasing difficulty. In the translation setting, tasks that are previously difficult (low solve rate for the baseline) can become easily solvable, demonstrating that models can leverage reference solutions in the source language to solve hard tasks. In contrast, the solve rates with few-shot prompting do not deviate as much per task from the baseline solve rate.\\n\\n$\\\\text{max_num} = \\\\frac{r}{l}; \\\\text{for} (i = l; i \\\\leq \\\\text{max_num}; i++) {\\n    \\\\text{if} (i \\\\% l == 0 \\\\&\\\\& i \\\\% r == 0) {\\n        \\\\text{return } i;\\n    } ...\\n}\\\\text{return } m.\\\\text{sortedBy } \\\\{ \\\\text{it}.\\\\text{sum}() \\\\}\\\\text{result } = \\\\text{sorted}(M, \\\\text{key}=\\\\text{sum})\\\\text{return result}$\\n\\nFigure 8: Code generation model can use the style and content of a reference solution in the translation setting to generate a correct solution in a different language.\\n\\nare not familiar with the target language. For example, in MBRBP evaluation (Ruby), the Ruby function signature can be very similar to that of Python, which can lead to confusion and the model generating Python code without the few-shot prompt. The error analysis in Figure 7a demonstrates that compilation, syntax, or parsing errors (non-assertion errors) drop significantly due to the few-shot prompts.\\n\\nThe improvement due to few-shot prompts also applies to other datasets such as MathQA (Appendix D.1). These observations suggest that soft prompts obtained via prompt tuning or its variants (Lester et al., 2021; Liu et al., 2021b,a; Li & Liang, 2021) could further help condition models to perform better in out-of-domain or scarce programming languages.\\n\\n4.5 Robustness Evaluation: \\\\text{R-MBXP}\\n\\nWe evaluate the robustness of models across \\\\text{r-MBXP} datasets perturbed by common transformations in NL-Augmenter (Dhole et al., 2021), a standard collection of data augmentations for robustness evaluation on text. Our experiments show that multi-lingual models are more robust on average, with less percentage of performance drops (7.80% vs 9.39% for multi- and mono-lingual models) and higher pass@1 scores across most perturbed datasets compared to mono-lingual models.\\n\\nFor more details and other interesting observations on robustness, we refer readers to Appendix J.\\n\\nAs the first code-generation robustness benchmark, we encourage researchers to further investigate robustness evaluation metrics, data augmentations, adversarial attacks, and defenses based on our released datasets.\\n\\n4.6 Code Insertion: \\\\text{I-MBXP}\\n\\nWe introduce \\\\text{i-MBXP}, an insertion-based variant of our \\\\text{MBXP} benchmark, which is the first execution-based multi-lingual code insertion benchmark. Each data sample consists of left and right\"}"}
{"id": "Bo7eeXm6An8", "page_num": 53, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"# Code\\n\\n```python\\n# Code\\n\\ndef square_nums(nums):\\n    square_nums = list(map(lambda x: x ** 2, nums))\\n    return square_nums\\n```\\n\\n# Summary:\\n- Write a function to find squares of individual elements in a list using lambda function.\\n\\n---\\n\\n# Code\\n\\n```python\\n# Code\\n\\ndef check_tuples(test_tuple, K):\\n    res = all(ele in K for ele in test_tuple)\\n    return (res)\\n```\\n\\n# Summary:\\n- Write a function to check if the given tuple contains only k elements.\\n- Write a function to check if a tuple is a subset of a list.\\n\\n---\\n\\n# Groundtruth\\n\\n```java\\nimport java.io.*\\nimport java.lang.*\\nimport java.util.*\\n\\nclass FindCharLong {\\n    public static List<String> findCharLong(String text) {\\n        List<String> result = new ArrayList<>();\\n        for (String str : text.split(\" \")) {\\n            if (str.length() >= 4) {\\n                result.add(str);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n# Summary:\\n- Write a function to find all words which are at least 4 characters long in a string by using regex.\\n\\n---\\n\\n```java\\nimport java.io.*\\nimport java.lang.*\\nimport java.util.*\\n\\nclass FindRotations {\\n    public static int findRotations(String str) {\\n        String tmp = str + str;\\n        int n = str.length();\\n        for (int i = 1; i <= n; i++) {\\n            String substring = tmp.substring(i, i + n);\\n            if (str.equals(substring)) {\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```\\n\\n# Summary:\\n- Write a javascript function to find the minimum number of rotations required to get the same string.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 54, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"for (Integer num : nums)\\n    squareList.add(num*num);\\nreturn squareList;\"}"}
{"id": "Bo7eeXm6An8", "page_num": 55, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"if (arr[mid] < arr[high]) {\\n    high = mid;\\n}\\n\\nreturn arr[high];\\n\\n// Summary:\\n\\n// Groundtruth: Write a javascript function to find the minimum element in a sorted and rotated array.\\n\\n// Generation: Write a function to find the minimum element in a list using lambda function.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 56, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"We used MBXP to evaluate several public models such as OPT (Zhang et al., 2022b), BLOOM (Mitchell et al., 2022), and CodeGen (Nijkamp et al., 2022). We use pass@1 to evaluate these models, where we generate the samples using greedy decoding. We generate 256 tokens per example and truncate the output to one function for evaluations. The trends we observe with public models are aligned with those observed with our models. In general, we observe a log-linear performance gain with model sizes, across all model families, and better execution accuracy in in-domain languages.\\n\\nAmong the general large-language models we observe that BLOOM models outperform OPT models (See Table 6). This can be attributed to the fact that 13.4% of the pretraining data used for BLOOM models is code, while OPT does not train on code specifically. BLOOM's pretraining data includes code in PHP, Java, Python, Javascript, and Ruby among others, making them all in-domain languages. This explains relatively similar performance across all languages barring Kotlin and Ruby.\\n\\nCodeGen models are trained in three stages, first is text pretraining, which is followed by code pretraining and python-only training. Here pretraining code data includes code in Python, Java, Javascript, C++, and Go. The CodeGen-multi refers to the models at the end of the code pretraining stage without the python-only training, while the CodeGen-mono is models at the end of all three training stages.\\n\\nExperiments with CodeGen models show similar performance trends as our models listed in Section 4.2. Specifically, we observe that large models show better than log-linear performance on out-of-domain languages (Kotlin, Java, and PHP). Interestingly, when compared with CodeGen-multi, CodeGen-mono 16B models show 6% and 8% improvements on JavaScript, and PHP, respectively (See Table 6). We speculate the additional training with python data has improved model performance in other languages as well.\\n\\nWith few-shot prompting, we observe significant improvements in out-of-domain languages. Specifically, accuracy with Ruby (which is typically confused with python by the models) increased from 3.5% to 16.46% with few-shot prompting on CodeGen-multi models with few-shot learning (See Table 8). In translation mode, barring Ruby, we find significant improvements in all languages (See Table 10).\"}"}
{"id": "Bo7eeXm6An8", "page_num": 21, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"We evaluate our 13B multi-lingual and mono-lingual models on MathQA datasets in different programming languages. The original MathQA dataset was formatted to the Python version by Austin et al. (2021), after which we use our conversion framework to obtain the corresponding data in different languages for analyses. We do not leverage the training and validation sets of MathQA to finetune our models. The purpose of this evaluation is to investigate the generalization capability of our models on complex context, which requires mathematical reasoning. Similar to Section 4.4 and 4.3, we compare the models with respect to adding few-shot prompts, conducting canonical solution translation, as well as the normal function completion.\\n\\nTable 1: Evaluating pass@100 execution scores (%) on multi-lingual MathQA using sampling with temperature=0.8\\n\\n| Mode   | Model | Param. Size | MathQA-Python | MathQA-Java | MathQA-JS |\\n|--------|-------|-------------|---------------|-------------|-----------|\\n| Translate | Multi | 672M | N/A | 91.66 | 94.21 |\\n| Translate | Multi | 13B | N/A | 96.33 | 98.08 |\\n| Translate | Mono | 13B | N/A | 94.31 | 96.49 |\\n| Few-shot | Multi | 15.61 | 13.54 | 13.54 |\\n| Few-shot | Multi | 13B | 21.50 | 26.21 | 24.96 |\\n| Few-shot | Mono | 13B | 22.78 | 15.29 | 19.33 |\\n| Normal | Multi | 13B | 13.43 | 18.05 | 10.67 |\\n| Normal | Mono | 13B | 20.23 | 14.86 | 10.78 |\\n\\nSpecifically, for the few-shot setup, we prepend the first 4 examples in the MathQA training data with their canonical solutions. For MathQA-Python, the canonical solutions are given; we manually adapt the Python solutions to other languages for these four examples. For solution translation, we evaluate the models on Java and JavaScript with the Python canonical solutions given in the context. The mono-lingual models are only evaluated on the MathQA dataset of the same language.\\n\\nFollowing findings are summarized below based on Table 1.\\n\\n- Both multi-lingual and monolingual models perform very well for solution translation (>94%), probably because the solutions required for solving MathQA problems are usually simple mathematical calculations. Converting them to different languages are straightforward, if python solutions are provided.\\n- Prepending few-shot examples achieves better performances than normal predictions for both multi-lingual and monolingual models. As illustrated in the MathQA example in Section R.3, the context are significantly different from the training corpus. Involving a few examples from MathQA domain in the context does help alleviate the domain divergence.\\n- The multi-lingual models do not consistently outperform the monolingual counterparts. This may be due to the nature of MathQA problems that emphasizes the models' mathematical reasoning capability.\\n\\nBelow, we present a correct prediction and a failed case for MathQA-Java examples under the translation mode. The case below demonstrates that the model understands that exponentiation in Python \\\\((a**b)\\\\) and is able to translate to `Math.pow(a,b)`.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 22, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"```java\\nimport java.io.*;\\nimport java.lang.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Problem {\\n    public static double problem() {\\n        double n0 = 14.0;\\n        double n1 = 1000.0;\\n        double n2 = 4.0;\\n\\n        double t0 = n0 / 100.0;\\n        double t1 = t0 + 1.0;\\n        double t2 = n1 * t0;\\n        double t3 = n2 * t2;\\n        double t4 = Math.pow(t1, Math.min(n2, 5));\\n        double t5 = n1 * t4;\\n        double t6 = t5 - n1;\\n        double answer = t6 - t3;\\n\\n        return answer;\\n    }\\n}\\n```\\n\\nIllustrated by the failed example below, despite the good overall performance, the model sometimes fails to translate mathematical built-in functions from Python to Java (e.g. `max` in Python vs. `Math.max` in Java). Additionally, `math.log` in Python can take a second argument for logarithmic base, while `Math.log` in Java specifically means natural logarithm, taking only one argument. The translation model ignores this difference.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 23, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"/**\n * find the least number of complete years in which a sum of money put out at 45 \\\\%\\\\ compound interest will be more than double of itself ? n0 = 45.0\\n*/\\n\\npublic static double problem() {\\n    double n0 = 45.0;\\n    double t0 = n0 / 100.0;\\n    double t1 = Math.log(max(1e-5, 2.0), 2);\\n    // Error: cannot find symbol \\\"max\\\". Also, math.log in Python can take a second argument for logarithmic base, while Math.log in Java specifically means natural logarithm, taking only one argument.\\n    double t2 = t0 + 1.0;\\n    double t3 = Math.log(max(1e-5, t2), 2); // Error\\n    double t4 = t1 / t3;\\n    double t5 = t4 + 1.0;\\n    int answer = (int) Math.floor(t5);\\n    return answer;\\n}\\n\\nD.2 MULTI-LINGUAL HUMAN EVAL\\n\\nWe present the results on multi-lingual HumanEval in Section M using our models as well as publicly available models. We find that the results on few-shot prompting and translation are generally consistent with MBXP. Details on multi-lingual HumanEval dataset preparation can be found in Section R.2.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 24, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Our evaluation indicates that code generation models typically have out-of-domain generalization performance (see Section 4.2). We hypothesize that it is due to the effect of data spillover that are quite common especially in cross-lingual code projects where each file can have multiple languages present. In this section, we provide discussion and examples of such cross-lingual code occurrences.\\n\\n### E.1 Types of Cross-Language Data Spillover\\n\\nWe provide discussion on types of data observed for code in the wild where multiple languages can co-occur. In particular, there are four categories:\\n\\n1. Source code from two programming languages occurring in the same file via explicit language embedding mechanism other than \u201cputting code in strings\u201d. There are actually two categories \u2014 \u201cdeep\u201d and \u201cshallow\u201d embeddings of the guest language into the host language. A good example of this in Python is [https://nyu-cds.github.io/python-numba/05-cuda/](https://nyu-cds.github.io/python-numba/05-cuda/) which uses python syntax but does not have the semantics of the corresponding python program.\\n\\n2. Source code from two programming languages occurring in the same file, where the \u201cguest language\u201d is included in the \u201chost language\u201d via the host language\u2019s string type. Most web code will fit in this category, but also stuff like code generators (e.g. [https://github.com/LS-Lab/KeYmaeraX-release/blob/master/keymaerax-webui/src/main/scala/edu/cmu/cs/ls/keymaerax/codegen/CExpression.scala](https://github.com/LS-Lab/KeYmaeraX-release/blob/master/keymaerax-webui/src/main/scala/edu/cmu/cs/ls/keymaerax/codegen/CExpression.scala)).\\n\\n3. Source code from two programming languages occurring in the same project, but always in separate files. This is another potential source of cross-lingual data, but it does not apply to the models trained in our paper since we filter languages per file, not per project.\\n\\n4. Combinations of programming languages via a Foreign Function Interface, where the host language does not explicitly use any source code from the source language but does, e.g., refer to identifiers or function names in compiled bytecode.\\n\\n### E.2 Example 1: Embedded JavaScript in Python Files\\n\\nThe example below taken from [https://github.com/brython-dev/brython/blob/master/scripts/make_encoding_js.py#L30](https://github.com/brython-dev/brython/blob/master/scripts/make_encoding_js.py#L30) shows JavaScript written in Python strings throughout the code file `make_encoding_js.py`.\\n\\n```python\\n\"\"\"Create a Javascript script to encode / decode for a specific encoding\\ndescribed in a file available at\\nhttp://unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/<ENCODING>.TXT\\n\\\"\\n\\nimport os\\nimport re\\nimport json\\nimport urllib.request\\n\\nline_re = re.compile(\\\"(0x[A-Z0-9]+)\\\\s+(0x[A-Z0-9]+)\\\\*\\\", re.M)\\n\\ntmpl = \\\"http://unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/.TXT\\\"\\nencoding = input(\\\"Encoding name: \\\")\\nreq = urllib.request.urlopen(tmpl.format(encoding.upper()))\\ndata = req.read().decode(\\\"ascii\\\")\\n\\nroot_dir = os.path.dirname(os.path.dirname(__file__))\\nlibs_dir = os.path.join(root_dir, \\\"www\\\", \\\"src\\\", \\\"libs\\\")\\nfilename = os.path.join(libs_dir, f\\\"encoding_{encoding.lower()}.js\\\")\\nwith open(filename, \\\"w\\\", encoding=\\\"utf-8\\\") as out:\\n    out.write(\\\"var _table = [\\\"\\n    for line in data.split(\\\"\\\\n\\\"):\\n        mo = line_re.match(line)\\n        if mo:\\n            key, value = mo.groups()\\n            out.write(f\\\"{key}, {value or -1},\\\"\\n            out.write(\\\"]\\\\n\\\"\\\"\\n    out.write(\\\"var decoding_table = [], encoding_table = []\\\")\\n```\\n\\n---\\n\\n---\"}"}
{"id": "Bo7eeXm6An8", "page_num": 17, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"A.1 IMPLICATION OF FINDINGS\\n\\nFrom our findings, it is clear that a large multi-lingual model compared to multiple mono-lingual is a better choice if we are to consider deploying code generation models. This is due to the data spillover from each language source which reinforces the knowledge of the model in the multi-lingual training. However, such model needs to be of sufficient size to capture all the available knowledge. For our controlled setting, model sizes $2^7$ and above begin to clearly outperform all mono-lingual models. It is possible that as the number of languages in the training set increase, the required size for the multi-lingual model to be superior to individual mono-lingual models can increase.\\n\\nA.2 IMPLICATION OF EVALUATION DATA AT SCALE\\n\\nOur parallel datasets provide a valuable resource for studying the translation abilities of code generation models. By leveraging the canonical solutions in our source language, we can evaluate how well the models generate code in any other supported language. This opens up a range of research questions, such as how well the models generalize across languages, what factors contribute to successful or unsuccessful translations, and how different modeling strategies affect translation performance.\\n\\nA.3 POSSIBILITIES OF TRUE GENERALIZATION\\n\\nOut-of-domain evaluations from our controlled experiments reveal interesting behavior of how code in multiple languages present themselves in natural data. We hypothesize that the out-of-domain code generation abilities are mainly due to the data spillover. However, we believe it is also possible that a true generalization plays a role where the model is able to complete code in a new language that is not in the training data at all. To test this, we can design a new language which avoids the complication of data spillover in the any training dataset. We can use our framework to construct the evaluation set in such language and use it to evaluate the existing models. However, we note that such new language likely are similar to existing languages in the training set in some aspects. For instance, the control flows (if clause), loops, variable declaration, or objects such as lists or dictionaries potentially might not differ much from each component of existing languages. Even with the new language constructed, the boundary between evaluating a true generalization versus generalization between data spillover can be somewhat unclear.\\n\\nA.4 POTENTIAL PROXY FOR GENERAL CODING CAPABILITIES\\n\\nMBXP and other code completion benchmarks such as HumanEval measure the general understanding of basic tasks from natural language description with function signature and the model's ability to complete such tasks. Given the description of these problems in natural language and function signature where a competent human coder can complete, this benchmark helps measure if a code generation model can perform such tasks. The scores of these evaluations can be a useful proxy for overall code capabilities if they correlate with the performance on all coding-related tasks. We believe that such correlation is possible or likely the case if the models are not trained to adapt to a specific distribution of evaluation datasets. By using these evaluations as proxies of general coding abilities, we implicitly accept the premise that zero-shot evaluation on a slice of all possible problems (the slice being MBXP, for instance) is an unbiased proxy to measure overall model's capabilities in each language. Hence, in this paper, we particularly avoid finetuning even though results in the literature demonstrate increased performance so that the results established can be less biased towards specific kinds of coding problems and can better reflect models' true coding capabilities.\\n\\nA.5 LIMITATIONS\\n\\nThe proposed conversion framework is well suited for basic programming problems that are applicable to a wide set of programming languages. While the original MBPP dataset is meant for basic programming problems, some tasks can be more appropriate for certain languages than others. For instance, string manipulation problems can be naturally encountered in languages such as Python.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 18, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"By design, our conversion \u201cnaively\u201d assumes that a problem is relevant to the target language which might not be true for all problems in a given dataset. That is, the scores obtained from MBXP benchmark might not align with the distribution of natural usage in different languages equally.\\n\\nIn addition, the programming problems in MBXP do not cover language-specific functionalities; for instance, there are no specific questions related to web development for JavaScript, or memory allocation for C++. Therefore, it can be unclear how the conclusion from MBXP benchmark transfers to coding performance in the wild given the complexity of real-world software development.\\n\\nThe test conversion we support are value-oriented which do not cover all possible types of testing. The value-oriented test performs assertion by checking if the values match. If the assertion process is more complex such as in deep integration tests with specific code packages or APIs, the conversion process is not applicable. In fact, we explicitly define the types of Python objects that we support converting from in Appendix O. We suggest that it can be beneficial to complement MBXP evaluation with other language-specific evaluation, if available.\\n\\nA.6 Generation Trend versus Generation Ability\\n\\nThe prompts in our benchmark heavily guide the model to generate in a particular language. For example, when a prompt contains `function method_name(`, the model is highly encouraged to generate code that has such syntax, in this case PHP, but not Python where the function signature would have started with `def method_name(`. In that sense, this benchmark measures the ability of a model to conform to the guided prompt and the completion ability based on the function signature that has already started, and not necessarily the tendency to generate in particular languages.\\n\\nNote that without explicit guidance or special tags, models can generate code in any languages, especially multi-lingual models, which makes fair evaluation of code completion harder since we might not penalize correct code that is correct but in a different language. Our prompt format helps isolate evaluation of the generation ability in a desired language from the generation tendency. This is contrast to free-form prompt style in datasets like the original MBPP, APPs, or CodeContests where the model generates its own function signature. However, in our case, if the evaluation is out-of-domain, it is still possible that with explicit guidance of function signature, the model can still generate in a similar yet different language, as in the case of confusion between Ruby and Python with similar function signature syntax.\\n\\nWe also observe that while this benchmark is about generic understanding of basic programming tasks and does not particular attempt to measure the knowledge of a model in terms of specific syntax in the desired language, we observe that language-specific syntax usage typically emerge, for instance, the usage of `list.select` in Ruby, or `nums.filter` in Kotlin to select elements of a list, instead of a generic for loop. We provide sample generations for all converted languages in Section R.1.\\n\\nB Other Related Work\\n\\nCode Generation Models\\n\\nLanguage models for code generation is a rising domain in recent years. CodeBERT (Feng et al., 2020) is the first BERT-based language model trained on code. GraphCodeBERT Guo et al. (2021) improves upon CodeBERT by leveraging AST and data flow. CodeT5 Wang et al. (2021) and PLBART Ahmad et al. (2021a) pretrained encoder-decoder based generative language models for code. More recently, various work have been proposed to use large language models for code generation. Codex (Chen et al., 2021) was pretrained on Python on top of GPT-3, resulting in up to 175B parameters code generation models. CodeGen (Nijkamp et al., 2022) was pretrained on multiple programming languages and optimized for conversational code generation with up to 16B parameters. InCoder (Fried et al., 2022), along with CoditT5 Zhang et al. (2022a) on a similar line of research, is able to perform program synthesis (via left-to-right generation) as well as editing (via infilling) with up to 6.7B parameters. Further, researchers also found that generic (natural) language models are also able to perform code completion to a certain degree, e.g., PaLM (Chowdhery et al., 2022) and BLOOM (Mitchell et al., 2022).\\n\\nIn addition, researchers proposed various ways of improving code generation models. For example, Poesia et al. (2022) propose Target Similarity Tuning for code retrieval augmentation and Con-\"}"}
{"id": "Bo7eeXm6An8", "page_num": 19, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"strained Semantic Decoding to improve code generation by constraining the output to a set of valid programs in the target language. Shi et al. (2022) introduce execution result\u2013based minimum Bayes risk decoding that improves choosing a single correct program from among a generated set. Another line of work is to \u201crepair\u201d the generated code by language models, e.g., (Fan et al., 2022; Li et al., 2022b).\\n\\nOur work is model-agnostic and complimentary to all the above works that serves as a testbed of code generation.\\n\\nCode Completion Resources\\n\\nMany code completion evaluation benchmarks have been proposed recently, but they differ in style and focus. Lu et al. (2021) composed a token and line completion datasets in Java and Python based on existing benchmarks (Allamanis & Sutton, 2013; Raychev et al., 2016). Clement et al. (2021) presented a method generation dataset in Python based on CodeSearchNet (Husain et al., 2019). All these datasets are primarily collected from open-source projects or GitHub and focus on match-based evaluation (using n-gram metrics). In contrast to these efforts, recent works promote unit tests-based execution evaluation to assess the functional correctness of ML-based code completion techniques.\\n\\nIn this line of work, Austin et al. (2021) introduced the MBPP dataset focusing on basic programming problems where the prompt format consists of a natural language description and assert state\u2013ments in Python. HumanEval (Chen et al., 2021) focuses on more challenging algorithmic problems with prompts containing function signatures in Python along with docstring descriptions of the problems, including test case descriptions. APPS (Hendrycks et al., 2021) and CodeContest (Li et al., 2022a) contain language-agnostic problems in algorithmic competition style and tend to be very challenging. Both datasets expect solutions (complete programs, unlike functions in other datasets) in any language that uses standard input and output to consume and return values. The output is compared directly with the expected values without test cases written in any particular language to test for correctness. In contrast, HumanEval and MBPP use test statements written directly in Python. We show all the dataset formats for comparison in Section R.1.\\n\\nWe find that the HumanEval format aligns best with how programmers would write in a typical coding environment; therefore, we use this format for our converted MBXP benchmark. We also convert the original Python MBPP dataset to be of this format as well for comparison consistency.\\n\\nOur benchmark, MBXP, is the first execution-based function completion benchmark available in multiple languages for all (or most) tasks in parallel.\\n\\nCode Translation Resources\\n\\nSeveral works in the literature have developed parallel corpus to facilitate source code translation. Earlier works (Nguyen et al., 2013; Karaivanov et al., 2014) focused on building semi-automatic tools to find similar functions in Java and C# from open source projects. Subsequent works used libraries and transcompilers to construct parallel corpora in Python 2 and Python 3 (Aggarwal et al., 2015), and CoffeeScript and JavaScript (Chen et al., 2018). Among the recent works, Lachaux et al. (2020a) collected a corpus of parallel functions in Java, Python, and C++ from GeeksforGeeks and provided unit tests for execution-based evaluation. Very recently, Szafraniec et al. (2022) extended the dataset in Go and Rust languages. On a similar line, Zhu et al. (2022) introduce a new dataset which is parallel across 7 programming languages on both snippet level and program level based on GeeksforGeeks data. Another work (Ahmad et al., 2021b) aggregated a comparatively larger parallel corpus in Java and Python by collecting programming problem solutions from several sources. Different from the prior works, our proposed dataset, MBXP, covers a wide range of languages with unit tests to facilitate the evaluation of functional accuracy of ML-based code translation models.\\n\\nMulti-lingual Evaluation of Code Generation Models\\n\\nWang et al. (2022) proposed MCoNaLa, a multi-lingual version of CoNaLa Yin et al. (2018) in various natural languages. This is orthogonal to our work that extends multi-linguality on programming languages. Similar approaches could be applied to MBXP to expand the dataset to multiple natural languages and we leave it as one of the future directions.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 20, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"We use nucleus sampling with $p = 0.95$ (Holtzman et al., 2020). For all experiments, limit the input length to be 1792 and generate up to 256 tokens. If the context exceeds 1792 tokens, we perform truncation from the left. Note that the truncation can happen more often in the case of few-shot prompting or translation settings.\\n\\nC.2 Stopping Criteria\\n\\nWe categorize languages into groups where each group has the same stopping criteria.\\n\\n- **Curly-brace style with standalone function**: JavaScript, TypeScript, Go, Kotlin, PHP, C++, Rust. We truncate right after the closing `}` character.\\n- **Curly-brace style with function wrapped under class**: Java, C#. We truncate right after the closing `}` and add `\\n}` to close the higher-level class wrapper. This is slightly different from letting the model generate a closing `}` for the wrapper class. We find that if we do let the model generate a closing `}` on its own, it can go on to generate another function, which technically should not harm the evaluation, but it can cause the generation to be too long and can hit the maximum token limit. Therefore, we find that it is fair and more efficient to close out the class right away after the current function is generated.\\n- **Other keywords**: 'end' for Ruby\\n\\nNote that it is possible to extend these stopping criteria to include multi-function evaluation, where the first function can refer to other functions that follow. However, it is out of scope for this current paper.\\n\\nC.3 Code Execution\\n\\nWe adapted the human-eval\u2020 repository by OpenAI which provides multi-thread execution-based evaluation framework in Python along with unbiased pass@k calculation. Our adaptation supports execution in all languages in MBXP where we use Python's subprocess to execute native command in each respective language. For instance, we execute with `node file.js` for JavaScript.\\n\\nThe test statements for each language are such that exceptions are thrown if the test cases fail. Each task can also fail due to improper generated code that does not parse or compile. We capture the failure or success of each execution via exit code as well as standard error message for further analysis.\\n\\n\u2020 https://github.com/openai/human-eval\"}"}
{"id": "Bo7eeXm6An8", "page_num": 37, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"Figure 16: Translation performance compared to baseline (dot) for multi- and monolingual models, with Python as a source language.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 38, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"| Model   | Baseline | Multi-lingual | Python | Java | JavaScript | PHP | Ruby | Kotlin |\\n|---------|----------|---------------|--------|------|------------|-----|------|--------|\\n| MBPP    | 8.5      | 11.7          | 3.2    | 0.8  | 0.0        | 7.9 | 1.0  | 4.8    |\\n| MBJP    | 0.0      | 6.6           | 6.6    | 17.3 | 21.1       | 27.2| 0.0  | 11.2   |\\n| MBJSP   | 11.7     | 21.1          | 18.9   | 22.8 | 27.1       | 27.2| 0.0  | 14.8   |\\n| MBPHP   | 3.6      | 4.0           | 4.0    | 4.0  | 4.0        | 4.0 | 4.0  | 4.0    |\\n| MBRBP   | 4.8      | 7.4           | 7.4    | 7.4  | 7.4        | 7.4 | 7.4  | 7.4    |\\n| MBKP    | 5.2      | 8.2           | 8.2    | 8.2  | 8.2        | 8.2 | 8.2  | 8.2    |\"}"}
{"id": "Bo7eeXm6An8", "page_num": 39, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"Figure 18: Translation performance compared to baseline (dot) for multi- and mono-lingual models, with Java as a source language.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 40, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"def find_Sum(arr, n):\\n    \"\"\"\\n    Write a python function to find the sum of repeated elements in a given array.\\n    >>> find_Sum([1, 2, 3, 1, 1, 4, 5, 6], 8)\\n    3\\n    >>> find_Sum([1, 2, 3, 1, 1], 5)\\n    3\\n    >>> find_Sum([1, 1, 2], 3)\\n    2\\n    \"\"\"\\n    return sum([x for x in arr if arr.count(x) > 1])\\n\\nfunction findSum($arr, $n) {\\n    $count = array_count_values($arr);\\n    return array_sum(array_filter($arr, function ($value) use ($count) {\\n        return $count[$value] > 1;\\n    }));\\n}\\n\\ndef find_Product(arr, n):\\n    \"\"\"\\n    Write a python function to find the product of non-repeated elements in a given array.\\n    >>> find_Product([1, 1, 2, 3], 4)\\n    6\\n    >>> find_Product([1, 2, 3, 1, 1], 5)\\n    6\\n    >>> find_Product([1, 1, 4, 5, 6], 5)\\n    120\\n    \"\"\"\\n    arr.sort()\\n    prod = 1\\n    for i in range(0, n, 1):\\n        if arr[i - 1] != arr[i]:\\n            prod = prod * arr[i]\\n    return prod;\\n\\nfunction findProduct($arr, $n) {\\n    $arr = array_unique($arr);\\n    $prod = 1;\\n    foreach($arr as $key => $value) {\\n        if($key == 0 || $value != $arr[$key - 1]) {\\n            $prod = $prod * $value;\\n        }\\n    }\\n    return $prod;\\n}\"}"}
{"id": "Bo7eeXm6An8", "page_num": 25, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"for(var i = 0, len = _table.length; i < len; i += 2) {\\n    var value = _table[i + 1]\\n    if(value !== null) {\\n        encoding_table[value] = _table[i]\\n    }\\n    decoding_table[_table[i]] = _table[i + 1]\\n}$module = {encoding_table, decoding_table}\"}"}
{"id": "Bo7eeXm6An8", "page_num": 26, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"Figure 9 shows pass@1, pass@10, and pass@100 for many evaluation datasets in MBXP. We can observe that the trends for pass@k for different k are consistent, but simply different in terms of scale for scores. That is, the observation that multi-lingual models begin to clearly outperform mono-lingual models when the model size becomes sufficiently large holds for any k.\\n\\n(a) Temperature 0.2 and k = 1.\\n\\n(b) Temperature 0.6 and k = 10 (as in main paper).\\n\\n(c) Temperature 0.8 and k = 100.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 27, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"### COMPREHENSIVE SAMPLING RESULTS\\n\\n| Language | MBPP (Python) | MBJSP (JavaScript) | MBJP (Java) | MBPHP (PHP) | MBCSP (C#) | MBGP (Go) | MBKP (Kotlin) | MBCPP (CPP) | MBSCP (Scala) | MBSWP (Swift) | MBPLP (Perl) |\\n|----------|---------------|--------------------|-------------|-------------|------------|-----------|--------------|-------------|---------------|-------------|-------------|\\n| pass@1   | 6.6           | 7.9                | 5.8         | 0.5         | 0.7        | 0.6       | 1.0          | 1.4         | 0.5           | 0.4         | 0.2         |\\n| pass@5   | 13.8          | 16.5               | 12.5        | 1.9         | 2.0        | 1.6       | 3.1          | 3.1         | 1.6           | 1.3         | 0.6         |\\n| pass@10  | 18.6          | 21.4               | 17.1        | 3.0         | 3.2        | 2.5       | 4.2          | 4.1         | 2.6           | 2.1         | 1.2         |\\n| pass@30  | 27.4          | 30.5               | 25.4        | 6.3         | 5.7        | 4.8       | 7.3          | 7.2         | 5.0           | 3.9         | 1.8         |\\n| pass@100 | 38.8          | 40.5               | 37.1        | 12.9        | 9.7        | 8.3       | 11.7         | 15.2        | 7.1           | 6.3         | 2.3         |\\n\\n**Figure 10:** pass@k trends for 125M monolingual and multi-lingual models for in-domain and out-of-domain languages.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 28, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"| Language   | MBPP (Python) | MBJSP (JavaScript) | MBJP (Java) | MBPHP (PHP) | MBTSP (TypeScript) | MBRBP (Ruby) | MBKP (Kotlin) | MBCSP (C#) | MBGP (Go) | MBCPP (CPP) | MBSCP (Scala) | MBSWP (Swift) | MBPLP (Perl) |\\n|------------|---------------|--------------------|-------------|------------|-------------------|--------------|--------------|------------|----------|-----------|---------------|---------------|-------------|\\n| pass@1     | 0             | 0.0                | 0.0         | 0.0        | 0.0               | 1.9          | 2.1          | 4.6        | 1.4      | 7.6       | 1.9           | 2.0          | 1.0         |\\n| pass@5     | 20            | 0.0                | 0.0         | 0.0        | 0.0               | 2.8          | 3.4          | 10.4       | 2.8      | 14.4      | 4.6           | 3.4          | 0.4         |\\n| pass@10    | 40            | 0.0                | 0.0         | 0.0        | 0.0               | 4.1          | 5.3          | 14.9       | 4.1      | 6.4       | 6.5           | 5.2          | 1.1         |\\n| pass@30    | 60            | 0.0                | 0.0         | 0.0        | 0.0               | 6.8          | 8.5          | 23.7       | 6.8      | 6.6       | 7.6           | 9.4          | 0.4         |\\n| pass@100   | 80            | 0.0                | 0.0         | 0.0        | 0.0               | 11.1         | 15.1         | 33.8       | 16.1     | 11.1      | 11.1          | 9.4          | 2.6         |\\n\\nMulti-lingual\\nPython\\nJava\\nJavaScript\\n\\nComparing pass@k scores of 672m Monolingual and Multi-lingual Models\\n\\nFigure 11: pass@k trends for 672M monlingual and multi-lingual models for in-domain and out-of-domain languages.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 49, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Example 2: left-to-right mode\\n\\n```java\\n### begin of left-right ###\\ncountableList.remove(countableList.get(0));\\nfor (int index = 0; index < countFor; index++) {\\n    finalResult.add(countableList.get(0));\\n    countableList.remove(countableList.get(0));\\n}\\ncountFor = c;\\nfor (int index = 0; index < countFor; index++) {\\n    finalResult.add(countableList.get(0));\\n    countableList.remove(countableList.get(0));\\n}\\ncountFor = d;\\nfor (int index = 0; index < countFor; index++) {\\n    finalResult.add(countableList.get(0));\\n    countableList.remove(countableList.get(0));\\n}\\nreturn finalResult;\\n### end of left-right ###\\n```\\n\\nExample 3: JavaScript insertion mode\\n\\n```javascript\\n/**\\n * Write a function to find all anagrams of a string in a given list of strings using lambda function.\\n * > anagramLambda([\"bcda\", \"abce\", \"cbda\", \"cbea\", \"adcb\"], \"abcd\")\\n * [\"bcda\", \"cbda\", \"adcb\"]\\n * > anagramLambda([\"recitals\", \"python\"], \"articles\")\\n * [\"recitals\"]\\n * > anagramLambda([\" keep\", \" abcdef\", \"xyz\"], \"peek\")\\n * [\" keep\"]\\n */\\nfunction anagramLambda(texts, str) {\\n    const countFunc = (str) => {\\n        let result = {};\\n        for (let i = 0; i < str.length; i++) {\\n            let char = str[i];\\n            if (result[char]) {\\n                result[char] += 1;\\n            } else {\\n                result[char] = 1;\\n            }\\n        }\\n        return result;\\n    };\\n    const countStr = countFunc(str);\\n    return texts.filter((word) => {\\n        let result = {};\\n        for (let i = 0; i < word.length; i++) {\\n            let char = word[i];\\n        }\\n        return Object.keys(countStr).every((char) => {\\n            return countStr[char] === result[char];\\n        });\\n    });\\n}\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 50, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Example 3: JavaScript left-to-right mode\\n\\n```javascript\\n### begin of left-right ###\\n\\n```javascript\\nif (result[char]) {\\n  result[char] += countStr[char];\\n} else {\\n  result[char] = countStr[char];\\n}\\n```\\n\\n```javascript\\nreturn Object.values(result).reduce((a, b) => a + b, 0) === Object.values(countStr).reduce((a, b) => a + b, 0);\\n```\\n\\n```javascript\\n### end of left-right ###\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 51, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Here we re-purpose the original MBXP datasets for code summarization task. We remove the natural language description from the original prompt and use the function signature and the canonical solution as the model input for code summarization. To induce the model to generate natural language in comments, we design two types of prompt in zero-shot and few-shot setting, respectively.\\n\\nZero-shot Evaluation.\\nIn this setting, we append \\\"The above code writes a \\\" in the format of code comment after the original code prompt. For example, in Python, the appended sequence is \\\"# The above code writes a \\\". See examples in different languages in Section L.3.\\n\\nFew-shot Evaluation.\\nIn this setting, we select three code-summary pairs and prepend them before the original prompt. Examples are shown in Section L.3.\\n\\nTo evaluate the code summarization performance, we use smoothed BLEU score as the metrics following the setting in CodeXGLUE (Lu et al., 2021) that compare the generated outputs with the groundtruth docstrings. In MBXP datasets, the summarizations are short paragraphs with one or two sentences which makes smoothed BLEU score a suitable metric (Feng et al., 2020).\\n\\nExperimental results are shown in Figure 23 covering Python, JavaScript and Java. Overall, we found that performances are improved along with the increasing of the model size. For example, the BLEU-4 scores on Python language in 13B, 672M and 125M models are 6.07, 5.59, 3.20 under zero-shot settings, and 34.10, 24.72, 20.75 under few-shot settings. We also noticed that multi-lingual models achieve better performances compared with monolingual models trained on individual languages. An interesting observation is that though the monolingual models are trained on a specific language, they can generalize to other languages well when few-shot examples are provided. From the table we can also notice that the improvements brought by few-shot settings are more significant on larger models. Comparing the multi-lingual models and monolingual models under few-shot settings, we found that the multi-lingual models are more robust to the few-shot examples while monolingual models in smaller sizes show unstable performances.\\n\\nFigure 23: Code summarization evaluation in BLEU scores for all models.\\n\\nQualitative Examples.\\nHere we list some examples in Python, JavaScript and Java to show the zero-shot prompts, generation from models and their ground-truth.\\n\\nExample Python-0\\n1\\n2 ------ begin of prompt ------\\n3 def discriminant_value(x,y,z):\\n4 discriminant = (y**2) - (4*x*z)\\n5 if discriminant > 0:\\n6 return (\\\"Two solutions\\\",discriminant)\\n7 elif discriminant == 0:\\n8 return (\\\"one solution\\\",discriminant)\\n9 elif discriminant < 0:\\n10 return (\\\"no real solution\\\",discriminant)\\n11 # The above code writes a\\n12 ------ end of prompt ------\"}"}
{"id": "Bo7eeXm6An8", "page_num": 52, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"# Groundtruth: Write a function to calculate the discriminant value.\\n\\nExample Python\\n\\n```python\\nfrom collections import Counter\\n\\ndef add_dict(d1, d2):\\n    add_dict = Counter(d1) + Counter(d2)\\n    return add_dict\\n```\\n\\n# The above code writes a\\n\\n# Groundtruth: Write a function to combine two dictionaries by adding values for common keys.\\n\\nExample Java\\n\\n```java\\nimport java.io.*\\nimport java.lang.*\\nimport java.util.*\\n\\nclass ChangeDateFormat {\\n    public static String changeDateFormat(String dt) {\\n        String[] tokens = dt.split(\"-\");\\n        return tokens[2] + \"-\" + tokens[1] + \"-\" + tokens[0];\\n    }\\n}\\n```\\n\\n# The above code writes a\\n\\n# Groundtruth: Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\\n\\nExample JavaScript\\n\\n```javascript\\nfunction swapList(newlist) {\\n    let first = newlist[0];\\n    let last = newlist[newlist.length - 1];\\n    newlist[0] = last;\\n    newlist[newlist.length - 1] = first;\\n    return newlist;\\n}\\n```\\n\\n# The above code writes a\\n\\n# Groundtruth: Write a javascript function to interchange the first and last elements in a list.\\n\\nFew-shot Prompt Examples.\\nThe following examples show the few-shot prompts in different languages.\\n\\nExample Python\\n\\n```python\\n# summarize the functionality of the code\\n\\ndef find_char_long(text):\\n    return (re.findall(r\"\\b\\w{4,}\\b\", text))\\n# Summary: Write a function to find all words which are at least 4 characters long in a string by using regex.\\n```\\n\\nExample Java\\n\\n```java\\ndef find_Rotations( str):\\n    tmp = str + str\\n    n = len(str)\\n    for i in range(1,n + 1):\\n        substring = tmp[i: i+n]\\n        if (str== substring):\\n            return i\\n    return n\\n# Summary: Write a python function to find the minimum number of rotations required to get the same string.\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 33, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"```javascript\\n/**\\n * Write a javascript function to identify non-prime numbers.\\n */\\nfunction isNotPrime(n) {\\n    for (let i = 2; i < n; i++) {\\n        if (n % i === 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n/**\\n * Write a javascript function to remove all digits from a list of strings.\\n */\\nfunction remove(list) {\\n    return list.map(item => item.replace(/\\d+/g, ''));\\n}\\n\\n/**\\n * Write a javascript function to determine whether all the numbers are different from each other are not.\\n */\\nfunction testDistinct(data) {\\n    return data.every((item, index) => {\\n        return data.indexOf(item) === index;\\n    });\\n}\\n```\\n\\n```php\\n<?php\\n/**\\n * You are an expert PHP programmer, and here is your task.\\n * Write a function of recursion list sum.\\n */\\nfunction recursiveListSum($dataList) {\\n    $sum = 0;\\n    foreach ($dataList as $item) {\\n        if (is_array($item)) {\\n            $sum += recursiveListSum($item);\\n        } else {\\n            $sum += $item;\\n        }\\n    }\\n    return $sum;\\n}\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 34, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"<?php\\n\\nfunction returnSum($dict) {\\n    $sum = 0;\\n    foreach ($dict as $key => $value) {\\n        $sum += $value;\\n    }\\n    return $sum;\\n}\\n\\nfunction squareNums($nums) {\\n    $squares = [];\\n    foreach ($nums as $num) {\\n        $squares[] = $num * $num;\\n    }\\n    return $squares;\\n}\\n\\n?>\\n\\nG.2.4 RUBY FEW\\n\\nYou are an expert Ruby programmer, and here is your task.\\nWrite a Ruby function to remove all digits from a list of strings.\\n\\n```ruby\\ndef remove(list)\\n    return list.map { |word| word.gsub(/\\d+/, '') }\\nend\\n```\\n\\nYou are an expert Ruby programmer, and here is your task.\\nWrite a Ruby function to remove even numbers from a given list.\\n\\n```ruby\\ndef remove_even(l)\\n    return l.reject {|x| x % 2 == 0}\\nend\\n```\\n\\nYou are an expert Ruby programmer, and here is your task.\\nWrite a Ruby function to find the minimum of two numbers.\\n\\n```ruby\\ndef minimum(a, b)\\n    return a < b ? a : b\\nend\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 35, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"In this section, we show translation results using (1) multi-lingual and mono-lingual models of various scales and (2) three different languages as source solutions (Python, Java, JavaScript). We note that the canonical solutions from Java and JavaScript are from the data bootstrapping using a separately trained model, as detailed in Section P. For tasks that we do not have solutions for, we do not prepend anything to the usual target-language prompt.\\n\\nWhile the training data can potentially consist of translation-like data which allow the model to perform zero-shot translation, we do not know the volume of such translation-related data and suspect such volume to be low. In addition, the model is not trained specifically on certain languages such as Kotlin or PHP for multi-lingual models, or even on Java for Python-only models, for instance.\\n\\nFigures 15 illustrate the zero-shot translation results for multi-lingual, Python, JavaScript and Java mono-lingual models respectively. In most settings, we observe improvements due to zero-shot translation over the baseline.\\n\\nOut-of-domain evaluation languages benefit more from translation. We can observe consistent performance gains due to translation as opposed to without using reference solution. The performance gain is drastic in certain cases. For example, for Ruby, the 13B multi-lingual model obtains 5.9% pass in the normal mode and 15.9% in the translation mode with JavaScript as a source language, or for PHP, the performance improvement is from 19.1% to 46.5% with Java as a source language.\\n\\nEffects of language compatibility or affinity for zero-shot translation\\n\\nBased on the trends of performance gains from the translation settings, we observe that different source languages have unequal effects as reference solutions. For instance, based on the multi-lingual 672M and 13B models, Java is the source language that yields the highest performance for MBPHP, whereas JavaScript seems to be the best for MBRBP and MBKP. These compatibility trends can change slightly but are roughly consistent. For instance, for MBJSP, JavaScript is the best source language for the 13B model, whereas Python is the best source language for MBJSP in many other settings. However, for MBKP and MBRBP, JavaScript consistently is the best source language across all model types. We summarize the best model types for each evaluation set below in Table 2. We observe that it is not necessarily the source languages that are closest in syntax that is the best source language, since it has potential to confuse the models during translation and lead the model to generate in an incoherent syntax.\\n\\nTable 2: Source language that yields the best zero-shot translation scores for each evaluation language\\n\\n| Evaluation Dataset | Model Type |\\n|--------------------|------------|\\n| MBPP               | None or Java | Java | Java | Python |\\n| MBJP               | Python | Python | None or Python | Python | Python |\\n| MBJSP              | Python or Java | Python | Java | Java |\\n| MBPHP              | Java | Python | Java | Java | Java or JavaScript |\\n| MHRBP              | JavaScript | JavaScript | JavaScript | JavaScript |\\n| MBKP               | JavaScript | JavaScript or Python | JavaScript | JavaScript |\\n\\nWe provide some examples in Section H.3.\\n\\nMono-lingual versus multi-lingual models\\n\\nFor mono-lingual models, we observe large performance boost, partly due to mono-lingual models not performing well for baseline to start with.\\n\\nTrends with respect to model sizes\\n\\nLarger models typically perform better, as observed in the normal code completion case and also in the translation case as well.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 36, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"Published as a conference paper at ICLR 2023\\n\\nModel knowledge of source language versus target language. It is likely the case that the knowledge of the target language is more important than the source language for translation performance.\\n\\nWe note that the Python model obtains high scores with translation on MBJSP with Python as source (13.8% \u2192 30.7%). The JavaScript model also obtains high scores with translation on MBJSP with Python as source, with better performance compared to the Python model, which is in part due to better baseline performance to start with (23.3% \u2192 32.8%).\"}"}
{"id": "Bo7eeXm6An8", "page_num": 61, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 25: Validation loss vs number of parameters for 128M, 672M, 2.7B and 13B multi-lingual and mono-lingual models.\\n\\ndemonstrate that it is more difficult for the same size of model to fit multi-lingual datasets since with limited model capacity it needs to learn more diverse information while mono-lingual models can be more concentrated.\\n\\nHowever, although the validation loss of mono-lingual models is generally lower, from Section 4.2, we observe that in terms of execution performance pass \\\\( k \\\\), multi-lingual models actually outperform mono-lingual ones especially when model sizes go beyond 672M. In fact, as model size increases, the improvement of multi-lingual models over mono-lingual models get more and more significant. The reason could be that although models get distracted to fit multiple languages, the knowledge sharing across different languages helps model to learn better in solving problems. For example, similar tasks might exist in different programming languages, hence models are easier to learn to transfer from one language to another. And larger models have better capability in knowledge sharing/transfer learning, with the evidence that the zero-shot learning performance of multi-lingual models on unseen programming languages get significantly better than mono-lingual ones as model sizes increases.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 62, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"In this section, we describe a dataset conversion framework that transforms an execution-based evaluation in one programming language to another. In particular, we focus on a function completion format of execution-based evaluation as shown in Figure 2. Each problem in a function completion dataset consists of a prompt, a test statement, and a canonical solution. The prompt contains a function signature along with a docstring describing the desired functionality of the code. The canonical solution is an example of a function body that fulfills such functionality, usually written by human annotators. Given a candidate function body generated by the model, we can test whether the corresponding function is correct by executing the test statement against the candidate function.\\n\\nTo construct an evaluation dataset for function completion in a new language, we recognize that it is sufficient to convert only the prompts and the test statements (Section O.1). That is, we do not need to transform the canonical solutions, since they are simply examples and are not used to measure correctness in the test-based framework. This key feature of a test-based evaluation makes it possible to perform mapping of an evaluation set from one language to many others by static analyses, as outlined below. For other code-related evaluations that require access to canonical solutions, we synthesize solutions by generating many code versions based on the converted prompt and use our converted test statement to filter for correctness (Section O.1.1).\\n\\nO.1 LANGUAGE CONVERSION OF PROMPTS AND TEST CASES\\n\\nO.1.1 FORMAT CHOICE\\n\\nThe purpose of this work is to build datasets that allow us to measure multi-lingual code generation abilities. The function completion format helps steer the model to generate code in a specific language since the prompt consists of a partial function that has already been started, i.e. a function signature. This is in contrast to other formats such as that of the original MBPP where the prompt does not consist of a function signature, but contains more implicit information such as assert statements, example function calls, and a description such as \u201cWrite code in Python\u201d (see Appendix R.1.1 for examples). Compared to other formats, the execution-based function completion aligns well with how an ML-driven model would perform code suggestion in a typical coding environment. Therefore, we process our converted datasets and the original datasets (MBPP, MathQA) to be of this format, except for the original HumanEval dataset whose format is already consistent.\\n\\nO.1.2 INFERRING ARGUMENT AND RETURN TYPES\\n\\nThis step is applicable for statically typed target languages such as Java, C#, etc. The process starts from inferring the types of function arguments, which can be done by inspecting the argument values. We perform mapping of types from Python to types in a target language; for instance, to convert to Java, we map list \u2192 ArrayList or dict \u2192 HashMap. Values for different test cases can have different types, therefore we infer the common superclass of all observed types for each argument. Since there can also be many levels of types, due to containers such as list or sets, we recursively infer the types among each level to be consistent. For example, \u201clist of list\u201d and \u201clist of object\u201d has a common type of \u201clist of object\u201d. The return type is inferred via expected return values in the test cases.\\n\\nO.1.3 SUPPORTED TYPES OF OBJECT CONVERSION\\n\\nOur conversion framework depends on the structure of basic programming problems which involve object types of the following:\\n\\n\u2022 Integer or long version of integer\\n\u2022 Float or double\\n\u2022 Boolean\\n\u2022 String. We assume any string of single character is also of type string for the purpose of conversion.\\n\u2022 None. This depends whether the target language also supports None/null/nil types.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 63, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"\u2022 List. Tuples in Python are also converted to list in all languages.\\n\\n- Dictionary\\n- Set\\n\\nFor any container type, we recursively perform object conversion for all nested structures within the container.\\n\\nO.1.4 CONSTRUCTING REPRESENTATIONS OF CODE OBJECTS\\n\\nWe convert the argument and return values from Python to a target language by generating strings that represent the target language\u2019s objects. For example, the object `[1, 2, 3]` in Python is converted to `Arrays.asList(1, 2, 3)` in Java, as shown in Figure 2. We recursively construct container elements for any nested structures.\\n\\nO.1.5 CONVERTING TEST STATEMENT\\n\\nWe construct objects for function argument inputs, using above information regarding constructed objects and types, as well as expected output. We build the test statement in a target language using appropriate assertion to match the returned value with the expected output. We perform deep object comparison with an appropriate comparator for each language.\\n\\nO.1.6 PROMPT CONSTRUCTION\\n\\nWe ensure that the converted function, argument, and class names are stylistically appropriate for each language, e.g., camel case versus snake case, etc. We construct function call examples in the docstring to look representative without being too verbose, e.g., we use `[1, 2, 3]` in Java\u2019s docstring to represent a list, instead of an actual `ArrayList`. We avoid using language-reserve words for variable names such as `end` for Ruby or `char` for Java or C++ and escape certain substrings that are keywords such as `/*` or `//`.\\n\\nWe also deal with all formats in the prompt with great care. For instance, docstrings for Java and JavaScript are to be before the function signature, following the convention. For Java, this is crucial, otherwise it would be too out of distribution and the model would not generate anything, if docstring is below function signature.\\n\\nO.1.7 DOCSTRING AND NATURAL LANGUAGE CONVERSION\\n\\nThe natural language statements for datasets such as MBPP can contain Python-specific statements that might not be applicable to Java or JavaScript such as \u201cWrite a function in Python to ...\u201d or \u201c... if the object does not exist, return None\u201d. We substitute \u201cPython\u201d with the target language name, \u201cNone\u201d as appropriate null values.\\n\\nO.1.8 VALIDATION\\n\\nWe validate that converted objects, test statements and function signatures parse and/or compile with respect to each language.\\n\\nO.1.9 QUALITY CHECK VIA REVIEWERS\\n\\nTo gauge the quality of our conversion, we also request annotators to manually review the converted programming problems in sample languages, namely, Java and JavaScript. We ask language experts to identify issues with converted examples consisting of natural language statement, test cases, and function signature and use this process to help iteratively improve our conversion algorithm. For the final review, annotators have not found issues specifically related to language conversion, but observed ambiguity in some cases attributed to the original dataset. In the future, any updates to the original datasets can be propagated to all converted languages programmatically. We provide the detailed analysis of evaluation by annotators in Appendix Q.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 64, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"We find ML translators to be insufficient to perform the dataset conversion, due to limited support for language pairs, restriction on format, as well as transformation errors related to types and object construction. In contrast, our framework can convert data to many target languages and does not have non-deterministic errors related to type inference or object mapping. We provide further discussion and examples in Appendix O.2.\\n\\nThe availability of canonical solutions in each converted language can open up the possibilities to perform other types of evaluation. To generate such synthetic solutions for each language, we sample up to $10^5$ versions of code per problem and filter them for correctness with our converted tests. In order to generate at least one correct solution for as many problems as possible, we use both the function completion and zero-shot translation settings (see Section 4.3) where we prepend the Python solution, provided in the original datasets by human annotators, to the beginning of the function signature prompt. With high-temperature sampling, we are able to generate correct solutions for a large portion of all problems, with 96% coverage for JavaScript, 93% for Java, and even on an out-of-domain language such as PHP with 93% coverage (more details in Appendix P).\\n\\nWe conduct preliminary experiments using a publicly available code translation model Transcoder (Lachaux et al., 2020b) to perform dataset conversion. Overall, there are two main limitations of this approach. First, these models typically support a limited number of language pairs, which means that we would not be able to perform conversion to 10+ languages like with our proposed framework. Second, we find that there are some common errors associated with type inference, for instance, when the return type should be `boolean`, the translation model can predict `int` as a return type. These types of error cause false negatives and can impact overall quality of the converted datasets. In contrast, we do not have these types of errors in our conversion framework due to the static analysis implementation.\\n\\nIn particular, Transcoder (Lachaux et al., 2020b) supports Python, Java, and C++. In this setup, we use a complete function in Python as an input prompt. The transcoder model then generates a complete function in Java and C++. Here, we are interested in whether the model is able to translate function signatures that capture necessary information.\\n\\nExample 1\\n\\nWhile the model seems able to translate the function signature, the function name for Java and C++ appear to be in snake case, which is not the standard for these languages.\\n\\n```\\ndef differ_At_One_Bit_Pos(a,b):\\n    return is_Power_Of_Two(a ^ b)\\n```\\n\\n```\\npublic static boolean differAt_One_Bit_Pos ( int a , int b ) {\\n\\n}\\n```\\n\\n```\\n(bool Differ_At_One_Bit_Pos ( int a , int b ) {\\n\\n}\\n```\\n\\nExample 2\\n\\nThe model seems to adapt the function name to be entirely different, i.e., `is_undulating` to `isAbundulating` or `isSkundulating`.\\n\\n```\\ndef is_undulating(n):\\n    if (len(n) <= 2):\\n        return False\\n    for i in range(2, len(n)):\\n        if (n[i - 2] != n[i]):\\n            return False\\n    return True\\n```\\n\\n```\\n-------------------- Translation in Java -------------------\\n```\\n\\n```\\n-------------------- Translation in C++ --------------------\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 9, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"contexts where we split the original function signature and the canonical solution into left context, right context, and ground truth insertion code. Code insertion is evaluated in an execution-based manner by using the same test statements as in MBXP. We benchmark using the publicly available insertion-based model, InCoder (Fried et al., 2022).\\n\\nBoth models show that incorporating right context can significantly boost performance compared to using only the left context. In InCoder, we observed $23.2\\\\%$, $14.4\\\\%$, and $37.6\\\\%$ relative improvements on Python, JavaScript, and Java respectively compared to the case without right context. Ablation studies on the performance versus the number of right context lines show a positive correlation, indicating the models' abilities to incorporate partial right context information to improve prediction.\\n\\nWe provide further details on dataset construction and results in Appendix K. This work demonstrates the usefulness of our MBXP benchmark for code insertion and highlights the need for further research in execution-based multi-lingual code insertion evaluation.\\n\\n4.7 Code Summarization: S-MBXP\\n\\nWe evaluate the ability of models to perform code summarization, where we use a function signature along with its solution as the prompt, with the natural language description in the docstring removed. Based on this prompt, we induce the model to generate the description of the code's functionality. Our results show that, in both zero-shot and few-shot settings, multi-lingual models generally outperform mono-lingual models, consistent with the performance trends observed in other evaluation tasks discussed in Section 4.2.3. In the few-shot case, we observe noticeable improvements compared to the zero-shot setting, with more significant improvement on larger models. We provide examples and detailed results in Appendix L.\\n\\n5 Related Work\\n\\nMany other evaluation datasets can be considered for the conversion to multi-lingual counterparts such as APPS (Hendrycks et al., 2021) and CodeContest (Li et al., 2022a). These datasets in its original forms are execution-based datasets containing challenging algorithmic competition problems and tests that are language-agnostic, but can be converted to Python and many other languages. Existing benchmarks for code generation are primarily either match-based or focused mostly on Python, if not language-agnostic. Our work fills a gap in the literature by providing a multi-lingual code evaluation framework that includes synthetic solutions, handles datasets beyond HumanEval (e.g., MBPP and MathQA), and investigates various types of code generation abilities. Concurrent work by Cassano et al. (2022) converts prompts and test cases of HumanEval into multiple languages. Recent work by Orlanski et al. (2023) presents BabelCode, a framework for execution-based evaluation, and investigates the effectiveness of balancing the distribution of languages in a training dataset. Together, these works provide a valuable resource for researchers to evaluate multi-lingual code generation. We provide further discussion of related work in Appendix B.\\n\\n6 Discussion\\n\\nOur release of these datasets is a significant contribution to the field of code generation research, providing researchers with a valuable resource to evaluate various aspects of code generation abilities. The findings from our evaluations have shed light on interesting areas such as multi- vs mono-lingual models, out-of-domain performance, zero-shot translation abilities, and multi-lingual code insertion, all of which hold potential for advancing the state-of-the-art in code generation.\\n\\nOur observations suggest that large multi-lingual models are more effective than multiple mono-lingual models in code generation tasks, benefiting from the data spillover across languages. The success of our multi-lingual models in out-of-domain evaluations and robustness testing demonstrates their potential to generalize to new languages and tasks. However, to comprehensively evaluate the complexities of real-world software development tasks, it may be necessary to include additional language-specific evaluations where appropriate. Overall, our datasets provide a solid foundation for future research to explore and enhance various aspects of code generation, with the potential to lead to significant advancements in the field.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 10, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Karan Aggarwal, Mohammad Salameh, and Abram Hindle. Using machine translation for converting python 2 to python 3 code. Technical report, PeerJ PrePrints, 2015. URL https://peerj.com/preprints/1459/.\\n\\nWasi Ahmad, Saikat Chakraborty, Baishakhi Ray, and Kai-Wei Chang. Unified pre-training for program understanding and generation. In Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pp. 2655\u20132668, 2021a.\\n\\nWasi Uddin Ahmad, Md Golam Rahman Tushar, Saikat Chakraborty, and Kai-Wei Chang. Avatar: A parallel corpus for java-python program translation. arXiv preprint arXiv:2108.11590, 2021b.\\n\\nMiltiadis Allamanis and Charles Sutton. Mining source code repositories at massive scale using language modeling. In 2013 10th Working Conference on Mining Software Repositories (MSR), pp. 207\u2013216. IEEE, 2013.\\n\\nJacob Austin, Augustus Odena, Maxwell I. Nye, Maarten Bosma, Henryk Michalewski, David Dohan, Ellen Jiang, Carrie J. Cai, Michael Terry, Quoc V. Le, and Charles Sutton. Program synthesis with large language models. CoRR, abs/2108.07732, 2021. URL https://arxiv.org/abs/2108.07732.\\n\\nShraddha Barke, Michael B. James, and Nadia Polikarpova. Grounded copilot: How programmers interact with code-generating models, 2022. URL https://arxiv.org/abs/2206.15000.\\n\\nTom B. Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel M. Ziegler, Jeffrey Wu, Clemens Winter, Christopher Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, and Dario Amodei. Language models are few-shot learners. In Hugo Larochelle, Marc'Aurelio Ranzato, Raia Hadsell, Maria-Florina Balcan, and Hsuan-Tien Lin (eds.), Advances in Neural Information Processing Systems 33: Annual Conference on Neural Information Processing Systems 2020, NeurIPS 2020, December 6-12, 2020, virtual, 2020. URL https://proceedings.neurips.cc/paper/2020/hash/1457c0d6bfcb4967418bfb8ac142f64a-Abstract.html.\\n\\nFederico Cassano, John Gouwar, Daniel Nguyen, Sydney Nguyen, Luna Phipps-Costin, Donald Pinckney, Ming Ho Yee, Yangtian Zi, Carolyn Jane Anderson, Molly Q Feldman, Arjun Guha, Michael Greenberg, and Abhinav Jangda. A scalable and extensible approach to benchmarking nl2code for 18 programming languages, 2022. URL https://arxiv.org/abs/2208.08227.\\n\\nMark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared Kaplan, Harrison Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, Alex Ray, Raul Puri, Gretchen Krueger, Michael Petrov, Heidy Khlaaf, Girish Sastry, Pamela Mishkin, Brooke Chan, Scott Gray, Nick Ryder, Mikhail Pavlov, Alethea Power, Lukasz Kaiser, Mohammad Bavarian, Clemens Winter, Philippe Tillet, Felipe Petroski Such, Dave Cummings, Matthias Plapert, Fotios Chantzis, Elizabeth Barnes, Ariel Herbert-Voss, William Hebgen Guss, Alex Nichol, Alex Paino, Nikolas Tezak, Jie Tang, Igor Babuschkin, Suchir Balaji, Shantanu Jain, William Saunders, Christopher Hesse, Andrew N. Carr, Jan Leike, Joshua Achiam, Vedant Misra, Evan Morikawa, Alec Radford, Matthew Knight, Miles Brundage, Mira Murati, Katie Mayer, Peter Welinder, Bob McGrew, Dario Amodei, Sam McCandlish, Ilya Sutskever, and Wojciech Zaremba. Evaluating large language models trained on code. CoRR, abs/2107.03374, 2021. URL https://arxiv.org/abs/2107.03374.\\n\\nXinyun Chen, Chang Liu, and Dawn Song. Tree-to-tree neural networks for program translation. In S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. Garnett (eds.), Advances in Neural Information Processing Systems, volume 31. Curran Associates, Inc., 2018. URL https://proceedings.neurips.cc/paper/2018/file/d759175de8ea5b1d9a2660e45554894f-Paper.pdf.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 11, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":null}"}
{"id": "Bo7eeXm6An8", "page_num": 12, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Dhiraj Kalamkar, Dheevatsa Mudigere, Naveen Mellempudi, Dipankar Das, Kunal Banerjee, Sasikanth Avancha, Dharma Teja Vootturi, Nataraj Jammalamadaka, Jianyu Huang, Hector Yuen, et al. A study of bfloat16 for deep learning training. arXiv preprint arXiv:1905.12322, 2019.\\n\\nSvetoslav Karaivanov, Veselin Raychev, and Martin Vechev. Phrase-based statistical translation of programming languages. In Proceedings of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming & Software, pp. 173\u2013184, 2014. URL https://doi.org/10.1145/2661136.2661148.\\n\\nSumith Kulal, Panupong Pasupat, Kartik Chandra, Mina Lee, Oded Padon, Alex Aiken, and Percy Liang. Spoc: Search-based pseudocode to code. CoRR, abs/1906.04908, 2019. URL http://arxiv.org/abs/1906.04908.\\n\\nMarie-Anne Lachaux, Baptiste Roziere, Lowik Chanussot, and Guillaume Lample. Unsupervised translation of programming languages. In Advances in Neural Information Processing Systems, volume 33, pp. 20601\u201320611. Curran Associates, Inc., 2020a. URL https://proceedings.neurips.cc/paper/2020/file/ed23fbf18c2cd35f8c7f8de44f85c08d-Paper.pdf.\\n\\nMarie-Anne Lachaux, Baptiste Roziere, Lowik Chanussot, and Guillaume Lample. Unsupervised translation of programming languages, 2020b. URL https://arxiv.org/abs/2006.03511.\\n\\nBrian Lester, Rami Al-Rfou, and Noah Constant. The power of scale for parameter-efficient prompt tuning. In Marie-Francine Moens, Xuanjing Huang, Lucia Specia, and Scott Wen-tau Yih (eds.), Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing, EMNLP 2021, Virtual Event / Punta Cana, Dominican Republic, 7-11 November, 2021, pp. 3045\u20133059. Association for Computational Linguistics, 2021. doi: 10.18653/v1/2021.emnlp-main.243. URL https://doi.org/10.18653/v1/2021.emnlp-main.243.\\n\\nXiang Lisa Li and Percy Liang. Prefix-tuning: Optimizing continuous prompts for generation. In Chengqing Zong, Fei Xia, Wenjie Li, and Roberto Navigli (eds.), Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing, ACL/IJCNLP 2021, (Volume 1: Long Papers), Virtual Event, August 1-6, 2021, pp. 4582\u20134597. Association for Computational Linguistics, 2021. doi: 10.18653/v1/2021.acl-long.353. URL https://doi.org/10.18653/v1/2021.acl-long.353.\\n\\nYujia Li, David Choi, Junyoung Chung, Nate Kushman, Julian Schrittwieser, R\u00e9mi Leblond, Tom Eccles, James Keeling, Felix Gimeno, Agustin Dal Lago, Thomas Hubert, Peter Choy, Cyprien de Masson d\u2019Autume, Igor Babuschkin, Xinyun Chen, Po-Sen Huang, Johannes Welbl, Sven Gowal, Alexey Cherepanov, James Molloy, Daniel J. Mankowitz, Esme Sutherland Robson, Pushmeet Kohli, Nando de Freitas, Koray Kavukcuoglu, and Oriol Vinyals. Competition-level code generation with alphacode, 2022a. URL https://arxiv.org/abs/2203.07814.\\n\\nZhenhao Li and Lucia Specia. Improving neural machine translation robustness via data augmentation: Beyond back translation. arXiv preprint arXiv:1910.03009, 2019.\\n\\nZongjie Li, Chaozheng Wang, Zhibo Liu, Haoxuan Wang, Shuai Wang, and Cuiyun Gao. Cctest: Testing and repairing code completion systems. arXiv preprint arXiv:2208.08289, 2022b.\\n\\nXiao Liu, Kaixuan Ji, Yicheng Fu, Zhengxiao Du, Zhilin Yang, and Jie Tang. P-tuning v2: Prompt tuning can be comparable to fine-tuning universally across scales and tasks. CoRR, abs/2110.07602, 2021a. URL https://arxiv.org/abs/2110.07602.\\n\\nXiao Liu, Yanan Zheng, Zhengxiao Du, Ming Ding, Yujie Qian, Zhilin Yang, and Jie Tang. GPT understands, too. CoRR, abs/2103.10385, 2021b. URL https://arxiv.org/abs/2103.10385.\\n\\nIlya Loshchilov and Frank Hutter. Decoupled weight decay regularization. In International Conference on Learning Representations, 2018.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 29, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Comparing pass@k scores of 2.7b Monolingual and Multi-lingual Models\\n\\n| Language | pass@1  | pass@5  | pass@10 | pass@30 | pass@100 |\\n|----------|---------|---------|---------|---------|----------|\\n| Python   | 27.2    | 42.8    | 50.6    | 62.8    | 72.4     |\\n| Java     | 24.2    | 41.4    | 49.2    | 59.0    | 64.8     |\\n| JavaScript| 40.5    | 54.2    | 60.0    | 68.0    | 75.0     |\\n\\nFigure 12: pass@k trends for 2.7B monlingual and multi-lingual models for in-domain and out-of-domain languages.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 30, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Comparing pass@k scores of 13b Monolingual and Multi-lingual Models\\n\\nFigure 13: pass@k trends for 13B monlingual and multi-lingual models for in-domain and out-of-domain languages.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 31, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"In this section, we present more detailed results on few-shot prompting with prompt consisting of three correct functions from the respective MBXP dataset. The few-shot prompts are selected from three correct samples for each language. We note that this gives an automatic performance gain of roughly 0.3% since there are $\\\\approx 1000$ cases for each evaluation language. However, this is quite small compared to the gains observed. We do not tune on the few-shot examples selected; that is, these examples are chosen once and fixed for all usage. It is possible that this can be further tuned, such as the case of prompt engineering in the literature.\\n\\nG.1 Evaluation Results\\n\\nFrom Figure 14, we observe that the performance gain is quite clear especially for out-of-domain languages (pass $\\\\hat{\\\\text{@}}$ with temperature 0.2). In some cases, there are large performance boosts for mono-lingual models evaluated on out-of-domain languages. For instance, with few-shot prompting, the pass $\\\\hat{\\\\text{@}}$ of the 13B Python model evaluated on MBJP increases from 5.7% to 10.3%. Similarly, the pass $\\\\hat{\\\\text{@}}$ of the 13B multi-lingual model increases from 5.9% to 12.2% with few-shot prompting.\\n\\nG.2 Qualitative Examples\\n\\nWe demonstrate the few-shot prompts for select languages. Each of these prompts precede the function completion prompt for each evaluation.\\n\\nG.2.1 Python Few-Shot Prompt\\n\\n```python\\ndef find_char_long(text):\\n    \\\"\\\"\\\"Write a function to find all words which are at least 4 characters long in a string by using regex.\\\"\\n    >>> find_char_long('Please move back to stream')\\n    ['Please', 'move', 'back', 'stream']\\n    >>> find_char_long('Jing Eco and Tech')\\n    ['Jing', 'Tech']\\n    >>> find_char_long('Jhingai wulu road Zone 3')\\n    ['Jhingai', 'wulu', 'road', 'Zone']\\n    \\\"\\\"\\\"\\n    import re\\n    return re.findall(r\\\"\\\\b\\\\w{4,}\\\\b\\\", text)\\n\\ndef square_nums(nums):\\n    \\\"\\\"\\\"Write a function to find squares of individual elements in a list using lambda function.\\\"\\n    >>> square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\\n    [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\\n    >>> square_nums([10, 20, 30])\\n    [100, 400, 900]\\n    >>> square_nums([12, 15])\\n    [144, 225]\\n    \\\"\\\"\\\"\\n    return list(map(lambda x: x**2, nums))\\n\\ndef test_duplicate(arraynums):\\n    \\\"\\\"\\\"Write a function to find whether a given array of integers contains any duplicate element.\\\"\\n    >>> test_duplicate([1, 2, 3, 4, 5])\\n    False\\n    >>> test_duplicate([1, 2, 3, 4, 4])\\n    True\\n    >>> test_duplicate([1, 1, 2, 2, 3, 3, 4, 4, 5])\\n    True\\n    \\\"\\\"\\\"\\n    if len(arraynums) == len(set(arraynums)):\\n        return False\\n    else:\\n        return True\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 32, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 14: Performance difference due to few-shot prompting (pass@1 with temperature 0.2).\"}"}
{"id": "Bo7eeXm6An8", "page_num": 69, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"import java.io.*\\nimport java.lang.*\\nimport java.util.*\\nimport java.math.*\\n\\nclass MinCost {\\n    public static int minCost(List<List<Integer>> cost, int m, int n) {\\n        int[][] dp = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = cost.get(i).get(j);\\n                } else if (i == 0) {\\n                    dp[i][j] = dp[i][j - 1] + cost.get(i).get(j);\\n                } else if (j == 0) {\\n                    dp[i][j] = dp[i - 1][j] + cost.get(i).get(j);\\n                } else {\\n                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + cost.get(i).get(j);\\n                }\\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n}\\n\\nclass Main {\\n    public static boolean compare(Object obj1, Object obj2) {\\n        return obj1.equals(obj2);\\n    }\\n\\n    public static void main(String[] args) throws Exception {\\n        int x0 = MinCost.minCost(Arrays.asList(Arrays.asList(1, 2, 3), Arrays.asList(4, 8, 2), Arrays.asList(1, 5, 3)), 2, 2);\\n        if (!(compare(x0, 8))) {\\n            throw new java.lang.Exception(\"Exception -- test case 0 did not pass. x0 = \" + x0);\\n        }\\n\\n        int x1 = MinCost.minCost(Arrays.asList(Arrays.asList(2, 3, 4), Arrays.asList(5, 9, 3), Arrays.asList(2, 6, 4)), 2, 2);\\n        if (!(compare(x1, 12))) {\\n            throw new java.lang.Exception(\"Exception -- test case 1 did not pass. x1 = \" + x1);\\n        }\\n\\n        int x2 = MinCost.minCost(Arrays.asList(Arrays.asList(3, 4, 5), Arrays.asList(6, 10, 4), Arrays.asList(3, 7, 5)), 2, 2);\\n        if (!(compare(x2, 16))) {\\n            throw new java.lang.Exception(\"Exception -- test case 2 did not pass. x2 = \" + x2);\\n        }\\n    }\\n}\"}"}
{"id": "Bo7eeXm6An8", "page_num": 70, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"function minCost(cost, m, n) {\\n    // --------------------- COMPLETION (model generated) ---------------------\\n    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            dp[i][j] = cost[i - 1][j - 1] + Math.min(dp[i - 1][j], dp[i][j - 1]);\\n        }\\n    }\\n    return dp[m][n];\\n}\\n\\n// --------------------- TEST ---------------------\\n\\n// --------------------- MBTSP/1: PROMPT ---------------------\\n\\n/**\n * Write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost and a position (m, n) in cost.\\n * \\n * Examples:\\n * >>> min_cost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2)\\n * >>> 8\\n * >>> min_cost([[2, 3, 4], [5, 9, 3], [2, 6, 4]], 2, 2)\\n * >>> 12\\n * >>> min_cost([[3, 4, 5], [6, 10, 4], [3, 7, 5]], 2, 2)\\n * >>> 16\\n */\\n\\nconst min_cost = function (cost: Array<Array<number>>, m: number, n: number): number {\\n    // --------------------- COMPLETION (model generated) ---------------------\\n    const dp = [];\\n    for (let i = 0; i <= m; i++) {\\n        dp[i] = [];\\n        for (let j = 0; j <= n; j++) {\\n            dp[i][j] = Number.MAX_SAFE_INTEGER;\\n        }\\n    }\\n    dp[0][0] = cost[0][0];\\n    for (let i = 1; i <= m; i++) {\\n        dp[i][0] = cost[i][0] + dp[i - 1][0];\\n    }\\n    for (let j = 1; j <= n; j++) {\\n        dp[0][j] = cost[0][j] + dp[0][j - 1];\\n    }\\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            dp[i][j] = cost[i - 1][j - 1] + Math.min(dp[i - 1][j], dp[i][j - 1]);\\n        }\\n    }\\n    return dp[m][n];\\n}\"}"}
{"id": "Bo7eeXm6An8", "page_num": 71, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"package main\\n\\n// Code should be written in Go/Golang\\n\\n// Write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].\\n\\n// Examples:\\n// >>> min_cost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2)\\n// >>> 8\\n// >>> min_cost([[2, 3, 4], [5, 9, 3], [2, 6, 4]], 2, 2)\\n// >>> 12\\n// >>> min_cost([[3, 4, 5], [6, 10, 4], [3, 7, 5]], 2, 2)\\n// >>> 16\\n\\nfunc min_cost(cost [][]int, m int, n int) int {\\n    R := 3\\n    C := 3\\n    tc := make([][]int, 0)\\n    tc[0][0] := cost[0][0]\\n    for i := 1; i <= m; i++ {\\n        tc[i][0] := tc[i-1][0] + cost[i][0]\\n    }\\n    for j := 1; j <= n; j++ {\\n        tc[0][j] := tc[0][j-1] + cost[0][j]\\n    }\\n    for i := 1; i <= m; i++ {\\n        for j := 1; j <= n; j++ {\\n            tc[i][j] := min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]\\n        }\\n    }\\n    return tc[m][n]\\n}\\n\\n// --------------------- TEST ---------------------\\n\\nfunc deepCompare(a interface{}, b interface{}) bool {\\n    aJSON, err := json.Marshal(a)\\n    if err != nil {\\n        panic(err)\\n    }\\n    bJSON, err := json.Marshal(b)\\n    if err != nil {\\n        panic(err)\\n    }\\n    var a2 interface{}\\n    var b2 interface{}\\n    err = json.Unmarshal(aJSON, &a2)\\n    if err != nil {\\n        panic(err)\\n    }\\n    err = json.Unmarshal(bJSON, &b2)\\n    if err != nil {\\n        panic(err)\\n    }\\n    result := reflect.DeepEqual(a2, b2)\\n    if result {\\n        return true\\n    } else {\\n        panic(fmt.Sprintf(\"%v != %v\", a, b))\\n    }\\n}\\n\\nfunc main() {\\n    actual_1 := min_cost([][]int{{[]int{1, 2, 3}, []int{4, 8, 2}, []int{1, 5, 3}}, 2, 2)\\n    expected_1 := 8\\n    deepCompare(actual_1, expected_1)\\n\\n    actual_2 := min_cost([][]int{{[]int{2, 3, 4}, []int{5, 9, 3}, []int{2, 6, 4}}, 2, 2)\\n    expected_2 := 12\\n    deepCompare(actual_2, expected_2)\\n\\n    actual_3 := min_cost([][]int{{[]int{3, 4, 5}, []int{6, 10, 4}, []int{3, 7, 5}}, 2, 2)\\n    expected_3 := 16\\n    deepCompare(actual_3, expected_3)\\n}\"}"}
{"id": "Bo7eeXm6An8", "page_num": 72, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text.RegularExpressions;\\n\\nnamespace Solution\\n{\\n    public class Program\\n    {\\n        /// <summary>\\n        /// Write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[,] and a position (m, n) in cost[,].\\n        /// Examples:\\n        /// >>> MinCost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2)\\n        /// >>> 8\\n        /// >>> MinCost([[2, 3, 4], [5, 9, 3], [2, 6, 4]], 2, 2)\\n        /// >>> 12\\n        /// >>> MinCost([[3, 4, 5], [6, 10, 4], [3, 7, 5]], 2, 2)\\n        /// >>> 16\\n        /// </summary>\\n        public static int MinCost(List<List<int>> cost, int m, int n)\\n        {\\n            // --------------------- COMPLETION (model generated) ---------------------\\n            // TODO: Write your code here\\n            return 0;\\n        }\\n    }\\n}\\n\\n// --------------------- TEST ---------------------\\npublic static void Main(string[] args)\\n{\\n    CompareLogic compareLogic = new CompareLogic();\\n    var actual1 = MinCost(new List<List<int>> { new List<int> { 1, 2, 3 }, new List<int> { 4, 8, 2 }, new List<int> { 1, 5, 3 } }, 2, 2);\\n    var expected1 = 8;\\n    var result1 = compareLogic.Compare(actual1, expected1);\\n    if (!result1.AreEqual) { throw new Exception(\"assertion failed\"); }\\n\\n    var actual2 = MinCost(new List<List<int>> { new List<int> { 2, 3, 4 }, new List<int> { 5, 9, 3 }, new List<int> { 2, 6, 4 } }, 2, 2);\\n    var expected2 = 12;\\n    var result2 = compareLogic.Compare(actual2, expected2);\\n    if (!result2.AreEqual) { throw new Exception(\"assertion failed\"); }\\n\\n    var actual3 = MinCost(new List<List<int>> { new List<int> { 3, 4, 5 }, new List<int> { 6, 10, 4 }, new List<int> { 3, 7, 5 } }, 2, 2);\\n    var expected3 = 16;\\n    var result3 = compareLogic.Compare(actual3, expected3);\\n    if (!result3.AreEqual) { throw new Exception(\"assertion failed\"); }\\n\\n}\\n\\nR.1.7 MBPHP: PHP\\n\\n// --------------------- MBPHP/1: PROMPT ---------------------\\n\\n/**\n * You are an expert PHP programmer, and here is your task.\\n * Write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[,] and a position (m, n) in cost[,].\\n * php > minCost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2)\\n * 8\\n * php > minCost([[2, 3, 4], [5, 9, 3], [2, 6, 4]], 2, 2)\\n * 12\\n * php > minCost([[3, 4, 5], [6, 10, 4], [3, 7, 5]], 2, 2)\\n * 16\\n */\\n\\nfunction minCost($cost, $m, $n) {\\n    // --------------------- COMPLETION (model generated) ---------------------\\n    $min = $cost[$m][$n];\\n    for ($i = $m + 1; $i < $m + $n; $i++) {\\n        for ($j = $i + 1; $j < $m + $n; $j++) {\\n            if ($cost[$i][$j] < $min) {\\n                $min = $cost[$i][$j];\\n            }\\n        }\\n    }\\n    return $min;\\n}\"}"}
{"id": "Bo7eeXm6An8", "page_num": 77, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"func minCost(cost : [[Int]], m : Int, n : Int) -> Int {\\n    // --------------------- COMPLETION (model generated) ---------------------\\n    if (m == 0 || n == 0) {\\n        return 0;\\n    }\\n    if (m == 1 || n == 1) {\\n        return cost[0][1];\\n    }\\n    if (cost[m][n] != -1) {\\n        return cost[m][n];\\n    }\\n    cost[m][n] = min(minCost(cost, m - 1, n) + cost[m][n], minCost(cost, m, n - 1) + cost[m][n]);\\n    return cost[m][n];\\n}\\n\\n// --------------------- CANONICAL SOLUTION ---------------------\\nvar arg00 : [[Int]] = [[1, 2, 3], [4, 8, 2], [1, 5, 3]]\\nvar arg01 : Int = 2\\nvar arg02 : Int = 2\\nvar x0 : Int = minCost(cost : arg00, m : arg01, n : arg02)\\nvar v0 : Int = 8\\nassert(x0 == v0, \\\"Exception -- test case 0 did not pass. x0 = \\\")\\n\\nvar arg10 : [[Int]] = [[2, 3, 4], [5, 9, 3], [2, 6, 4]]\\nvar arg11 : Int = 2\\nvar arg12 : Int = 2\\nvar x1 : Int = minCost(cost : arg10, m : arg11, n : arg12)\\nvar v1 : Int = 12\\nassert(x1 == v1, \\\"Exception -- test case 1 did not pass. x1 = \\\")\\n\\nvar arg20 : [[Int]] = [[3, 4, 5], [6, 10, 4], [3, 7, 5]]\\nvar arg21 : Int = 2\\nvar arg22 : Int = 2\\nvar x2 : Int = minCost(cost : arg20, m : arg21, n : arg22)\\nvar v2 : Int = 16\\nassert(x2 == v2, \\\"Exception -- test case 2 did not pass. x2 = \\\")\\n\\nR.2 MULTILINGUAL\\n\\nHumanEval contains 164 cases, most of which are compatible with our conversion framework. For some cases where the tests are not explicit, such as using Python for loop to iterate over many test cases, we expand them out explicitly to make it compatible with the conversion framework. For instance, the test statement below\\n\\n```python\\nfor x in range(2, 8):\\n    assert candidate(x, x+1) == str(x)\\n```\\n\\nis expanded to\\n\\n```python\\nassert candidate(2, 3) == \\\"2\\\"\\nassert candidate(3, 4) == \\\"3\\\"\\nassert candidate(4, 5) == \\\"4\\\"\\nassert candidate(5, 6) == \\\"5\\\"\\nassert candidate(6, 7) == \\\"6\\\"\\nassert candidate(7, 8) == \\\"7\\\"\\n```\\n\\nThere are some cases that we filtered out such as cases that involve a user defined function. In total, we keep 161 out of 164 cases. We format of multi-lingual HumanEval are similar to that of MBXP in each language; therefore, we skip the display of examples in this section for brevity.\\n\\nR.3 MULTILINGUAL MATH QA\\n\\nBy extending MathQA-python datasets Austin et al. (2021) for other programming languages, we obtained MathQA-Java and MathQA-JavaScript, for the purpose of evaluating the ability of the models to reason and synthesize code from more complex text, under multiple languages. The original MathQA-python problem contains a short text (which describes a mathematical question),\"}"}
{"id": "Bo7eeXm6An8", "page_num": 78, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2023\\n\\nBased on this, to build a version in a different language, we perform the following two transformation steps:\\n\\n1. Convert MathQA-Python problem into our canonical MBXP format (Section 3). Specifically, we construct a unified function signature, i.e. `def problem()`, followed by a docstring, which is equivalent to the short text of the original MathQA-Python.\\n\\n   ```python\\n   n0 = 5.0\\n   n1 = 31.1\\n   t0 = n1 + 100.0\\n   t1 = 100.0 - n0\\n   t2 = t0 * 100.0\\n   t3 = t2 / t1\\n   answer = t3 - 100.0\\n   return answer\\n   ```\\n\\n2. Obtain prompts and test cases in another language for execution-based evaluation using our proposed rule-based conversion framework.\\n\\nFor the conversion framework outlined in Section 3, we emphasize that we handle floating point comparing numbers to be within $\\\\epsilon = 1 \\\\times 10^{-8}$ instead of exact comparison. This handling is suitable for floating points and helps avoid potential false negatives. It is also compatible with all conversions in other datasets since it is handled within the abstract `compare` function in each target language.\\n\\nBelow, we show converted examples after the first step (including Python prompts, the canonical solution and a single test case) and its counterparts for Java and JavaScript generated from the second step.\\n\\n**MathQA-Python**\\n\\n```python\\ndef problem():\\n    \\\"\\\"\\\"a shopkeeper sold an article offering a discount of 5% and earned a profit of 31.1%.\\nwhat would have been the percentage of profit earned if no discount had been offered?\\n    \\\"\\\"\\n    n0 = 5.0\\n    n1 = 31.1\\n    t0 = n1 + 100.0\\n    t1 = 100.0 - n0\\n    t2 = t0 * 100.0\\n    t3 = t2 / t1\\n    answer = t3 - 100.0\\n    return answer\\n```\\n\\n**MathQA-Java**\\n\\n```java\\nimport java.io.*;\\nimport java.lang.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Problem {\\n\\n    public static double problem() {\\n        // the model output are inserted here.\\n        return answer;\\n    }\\n}\\n```\\n\\n```java\\nclass Main {\\n    public static boolean compare(Object obj1, Object obj2) {\\n        if (obj1 == null && obj2 == null) {\\n            return true;\\n        } else if (obj1 == null || obj2 == null) {\\n            return false;\\n        } else {\\n            if ((obj1 instanceof Double || obj1 instanceof Float) &&\\n                (obj2 instanceof Double || obj2 instanceof Float)) {\\n                if (obj1 instanceof Float) {\\n                    obj1 = ((Float) obj1).doubleValue();\\n                }\\n                return Math.abs(obj1 - obj2) < 1e-8;\\n            }\\n        }\\n    }\\n}\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 79, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"if (obj2 instanceof Float) {\\n    obj2 = ((Float) obj2).doubleValue();\\n}\\n\\nreturn Math.abs((double)obj1 - (double)obj2) < 1e-7;\\n\\nelse\\n    return obj1.equals(obj2);\\n\\n//execution-based test case\\npublic static void main(String[] args) throws Exception {\\n    double x0 = Problem.problem();\\n    if (!(compare(x0, 38.0))) {\\n        throw new java.lang.Exception(\\\"Exception -- test case 0 did not pass. x0 = \\\"+ x0);\\n    }\\n}\\n\\n--------------------- MathQA-JavaScript ---------------------\\n\\n/**\\n * a shopkeeper sold an article offering a discount of 5 % and earned a profit of 31.1 % .\\n * what would have been the percentage of profit earned if no discount had been offered ?\\n * n0 = 5.0\\n * n1 = 31.1\\n */\\n\\nfunction problem() {\\n    // the model output are inserted here.\\n}\\n\\n// execution-based test case\\nconst _ = require(\\\"lodash\\\")\\n\\nfunction compare(object1, object2) {\\n    if (typeof object1 == \\\"number\\\" && typeof object2 == \\\"number\\\") {\\n        return Math.abs(object1 - object2) < 1e-7;\\n    } else {\\n        return _.isEqual(object1, object2);\\n    }\\n}\\n\\nvar x = problem();\\nif (compare(x, 38.0)) {} else { throw 'Error at 1th assert statement. Value = ' + JSON.stringify(x); }\"}"}
{"id": "Bo7eeXm6An8", "page_num": 41, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"function getOddOccurrence(arr, arrSize) {\\n  for i in range(0, arr_size):\\n    count = 0\\n    for j in range(0, arr_size):\\n      if arr[i] == arr[j]:\\n        count += 1\\n    if count % 2 != 0:\\n      return arr[i]\\n  return -1\\n}\\n\\ndef get_odd_occurrence(arr, arr_size):\\n  occurrences = Hash.new\\n  for i in 0...arr_size:\\n    occurrences[arr[i]] ||= 0\\n    occurrences[arr[i]] += 1\\n  result = nil\\n  occurrences.each_pair do |k, v|\\n    if v % 2 != 0 && result == nil:\\n      result = k\\n  end\\n  result\\n}\\n\\ndef sort_matrix(M):\\n  \\\"\\\"\\\"\\n  Write a function to sort a given matrix in ascending order according to the sum of its rows.\\n  >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\\n  [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\\n  >>> sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])\\n  [[-2, 4, -5], [1, -1, 1], [1, 2, 3]]\\n  >>> sort_matrix([[5, 8, 9], [6, 4, 3], [2, 1, 4]])\\n  [[2, 1, 4], [6, 4, 3], [5, 8, 9]]\\n  \\\"\\\"\\\"\\n  result = sorted(M, key=sum)\\n  return result\\n\\nfun sortMatrix(m : List<List<Int>>) : List<List<Int>> {\\n  return m.sortedBy { it.sum() }\\n}\"}"}
{"id": "Bo7eeXm6An8", "page_num": 42, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Below, we show an extended version of the analysis in main text (Figure 7) where we demonstrate the differences in qualitative behaviors of few-shot prompting versus translation settings and their effects on helping the usual function completion task. The differences in these two modes are simply the prompts that precede the function completion prompt. That is, the few-shot setting uses 3 examples in the corresponding language and the translation mode uses the solution from the same problem in a different language. The translation setting helps the model solve difficult tasks that are very difficult to solve without a reference solution (Figure 21) whereas the the few-shot prompting helps condition the model to generate code properly in that respective syntax (See Section I.1).\\n\\nI.1 Test Case Error versus Non-Assertion Error\\n\\nWe categorize the failure of each generation code sample into two main categories: assertion or test-based errors versus non-assertion errors, which consist of all other errors such as compile, parsing, or runtime error not related to test cases. We use the results from temperature 0.2 with 30 samples for each problem and calculate the fraction of non-assertion errors over the number of all samples. The results in Figure 19 show that the few-shot prompting results in lower non-assertion errors for out-of-domain languages, indicating that few-shot prompts help models generate code with more precise syntax in each language. In contrast, there is little effect even evaluated on the in-domain languages, since the models already are fluent in these languages where the additional signals from the few-shot prompts do not help further. For the translation case, interesting we observe higher non-assertion errors on in-domain evaluation.\\n\\nWe perform sampling to generate 100 samples with temperature 0.8. For each task ID, we calculate the fraction of number of code samples that pass the test over a total of 100 samples. We repeat this experiment for the function completion baseline, few-shot prompting, and translation settings. In Figure 21, we sort the task IDs by the solve rate of the function completion baseline, which indicates the difficulty of various tasks in each dataset. We observe differences in how the solve rates for few-shot prompting or translation settings accumulate. For the few-shot case, the accumulation of the solve rates per task revolve near the baseline solve rate, indicating that the difficulty of the problem given the few-shot prompts do not deviate much from the difficulty in the baseline case. However, in the translation case, some task IDs that correspond to low baseline solve rate have much higher solve rate in the translation case, sometimes with perfect rate 1.0.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 43, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"Figure 20: The percentage of test case assertion error out of all the error cases on different in-domain (upper) and out-of-domain (lower) datasets.\\n\\n(a) MBKP (Kotlin)\\n\\n(b) MBPHP (PHP)\\n\\n(c) MBRBP (Ruby)\\n\\nFigure 21: For each task, we show a fraction of generations that pass the tests over the total number of samples (solve rate), where the task indices are ranked to show increasing difficulty. In the translation setting, tasks that are previously difficult (low solve rate for the baseline) can become easily solvable, demonstrating that models can leverage reference solutions in the source language to solve hard tasks. In contrast, the solve rates with few-shot prompting do not deviate as much from the baseline solve rate. Translation from different language sources exhibit similar trends where the source solution can help solve hard tasks where we observe unequal effects from different source languages. Figure 21 also demonstrates consistent effects of source languages. For a language such as Java, we observe that it can help solve many of the hard problems for MBPHP (PHP) evaluation, based on the high concentration of points around solve rate \\\\(0.00\\\\). This analysis also complements Section H which demonstrates unequal effects of source languages.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 44, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Robustness is an important indicator of the reliability of code generation models in practice. Here we provide a robustness benchmark for all the trained models across MBXP datasets. Specifically, we consider three natural data augmentations (1) Paraphrase by Back Translation (Li & Specia, 2019; Sugiyama & Yoshinaga, 2019) (e.g., \u201ccreate a function\u201d to \u201cwrite one function\u201d) (2) Character Case Change (\u201cCreate A FunctioN\u201d) and (3) Synonym Substitutions (Miller, 1995) (\u201cgenerate a function\u201d) as basic transformations to perturb the docstrings in prompts. We use the default settings and implementations of these three transformations from NL-Augmenter, a standard collection of data augmentations for robustness evaluation on text (Dhole et al., 2021). We select these three transformations since they can mostly maintain the naturalness for the tasks of code generations based on our observations. We then measure the average pass@1 with greedy decoding for all the models on datasets perturbed by each transformation. Here multi-lingual models are trained with multiple languages including Python, Java, Javascript (JS) while mono-lingual models are trained with each language individually. To simplify the comparisons, we call Ruby, PHP, and Kotlin as out-of-domain datasets for all the evaluated models while Python, Java, JS as in-domain datasets.\\n\\nResults\\nWe present the detailed results in Figure 22 and summarize several interesting observations below. (1) The percentages of pass@1 drops on perturbed datasets over regular ones are consistent across different sizes of the models. In specific, the average pass@1 over all the datasets drops from 2.26 to 2.07 for 125M models (8.56% drop), 6.40 to 5.87 for 672M models (8.25% drop), 9.20 to 8.33 for 2.7B models (9.40% drop), and 12.63 to 11.62 (8.02% drop). (2) For in-domain datasets, multi-lingual models have less percentage of performance drops compared to mono-lingual models under perturbations. On average, pass@1 of multi-lingual models drops from 21.36 to 19.73 (7.63% drop) while pass@1 of mono-lingual models drops from 16.90 to 15.24 (9.81% drop). (3) For out-of-domain datasets, multi-lingual models also have less percentage of performance drops compared to mono-lingual models under perturbations. On average, pass@1 of multi-lingual models drops from 6.78 to 6.24 (7.98% drop) while pass@1 of mono-lingual models drops from 2.72 to 2.47 (8.97% drop).\"}"}
{"id": "Bo7eeXm6An8", "page_num": 65, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"public static boolean isAbundulating ( int[] n ) {\\n\\n-------------------- Translation in C++ --------------------\\n\\n#endif\\n\\n\\nExample 3\\nIncorrect type inference where a nested list\\nnestedList\\nis Python is mapped to a\\nstring in C++, or simply a flat list of strings in Java.\\n\\nExample 4\\nA list\\ntest_list\\nis incorrectly inferred to have a type\\nstring\\nin C++.\\n\\nWe combine solutions for (1) normal function completion or with few-shot prompting if the language\\nis out-of-domain and (2) translation settings. This is because these different generation modes can\\nsynthetic correct solutions for different problems, according to our evaluation analyses in Section\\n4.2. We perform data generation in multiple stages. We first sample\\nn = 100\\nsamples for all cases,\\nafter which we sample for\\nn = 1000\\ncases for the problems where we have not found at least one\\ncorrect solution. The last step contains uses\\nn = 10000\\nsamples. We use temperature\\n0.8,\\n1.0\\nand\\n1.2\\nrespectively.\\n\\nDISCUSSION: GROUND TRUTH ASSUMPTIONS OF TEST CASES\\nOur synthetic generation of canonical solutions make heavy use of test cases to filter whether each\\ncode is correct or not. The process implicitly assumes that the test cases act as a ground truth verifier\\nthat provides necessary and sufficient conditions for the correctness of each task's functionality.\\nSuch assumptions might not hold if the test cases are not thoroughly written in the original dataset.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 66, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"In fact, false positives of execution-based datasets can typically occur as indicated in several previous work (Li et al., 2022a). Our framework does not aim to inject additional knowledge per each test case but merely acts to translate a task in one language to another, while carrying the information captured in test cases of the original dataset to the corresponding datasets in other languages. Any corrections to the benchmark shall be done upstream in the original dataset, and can easily propagate to the rest of the converted datasets, since the conversion process for prompts and test cases is purely programmatic. The usefulness of the conversion framework lies in the automated conversion into many languages which can be repeatedly done if the test cases in original datasets are updated, or new tasks are added. This helps reduce human effort to perform such manual translation of a dataset in one language to many others.\\n\\nOne step that can be done to improve thoroughness of the test cases is to use the provided canonical solutions in the original dataset to synthetically generate additional test cases, with the hope that additional test cases can provide test coverage for the functionality. However, this proposal also relies heavily on the canonical solution as the ground truth that captures the true functionality of the task, which might not necessarily be true since during the annotation process, annotators might write canonical solutions that are only partially correct but pass the specified test cases. Therefore, we leave this investigation as future work.\"}"}
{"id": "Bo7eeXm6An8", "page_num": 67, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"During the manual review process, we provide the converted programming problem in Java and Javascript to annotators and ask them to check if the problem is correct and clear. Below we categorize the issues identified by annotators, with examples. Almost all of these cases can be attributed to the source dataset we use for conversion. On the other hand, the conversion process itself does not introduce additional errors. For future work, we plan to thoroughly check for errors in the original MBPP. Any changes from there can be easily propagated to the converted datasets due to the automatic conversion.\\n\\n- Natural language statement is ambiguous.\\n\\n```java\\nimport java.io.*\\nimport java.lang.*\\nimport java.util.*\\n\\nclass CountCommon {\\n    public static List<List<Object>> countCommon(List<String> words) {\\n        // Comment: The problem should explicit state to count the 4 most common words.\\n    }\\n}\\n```\\n\\n- Spelling mistake.\\n\\n```java\\n/**\\n * Write a javascript function to count numbers whose 0th and nth bits are set.\\n */\\nfunction countNum(n) {\\n    // Comment: \\\"oth\\\" should be \\\"0th\\\"\\n}\\n```\\n\\n- One or more test cases are wrong.\\n\\n```java\\nimport java.io.*\\nimport java.lang.*\\nimport java.util.*\\n\\nclass FirstRepeatedChar {\\n    public static String firstRepeatedChar(String str) {\\n        // Comment: The last test case is incorrect.\\n    }\\n}\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 68, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Below, we show examples of the samples from the original dataset as well as the converted dataset.\\n\\nTable 11: MBXP Datasets in 10+ Languages. The dataset names are loosely inspired by each language's file extension. For instance, the Scala or Perl dataset is MBSCP or MBPLP due to the file extension being .sc or .pl.\\n\\n| Language | Dataset Name |\\n|----------|-------------|\\n| Python   | MBPP        |\\n| Java     | MBJP        |\\n| JavaScript| MBJSP       |\\n| TypeScript| MBTSP      |\\n| Go       | MBGP        |\\n| C#       | MBCSP       |\\n| PHP      | MBPHP       |\\n| Ruby     | MBRBP       |\\n| Kotlin   | MBKP        |\\n| C++      | MBCPP       |\\n| Perl     | MBPLP       |\\n| Scala    | MBSCP       |\\n| Swift    | MBSWP       |\\n\\nNote that we convert the original MBPP dataset (Austin et al., 2021) which has a slightly different format into HumanEval format (Chen et al., 2021) with function signature and docstring, as shown below. The use of function signature and docstring in the formatted MBPP makes it consistent with the converted datasets in all other languages.\\n\\n```python\\n# --------------------- MBPP/1: PROMPT ---------------------\\ndef min_cost(cost, m, n):\\n    \"\"\"\\n    Write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].\\n    >>> min_cost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2)\\n    8\\n    >>> min_cost([[2, 3, 4], [5, 9, 3], [2, 6, 4]], 2, 2)\\n    12\\n    >>> min_cost([[3, 4, 5], [6, 10, 4], [3, 7, 5]], 2, 2)\\n    \"\"\"\\n# --------------------- CANONICAL SOLUTION ---------------------\\nR = 3\\nC = 3\\n\\ntc = [[0 for x in range(C)] for x in range(R)]\\ntc[0][0] = cost[0][0]\\nfor i in range(1, m+1):\\ntc[i][0] = tc[i-1][0] + cost[i][0]\\nfor j in range(1, n+1):\\ntc[0][j] = tc[0][j-1] + cost[0][j]\\nfor i in range(1, m+1):\\n    for j in range(1, n+1):\\ntc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]\\nreturn tc[m][n]\\n# --------------------- TEST ---------------------\\ndef check(candidate):\\n    assert candidate([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2) == 8\\n    assert candidate([[2, 3, 4], [5, 9, 3], [2, 6, 4]], 2, 2) == 12\\n    assert candidate([[3, 4, 5], [6, 10, 4], [3, 7, 5]], 2, 2) == 16\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 45, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"In this subsection, we provide qualitative examples to illustrate the three types of perturbations applied to the datasets. A successful and a failure MBPP sample completions before and after each type of perturbation are provided based on the code completion results by 672M python model on MBPP dataset. We performed similar perturbations for all the other datasets for robustness evaluation (quantitative results shown in Section J.2).\\n\\n**MBPP Example 1 for Back Translation Paraphrasing**\\n\\n1. [672M_python completion on normal prompt] (passed: True)\\n   ```python\\ndef left_Rotate(n,d):\\n    \\n    \\n    \\n    def left_Rotate(n,d):\\n    \\n    \\\"\\\"\\n    Write a python function to left rotate the bits of a given number.\\n    >>> left_Rotate(16,2)\\n    64\\n    >>> left_Rotate(10,2)\\n    40\\n    >>> left_Rotate(99,3)\\n    792\\n    \\\"\\\"\\n    \\n    return n << d\\n    \\n    ```\\n\\n2. [672M_python completion on perturbed prompt] (passed: False)\\n   ```python\\ndef left_Rotate(n,d):\\n    \\n    def left_Rotate(n,d):\\n    \\n    \\\"\\\"\\n    Write a Python function to rotate the bits of a given number to the left.\\n    >>> left_Rotate(16,2)\\n    64\\n    >>> left_Rotate(10,2)\\n    40\\n    >>> left_Rotate(99,3)\\n    792\\n    \\\"\\\"\\n    \\n    return n >> d | (n & (1 << d))\\n    \\n    ```\\n\\n**MBPP Example 2 for Character Case Changing**\\n\\n1. [672M_python completion on normal prompt] (passed: True)\\n   ```python\\ndef text_match_string(text):\\n    \\n    def text_match_string(text):\\n    \\n    \\\"\\\"\\n    Write a function that matches a word at the beginning of a string.\\n    >>> text_match_string(\\\" python\\\")\\n    'Not matched!'\\n    >>> text_match_string(\\\"python\\\")\\n    'Found a match!'\\n    >>> text_match_string(\\\" lang\\\")\\n    'Not matched!'\\n    \\\"\\\"\\n    \\n    return \\\"Not matched!\\\" if text.startswith(\\\" \\\") else \\\"Found a match!\\\"\\n    \\n    ```\\n\\n2. [672M_python completion on perturbed prompt] (passed: False)\\n   ```python\\ndef text_match_string(text):\\n    \\n    def text_match_string(text):\\n    \\n    \\\"\\\"\\n    Write a function that matches a word at the BeginNing of a strinG.\\n    >>> text_match_string(\\\" python\\\")\\n    'Not matched!'\\n    >>> text_match_string(\\\"python\\\")\\n    'Found a match!'\\n    >>> text_match_string(\\\" lang\\\")\\n    'Not matched!'\\n    \\\"\\\"\\n    \\n    return \\\"Not matched!\\\"\\n    \\n    ```\\n\\n**MBPP Example 3 for Synonym Substitutions**\\n\\n1. [672M_python completion on normal prompt] (passed: True)\\n   ```python\\ndef check_value(dict, n):\\n    \\n    ```\\n\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 46, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Write a function to check if all values are same in a dictionary.\\n\\n```python\\n>>> check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)\\nFalse\\n\\n>>> check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)\\nTrue\\n\\n>>> check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)\\nFalse\\n```\\n\\n```python\\n### Begin of code completion ###\\nfor key in dict:\\n  if dict[key] != n:\\n    return False\\nreturn True\\n### End of code completion ###\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 47, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Assume there are $n$ lines of code in canonical solution, we skip problems with $n < 2$ and randomly mask out $m = \\\\{1, 8\\\\}$ consecutive lines for remaining problems. For each problem, we run multiple times (say, 1 if $n < 5$, 2 if $n < 12$, otherwise 3) to generate variants and remove duplicate masks. We report data statistics in Table 3.\\n\\n| total | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\\n|-------|---|---|---|---|---|---|---|---|\\n| i-MBPP | 1489 | 1 | 922 | 246 | 138 | 69 | 62 | 28 | 23 |\\n| i-MBJP | 1813 | 19 | 805 | 328 | 217 | 172 | 119 | 114 | 39 |\\n| i-MBJSP | 1521 | 38 | 739 | 266 | 159 | 138 | 83 | 71 | 27 |\\n\\nK.2 Evaluation Setup\\n\\nWe evaluate InCoder-6.7B model (Fried et al., 2022) pretrained on 159 GB of code, 52 GB in Python and 107 GB in other 28 languages, and 57 GB of text content from StackOverflow. We do greedy search and report averaged execution accuracy over all problems. We feed a sequence left <Mask:0> right <Mask:0> to the model as prompt, where left denotes the right context and <Mask:0> denotes a sentinel token of Incoder model. We apply two stopping criteria: (1) <EOM> is generated and (2) any token from the predefined list ['class', 'def', '#', 'if'] is generated for Python or braces that close the function scope for Java and Javascript. After that, we match generated tokens with right context and remove duplicated tokens. We compare it against left-right (L-R) baseline where we feed left to the model as prompt and follow the same stopping criteria.\\n\\nK.3 Evaluation Results\\n\\nResults in Table 4 show that right context can significantly boost performance across all languages. We also studied the effect of the number of lines of right context and observed increasing accuracy as we add more lines of right context (in Table 5), which is intuitive since more context is beneficial. Furthermore, qualitative examples (K.4) show that models are able to leverage right context to fill in the blank. In example example 1, given index $j$ and $k$ in the right context, InCoder model can fill in two inner loops L15-L16. Otherwise, it fails to do so. In example 2, given add operator in the right context, the InCoder model can mimic the behavior in L33-L38. Otherwise, model might generate irrelevant operator remove. In example 3, given result $[\\\\text{char}] = 1$ in the right context, InCoder model generate result $[\\\\text{char}] += 1$. Otherwise, the model will replace 1 with countStr[\\\\text{char}] which results in wrong outputs.\\n\\n| dataset | 0 | 1 | 2 | 3 | ALL |\\n|---------|---|---|---|---|-----|\\n| i-MBPP  | 30.1 | 32.1 | 35.6 | 36.4 | 37.07 |\\n\\nK.4 Qualitative Examples for i-MBXP\\n\\nThe example below shows that the model is able to use the right context information and generate appropriate insertion code that are consistent with the right context. In contrast, the left-to-right\"}"}
{"id": "Bo7eeXm6An8", "page_num": 48, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Example 1: Python insertion mode\\n\\n```python\\ndef find_triplet_array(A, arr_size, sum):\\n    \"\"\"\\n    Write a function to find if there is a triplet in the array whose sum is equal to a given value.\\n    >>> find_triplet_array([1, 4, 45, 6, 10, 8], 6, 22)\\n    (4, 10, 8)\\n    >>> find_triplet_array([12, 3, 5, 2, 6, 9], 6, 24)\\n    (12, 3, 9)\\n    >>> find_triplet_array([1, 2, 3, 4, 5], 5, 9)\\n    (1, 3, 5)\\n    \"\"\"\\n    for i in range(0, arr_size-2):\\n        ### begin of insertion ###\\n        for j in range(i+1, arr_size-1):\\n            for k in range(j+1, arr_size):\\n                ### end of insertion ###\\n                if A[i] + A[j] + A[k] == sum:\\n                    return A[i], A[j], A[k]\\n    return True\\n    return False\\n```\\n\\nExample 1: Python left-to-right mode\\n\\n```python\\n### begin of left-right ###\\nif A[i] + A[i+1] + A[i+2] == sum:\\n    return (A[i], A[i+1], A[i+2])\\n### end of left-right ###\\n```\\n\\nExample 2: Java insertion mode\\n\\n```java\\nimport java.io.*;\\nimport java.lang.*;\\nimport java.util.*;\\n\\nclass CountVariable {\\n    // Write a function to iterate over elements repeating each as many times as its count.\\n    // > CountVariable.countVariable(4, 2, 0, -2)\\n    // [\\\"p\\\", \\\"p\\\", \\\"p\\\", \\\"p\\\", \\\"q\\\", \\\"q\\\"]\\n    // > CountVariable.countVariable(0, 1, 2, 3)\\n    // [\\\"q\\\", \\\"r\\\", \\\"r\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\"]\\n    // > CountVariable.countVariable(11, 15, 12, 23)\\n    // [\\\"p\\\", \\\"p\\\", \\\"p\\\", \\\"p\\\", \\\"p\\\", \\\"p\\\", \\\"p\\\", \\\"p\\\", \\\"p\\\", \\\"p\\\", \\\"p\\\", \\\"q\\\", \\\"q\\\", \\\"q\\\", \\\"q\\\", \\\"q\\\", \\\"q\\\", \\\"q\\\", \\\"q\\\", \\\"q\\\", \\\"q\\\", \\\"q\\\", \\\"q\\\", \\\"q\\\", \\\"q\\\", \\\"r\\\", \\\"r\\\", \\\"r\\\", \\\"r\\\", \\\"r\\\", \\\"r\\\", \\\"r\\\", \\\"r\\\", \\\"r\\\", \\\"r\\\", \\\"r\\\", \\\"r\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\", \\\"s\\\"]\\n    public static List<String> countVariable(int a, int b, int c, int d) {\\n        // Write your code here\\n        List<String> finalResult = new ArrayList<>();\\n        List<String> countableList = new ArrayList<>();\\n        countableList.add(\\\"p\\\");\\n        countableList.add(\\\"q\\\");\\n        countableList.add(\\\"r\\\");\\n        countableList.add(\\\"s\\\");\\n\\n        int countFor = a;\\n        for (int index = 0; index < countFor; index++) {\\n            finalResult.add(countableList.get(0));\\n        }\\n        ### begin of insertion ###\\n        countFor = b;\\n        for (int index = 0; index < countFor; index++) {\\n            finalResult.add(countableList.get(1));\\n        }\\n        ### end of insertion ###\\n        countFor = c;\\n        for (int index = 0; index < countFor; index++) {\\n            finalResult.add(countableList.get(2));\\n        }\\n        ### begin of insertion ###\\n        countFor = d;\\n        for (int index = 0; index < countFor; index++) {\\n            finalResult.add(countableList.get(3));\\n        }\\n        ### end of insertion ###\\n        return finalResult;\\n    }\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 73, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"// --------------------- TEST ---------------------\\n\\nfunction compare($x, $y) {\\n    return $x == $y;\\n}\\n\\n$x = minCost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2);\\nif (!compare($x, 8)) {\\n    throw new Exception(\\\"Error at 1th assert statement.\\\");\\n}\\n\\n$x = minCost([[2, 3, 4], [5, 9, 3], [2, 6, 4]], 2, 2);\\nif (!compare($x, 12)) {\\n    throw new Exception(\\\"Error at 2th assert statement.\\\");\\n}\\n\\n$x = minCost([[3, 4, 5], [6, 10, 4], [3, 7, 5]], 2, 2);\\nif (!compare($x, 16)) {\\n    throw new Exception(\\\"Error at 3th assert statement.\\\");\\n}\\n\\n# --------------------- COMPLETION (model generated) ---------------------\\n\\ndef min_cost(cost, m, n):\\n    if cost[m][n] == 0:\\n        return 0\\n    if m == 0 and n == 0:\\n        return cost[m][n]\\n    if m == 0:\\n        return cost[m][n] + min_cost(cost, m, n - 1)\\n    if n == 0:\\n        return cost[m][n] + min_cost(cost, m - 1, n)\\n    return cost[m][n] + min(min_cost(cost, m - 1, n), min_cost(cost, m, n - 1))\\n\\n# --------------------- TEST ---------------------\\nx = min_cost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2)\\nif x != 8:\\n    raise StandardError, \\\"Error at test case 1\\\"\\n\\nx = min_cost([[2, 3, 4], [5, 9, 3], [2, 6, 4]], 2, 2)\\nif x != 12:\\n    raise StandardError, \\\"Error at test case 2\\\"\\n\\nx = min_cost([[3, 4, 5], [6, 10, 4], [3, 7, 5]], 2, 2)\\nif x != 16:\\n    raise StandardError, \\\"Error at test case 3\\\"\"}"}
{"id": "Bo7eeXm6An8", "page_num": 74, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"```cpp\\nvar dp = Array(1).fill(0).map {\\n  Array(1).fill(0)\\n}\\n\\ndp[0][0] = cost[0][0]\\nfor (i in 0 until m) {\\n  for (j in 0 until n) {\\n    if (i == 0 || j == 0) {\\n      dp[i + 1][j + 1] = cost[i][j]\\n    } else {\\n      dp[i + 1][j + 1] = cost[i][j] + min(dp[i][j], dp[i][j + 1], dp[i + 1][j])\\n    }\\n  }\\n}\\nreturn dp[m][n]\\n```\\n\\n```\\n// --------------------- MBCPP/1: PROMPT ---------------------\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n/**\\n* Write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[]\\n* > minCost(vector<vector<int>>{{1, 2, 3}, {4, 8, 2}, {1, 5, 3}}, 2, 2)\\n* 8\\n* > minCost(vector<vector<int>>{{2, 3, 4}, {5, 9, 3}, {2, 6, 4}}, 2, 2)\\n* 12\\n* > minCost(vector<vector<int>>{{3, 4, 5}, {6, 10, 4}, {3, 7, 5}}, 2, 2)\\n* 16\\n*/\\nint minCost(vector<vector<int>> cost, int m, int n) {\\n  vector<int> dp(m + 1, n + 1);\\n  dp[0][0] = 0;\\n  for (int i = 1; i <= m; i++) {\\n    dp[i][0] = dp[i - 1][0] + cost[i - 1][0];\\n  }\\n  for (int j = 1; j <= n; j++) {\\n    dp[0][j] = dp[0][j - 1] + cost[0][j - 1];\\n  }\\n  for (int i = 1; i <= m; i++) {\\n    for (int j = 1; j <= n; j++) {\\n      dp[i][j] = cost[i - 1][j - 1] + Math.min(dp[i - 1][j], dp[i][j - 1]);\\n    }\\n  }\\n  return dp[m][n];\\n}\\n```\"}"}
{"id": "Bo7eeXm6An8", "page_num": 75, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"// --------------------- TEST ---------------------\\n\\ntemplate <typename T> bool compare(T a, T b){\\n    return a == b;\\n}\\n\\nint main(int argc, char* argv[]){\\n    int x0 = minCost(vector<vector<int>>{{1, 2, 3}, {4, 8, 2}, {1, 5, 3}}, 2, 2);\\n    if (!(compare(x0, 8))) {\\n        throw runtime_error(\\\"Exception -- test case 0 did not pass.\\\");\\n    }\\n\\n    int x1 = minCost(vector<vector<int>>{{2, 3, 4}, {5, 9, 3}, {2, 6, 4}}, 2, 2);\\n    if (!(compare(x1, 12))) {\\n        throw runtime_error(\\\"Exception -- test case 1 did not pass.\\\");\\n    }\\n\\n    int x2 = minCost(vector<vector<int>>{{3, 4, 5}, {6, 10, 4}, {3, 7, 5}}, 2, 2);\\n    if (!(compare(x2, 16))) {\\n        throw runtime_error(\\\"Exception -- test case 2 did not pass.\\\");\\n    }\\n\\n    return 0;\\n}\\n\\nsub min_cost\\n{\\n    my ($cost, $m, $n) = @_;  \\n\\n    # --------------------- COMPLETION (model generated) ---------------------\\n    my $min = 0;\\n    my $path = 0;\\n    my $i = 0;\\n    my $j = 0;\\n    my $min_path = 0;\\n    my $min_i = 0;\\n    my $min_j = 0;\\n\\n    while ($i < $m and $j < $n) {\\n        if ($cost[$i][$j] < $min) {\\n            $min = $cost[$i][$j];\\n            $min_i = $i;\\n            $min_j = $j;\\n        }\\n        if ($i < $m - 1) {\\n            $i += 1;\\n        } else {\\n            $i = 0;\\n            $j += 1;\\n        }\\n    }\\n\\n    $path = $min_i + 1;\\n}\\n\\nuse Data::Compare;\\n\\nmy $arg00 = [[1, 2, 3], [4, 8, 2], [1, 5, 3]];\\nmy $arg01 = 2;\\nmy $arg02 = 2;\\nmy $x0 = min_cost($arg00, $arg01, $arg02);\\nmy $v0 = 8;\\nunless(Compare($x0, $v0)) {\\n    die \\\"Exception -- test case 0 did not pass.\\\";\\n}\\n\\nmy $arg10 = [[2, 3, 4], [5, 9, 3], [2, 6, 4]];\\nmy $arg11 = 2;\\nmy $arg12 = 2;\\nmy $x1 = min_cost($arg10, $arg11, $arg12);\\nmy $v1 = 12;\\nunless(Compare($x1, $v1)) {\\n    die \\\"Exception -- test case 1 did not pass.\\\";\\n}\\n\\nmy $arg20 = [[3, 4, 5], [6, 10, 4], [3, 7, 5]];\\nmy $arg21 = 2;\\nmy $arg22 = 2;\\nmy $x2 = min_cost($arg20, $arg21, $arg22);\\nmy $v2 = 16;\\nunless(Compare($x2, $v2)) {\\n    die \\\"Exception -- test case 2 did not pass.\\\";\\n}\"}"}
{"id": "Bo7eeXm6An8", "page_num": 76, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"You are an expert Scala programmer, and here is your task.\\n\\nWrite a function to find the minimum cost path to reach \\\\((m, n)\\\\) from \\\\((0, 0)\\\\) for the given cost matrix \\\\(\\\\text{cost}[][]\\\\) and a position \\\\((m, n)\\\\) in \\\\(\\\\text{cost}[][]\\\\).\\n\\n\\\\[\\n\\\\begin{align*}\\n\\\\text{minCost}(\\\\text{List(List(1, 2, 3), List(4, 8, 2), List(1, 5, 3))), 2, 2) & \\\\quad 8 \\\\\\\\\\n\\\\text{minCost}(\\\\text{List(List(2, 3, 4), List(5, 9, 3), List(2, 6, 4))), 2, 2) & \\\\quad 12 \\\\\\\\\\n\\\\text{minCost}(\\\\text{List(List(3, 4, 5), List(6, 10, 4), List(3, 7, 5))), 2, 2) & \\\\quad 16\\n\\\\end{align*}\\n\\\\]\\n\\n\\\\[\\n\\\\begin{align*}\\n\\\\text{def minCost(cost : List[List[Int]], m : Int, n : Int) : Int} & \\\\quad = \\\\\\\\\\n\\\\text{// --------------------- COMPLETION (model generated) ---------------------} & \\\\\\\\\\n\\\\text{val dp = Array(m + 1, n + 1)} & \\\\\\\\\\n\\\\text{dp(0, 0) = 0} & \\\\\\\\\\n\\\\text{for (i <- 0 until m) } & \\\\\\\\\\n\\\\text{for (j <- 0 until n) } & \\\\\\\\\\n\\\\text{if (i == 0 && j == 0)} & \\\\text{continue} & \\\\\\\\\\n\\\\text{if (i == 0)} & \\\\text{dp(i, j) = cost(i, j)} & \\\\\\\\\\n\\\\text{else if (j == 0)} & \\\\text{dp(i, j) = dp(i - 1, j) + cost(i, j)} & \\\\\\\\\\n\\\\text{else} & \\\\text{dp(i, j) = min(dp(i - 1, j), dp(i, j - 1)) + cost(i, j)} & \\\\\\\\\\n\\\\text{println(dp(m, n))} & \\\\\\\\\\n\\\\text{// --------------------- TEST ---------------------} & \\\\\\\\\\n\\\\text{var arg00 : List[List[Int]] = List(List(1, 2, 3), List(4, 8, 2), List(1, 5, 3))} & \\\\\\\\\\n\\\\text{var arg01 : Int = 2} & \\\\\\\\\\n\\\\text{var arg02 : Int = 2} & \\\\\\\\\\n\\\\text{var x0 : Int = minCost(arg00, arg01, arg02)} & \\\\\\\\\\n\\\\text{var v0 : Int = 8} & \\\\\\\\\\n\\\\text{assert(x0 == v0, \"Exception -- test case 0 did not pass. x0 = \" + x0)} & \\\\\\\\\\n\\\\text{\\\\ldots} & \\\\\\\\\\n\\\\text{var arg10 : List[List[Int]] = List(List(2, 3, 4), List(5, 9, 3), List(2, 6, 4))} & \\\\\\\\\\n\\\\text{var arg11 : Int = 2} & \\\\\\\\\\n\\\\text{var arg12 : Int = 2} & \\\\\\\\\\n\\\\text{var x1 : Int = minCost(arg10, arg11, arg12)} & \\\\\\\\\\n\\\\text{var v1 : Int = 12} & \\\\\\\\\\n\\\\text{assert(x1 == v1, \"Exception -- test case 1 did not pass. x1 = \" + x1)} & \\\\\\\\\\n\\\\text{\\\\ldots} & \\\\\\\\\\n\\\\text{var arg20 : List[List[Int]] = List(List(3, 4, 5), List(6, 10, 4), List(3, 7, 5))} & \\\\\\\\\\n\\\\text{var arg21 : Int = 2} & \\\\\\\\\\n\\\\text{var arg22 : Int = 2} & \\\\\\\\\\n\\\\text{var x2 : Int = minCost(arg20, arg21, arg22)} & \\\\\\\\\\n\\\\text{var v2 : Int = 16} & \\\\\\\\\\n\\\\text{assert(x2 == v2, \"Exception -- test case 2 did not pass. x2 = \" + x2)} & \\\\\\\\\\n\\\\text{\\\\ldots}\\n\\\\end{align*}\\n\\\\]\"}"}
{"id": "Bo7eeXm6An8", "page_num": 57, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"| Model Family | Model Size | Python | Java | JavaScript | Kotlin | Ruby | PHP |\\n|--------------|------------|--------|------|------------|--------|------|-----|\\n| **BLOOM**    | 350M       | 1.54   | 3.21 | 3.21       | 0.83   | 0.00 | 2.80|\\n|              | 760M       | 4.52   | 4.76 | 4.66       | 0.83   | 0.00 | 5.90|\\n|              | 1.3B       | 5.34   | 4.66 | 5.49       | 2.07   | 0.00 | 6.94|\\n|              | 2.5B       | 6.88   | 6.83 | 10.14      | 4.66   | 0.00 | 11.59|\\n|              | 6.3B       | 6.98   | 7.76 | 7.35       | 6.21   | 0.00 | 6.94|\\n| **OPT**      | 1.3B       | 0.10   | 0.00 | 0.83       | 0.52   | 0.00 | 0.41|\\n|              | 2.7B       | 2.05   | 0.00 | 1.14       | 0.93   | 0.00 | 0.31|\\n|              | 6.7B       | 2.05   | 1.97 | 1.35       | 1.55   | 0.00 | 1.66|\\n|              | 13B        | 1.35   | 1.35 | 1.76       | 2.17   | 0.00 | 0.72|\\n|              | 30B        | 1.64   | 1.45 | 2.69       | 1.45   | 0.00 | 1.55|\\n|              | 66B        | 3.70   | 2.28 | 3.73       | 1.76   | 0.00 | 2.17|\\n| **CodeGen-multi** | 350M | 7.90 | 8.17 | 7.45 | 1.14 | 1.04 | 0.80 |\\n|              | 2B         | 18.78  | 19.56 | 17.70 | 3.93 | 4.76 | 2.90 |\\n|              | 6B         | 22.48  | 21.74 | 22.87 | 4.55 | 4.24 | 5.90 |\\n|              | 16B        | 24.22  | 28.05 | 26.29 | 7.04 | 3.52 | 10.35 |\\n| **CodeGen-mono** | 350M | 18.37 | 1.86 | 6.00 | 1.04 | 1.55 | 1.35 |\\n|              | 2B         | 31.72  | 16.66 | 22.04 | 3.21 | 2.90 | 9.21 |\\n|              | 6B         | 37.16  | 19.77 | 27.74 | 3.83 | 1.66 | 10.14 |\\n|              | 16B        | 40.55  | 26.81 | 32.81 | 6.63 | 5.90 | 18.94 |\\n| **Ours-multi** | 125M | 6.37 | 5.59 | 6.94 | 1.04 | 0.21 | 0.52 |\\n|              | 672M       | 19.71  | 17.29 | 21.43 | 4.55 | 1.86 | 7.76 |\\n|              | 2.7B       | 27.00  | 22.46 | 27.23 | 9.73 | 3.93 | 11.28 |\\n|              | 13B        | 35.32  | 30.33 | 36.13 | 14.18 | 6.73 | 18.84 |\\n| **Ours-mono** | 125M | 8.11 | 4.35 | 7.45 | - | - | - |\\n|              | 672M       | 19.82  | 11.39 | 14.39 | - | - | - |\\n|              | 2.7B       | 24.13  | 15.32 | 19.67 | - | - | - |\\n|              | 13B        | 33.57  | 19.77 | 23.60 | - | - | - |\\n\\n| Model Family | Model Size | go | c++ | c# | Typescript | Perl | swift | scala |\\n|--------------|------------|----|-----|----|------------|------|-------|-------|\\n| **OPT**      | 1.3B       | 0.11 | 0.35 | 0.00 | 0.00 | 0.10 | 0.52 |\\n|              | 2.7B       | 0.43 | 0.47 | 0.00 | 0.00 | 0.83 | 0.21 |\\n|              | 6.7B       | 1.28 | 1.53 | 3.31 | 3.31 | 0.52 | 0.93 |\\n|              | 13B        | 1.7  | 1.06 | 3.31 | 3.31 | 0.31 | 1.97 |\\n| **Bloom**    | 1.1B       | 3.3  | 5.07 | 0.31 | 0.31 | 0.21 | 0.62 |\\n|              | 1.7B       | 4.15 | 6.01 | 0.31 | 0.31 | 0.10 | 2.07 |\\n|              | 3B         | 6.28 | 8.61 | 10.95 | 10.95 | 1.55 | 4.24 |\\n|              | 7.1B       | 7.77 | 15.09 | 13.84 | 13.84 | 3.31 | 5.07 |\\n| **CodeGen-Mono** | 350M | 1.38 | 5.19 | 7.13 | 7.13 | 0.10 | 1.14 |\\n|              | 2B         | 5.11 | 17.69 | 20.76 | 20.76 | 0.83 | 2.59 |\\n|              | 6B         | 3.83 | 17.33 | 19.21 | 19.21 | 1.24 | 4.14 |\\n|              | 16B        | 10.54 | 29.13 | 29.96 | 29.96 | 2.48 | 4.55 |\\n| **CodeGen-Multi** | 350M | 6.39 | 9.32 | 7.13 | 7.13 | 0.10 | 1.66 |\\n|              | 2B         | 12.03 | 18.04 | 17.25 | 17.25 | 2.07 | 2.17 |\\n|              | 6B         | 11.61 | 17.69 | 17.46 | 17.46 | 2.07 | 2.80 |\\n|              | 16B        | 15.23 | 26.06 | 21.49 | 21.49 | 7.14 | 3.62 |\\n| **Ours**     | 125M       | 0.64 | 1.53 | 0.62 | 6.61 | 0.10 | 0.41 |\\n|              | 672M       | 0.00 | 7.67 | 4.34 | 19.83 | 1.35 | 1.76 |\\n|              | 2B         | 0.00 | 15.68 | 8.16 | 26.14 | 0.93 | 3.11 |\\n|              | 13B        | 5.22 | 18.75 | 10.54 | 32.85 | 4.14 | 6.52 |\"}"}
{"id": "Bo7eeXm6An8", "page_num": 58, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 7: Evaluating pass execution accuracy of publicly available models on Hu-\\nmaneval using greedy decoding\\n\\n| Model Family | Model Size | Python | Java | JavaScript | Kotlin | Ruby | PHP | Perl | Swift | Scala |\\n|--------------|------------|--------|------|-----------|--------|------|-----|------|-------|-------|\\n| Bloom        | 1.1B       | 3.66   | 3.73 | 2.48      | 0.62   | 0.00 | 2.48| 0.62 | 0.62  | 8.07  |\\n|              | 1.7B       | 3.66   | 1.86 | 4.97      | 0.62   | 0.00 | 4.35| 0.00 | 0.62  | 24.22 |\\n|              | 3B         | 7.93   | 4.97 | 5.59      | 2.48   | 0.00 | 4.97| 0.62 | 1.24  | 29.19 |\\n|              | 7.1B       | 7.93   | 8.07 | 6.21      | 0.62   | 0.00 | 3.11| 0.62 | 2.48  | 34.16 |\\n| OPT          | 1.3B       | 0.00   | 0.00 | 0.62      | 0.62   | 0.00 | 0.00| 0.62 | 0.00  | 0.00  |\\n|              | 2.7B       | 0.00   | 0.00 | 0.00      | 0.00   | 0.00 | 1.86| 0.00 | 0.00  | 0.00  |\\n|              | 6.7B       | 0.61   | 0.62 | 0.62      | 0.62   | 0.00 | 1.24| 0.00 | 0.62  | 9.32  |\\n|              | 13B        | 0.61   | 0.62 | 2.48      | 0.62   | 0.00 | 1.24| 0.00 | 0.62  | 12.42 |\\n| Codegen-Mono | 350M       | 10.37  | 1.24 | 3.11      | 0.00   | 0.00 | 0.62| 0.00 | 0.62  | 5.59  |\\n|              | 2B         | 20.73  | 4.97 | 10.56     | 1.24   | 0.00 | 3.73| 1.24 | 0.62  | 8.07  |\\n|              | 6B         | 19.51  | 8.70 | 11.18     | 1.24   | 0.00 | 4.35| 1.24 | 0.62  | 6.21  |\\n|              | 16B        | 22.56  | 17.39| 12.42     | 0.62   | 0.00 | 11.80| 2.48 | 0.62  | 16.15 |\\n| Codegen-Multi | 350M     | 7.32   | 4.97 | 4.35      | 0.62   | 0.00 | 0.62| 0.00 | 0.62  | 1.86  |\\n|              | 2B         | 10.98  | 11.18| 6.83      | 3.11   | 0.00 | 1.86| 1.24 | 0.62  | 21.12 |\\n|              | 6B         | 15.24  | 10.56| 11.80     | 3.11   | 0.62 | 3.73| 1.24 | 0.62  | 10.56 |\\n|              | 16B        | 17.07  | 16.15| 16.15     | 1.86   | 0.00 | 5.59| 3.11 | 0.62  | 16.15 |\\n| Ours         | 125M       | 7.32   | 3.73 | 4.35      | 1.24   | 0.00 | 0.62| 0.00 | 0.62  | 1.86  |\\n|              | 672M       | 17.07  | 9.32 | 13.04     | 1.86   | 0.00 | 1.86| 1.24 | 0.62  | 1.24  |\\n|              | 2B         | 19.51  | 14.29| 14.91     | 1.86   | 0.00 | 4.97| 0.00 | 0.62  | 1.86  |\\n|              | 13B        | 22.56  | 22.36| 20.50     | 8.07   | 0.00 | 11.80| 3.11 | 0.62  | 4.35  |\\n\\nTable 8: Evaluating pass execution accuracy of publicly available models on MBXP with few-shot prompting using greedy decoding\\n\\n| Model Family | Model Size | Python | Java | JavaScript | Kotlin | Ruby | PHP |\\n|--------------|------------|--------|------|-----------|--------|------|-----|\\n| Codegen-multi | 350M     | 7.80   | 10.56| 8.28       | 2.28   | 4.24 | 3.2 |\\n|              | 2B         | 20.02  | 22.15| 21.43      | 7.76   | 12.73| 8.8 |\\n|              | 6B         | 23.10  | 24.53| 24.84      | 10.66  | 9.01 | 13.87|\\n|              | 16B        | 26.69  | 29.92| 28.26      | 11.59  | 16.46| 17.60|\\n| Codegen-mono | 350M     | 17.04  | 3.73 | 5.18       | 2.69   | 4.35 | 2.69|\\n|              | 2B         | 28.95  | 15.42| 15.53      | 5.69   | 8.07 | 11.70|\\n|              | 6B         | 39.53  | 21.43| 19.15      | 7.14   | 10.35| 16.4 |\\n|              | 16B        | 46.41  | 27.64| 26.50      | 11.08  | 15.11| 20.2 |\\n| Ours-multi   | 125M       | 6.06   | 7.14 | 6.94       | 2.90   | 2.59 | 0.93|\\n|              | 672M       | 19.40  | 16.56| 19.46      | 5.90   | 5.90 | 8.90|\\n|              | 2.7B       | 24.23  | 24.12| 27.95      | 11.08  | 9.42 | 14.29|\\n|              | 13B        | 31.93  | 30.75| 37.37      | 15.11  | 12.53| 20.19|\\n| Ours-mono    | 125M       | 8.93   | 5.38 | 7.35       | -      | -    | -   |\\n|              | 672M       | 18.89  | 10.56| 16.87      | -      | -    | -   |\\n|              | 2.7B       | 21.77  | 15.11| 21.43      | -      | -    | -   |\\n|              | 13B        | 31.31  | 21.22| 25.16      | -      | -    | -   |\\n\\n| Model Family | Model Size | Go   | C++ | C#  | Typescript | Perl | Swift | Scala |\\n|--------------|------------|------|-----|-----|------------|------|-------|-------|\\n| Codegen-Mono | 350M       | 1.17 | 4.25| 4.03| 3.93       | 1.45 | 2.90  | 28.78 |\\n|              | 2B         | 5.86 | 19.34| 8.99| 16.94      | 4.97 | 4.45  | 26.29 |\\n|              | 6B         | 6.50 | 19.69| 12.71| 18.08      | 3.42 | 4.24  | 26.50 |\\n|              | 16B        | 13.84| 32.31| 16.63| 28.20      | 8.18 | 5.49  | 28.67 |\\n| Codegen-Multi | 350M     | 6.39 | 9.91 | 5.68| 9.19       | 1.66 | 3.62  | 30.43 |\\n|              | 2B         | 14.59| 19.46| 11.05| 18.80      | 4.24 | 3.83  | 37.68 |\\n|              | 6B         | 12.78| 21.58| 13.43| 19.83      | 6.00 | 4.55  | 28.26 |\\n|              | 16B        | 20.77| 29.36| 17.46| 24.38      | 8.49 | 4.55  | 28.57 |\"}"}
{"id": "Bo7eeXm6An8", "page_num": 59, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"| Table 9: Evaluating pass execution accuracy of publicly available models on HumanEval with few-shot prompting using greedy decoding |\\n|--------------------------------------------------|\\n| **Model Family** | **Model Size** | **Java** | **JS** | **Kotlin** | **Ruby** | **PHP** | **Swift** | **Scala** | **Mean** |\\n|--------------------|----------------|----------|--------|------------|----------|--------|----------|----------|---------|\\n| **CodeGen-Mono**   | 350M           | 12.80    | 3.11   | 2.48       | 1.86     | 2.48   | 1.24     | 0.62     | 19.25   |\\n|                    | 2B             | 21.95    | 8.07   | 10.56      | 3.11     | 3.11   | 6.83     | 1.86     | 15.53   |\\n|                    | 6B             | 23.17    | 8.07   | 8.70       | 3.11     | 2.48   | 7.45     | 1.24     | 13.66   |\\n|                    | 16B            | 28.66    | 16.77  | 11.18      | 4.97     | 5.59   | 9.94     | 3.73     | 18.63   |\\n| **CodeGen-Multi**  | 350M           | 7.93     | 4.97   | 4.35       | 1.86     | 1.24   | 1.24     | 1.24     | 22.98   |\\n|                    | 2B             | 13.41    | 10.56  | 12.42      | 4.35     | 7.45   | 4.35     | 0.62     | 24.22   |\\n|                    | 6B             | 14.02    | 12.42  | 11.80      | 3.11     | 4.97   | 3.11     | 3.73     | 13.04   |\\n|                    | 16B            | 20.12    | 17.39  | 13.66      | 4.35     | 8.07   | 9.94     | 5.59     | 16.15   |\\n| **Ours**           | 125M           | 7.32     | 4.35   | 5.59       | 1.24     | 0.62   | 1.86     | 0.00     | 0.62    |\\n|                    | 672M           | 17.07    | 8.70   | 11.18      | 3.73     | 2.48   | 4.97     | 1.24     | 1.86    |\\n|                    | 2B             | 19.51    | 14.29  | 14.91      | 4.97     | 3.11   | 8.07     | 2.48     | 3.11    |\\n|                    | 13B            | 22.56    | 18.01  | 26.09      | 4.97     | 6.21   | 10.56    | 3.72     | 5.59    |\\n\\n| Table 10: Evaluating pass execution accuracy of publicly available models on MBXP in translation mode (Python as a source language). |\\n|--------------------------------------------------|\\n| **Model Family** | **Model Size** | **Java** | **JavaScript** | **Kotlin** | **Ruby** | **PHP** | **Go** |\\n|--------------------|----------------|----------|----------------|------------|----------|--------|--------|\\n| **CodeGen-Mono**   | 350M           | 3.83     | 10.24         | 3.11       | 4.66     | 2.07   | 3.94   |\\n|                    | 2B             | 22.57    | 22.87         | 5.18       | 4.35     | 21.74  | 8.41   |\\n|                    | 6B             | 30.95    | 35.92         | 8.07       | 6.63     | 30.23  | 11.93  |\\n|                    | 16B            | 43.48    | 54.14         | 10.56      | 4.55     | 36.85  | 22.36  |\\n| **CodeGen-Multi**  | 350M           | 7.35     | 9.93          | 1.55       | 3.83     | 1.76   | 7.14   |\\n|                    | 2B             | 23.19    | 36.12         | 3.42       | 4.76     | 22.46  | 16.83  |\\n|                    | 6B             | 38.41    | 37.99         | 6.83       | 4.66     | 27.74  | 20.77  |\\n|                    | 16B            | 44.82    | 50.10         | 8.28       | 5.18     | 40.17  | 26.41  |\\n| **Ours**           | 125M           | 7.04     | 9.52          | 3.21       | 3.73     | 0.41   | 2.77   |\\n|                    | 672M           | 22.98    | 24.53         | 7.97       | 5.07     | 16.15  | 6.28   |\\n|                    | 2B             | 30.75    | 28.47         | 10.56      | 6.52     | 33.02  | 6.92   |\\n|                    | 13B            | 41.93    | 37.06         | 14.80      | 6.73     | 37.06  | 8.52   |\\n\\n| **Model Family** | **Model Size** | **C++** | **C#** | **Typescript** | **Perl** | **Swift** | **Scala** |\\n|--------------------|----------------|--------|-------|---------------|----------|----------|----------|\\n| **CodeGen-Mono**   | 350M           | 8.37   | 3.93  | 11.78         | 0.21     | 1.24     | 0.00     |\\n|                    | 2B             | 30.19  | 16.01 | 31.51         | 4.14     | 6.83     | 0.00     |\\n|                    | 6B             | 35.14  | 23.45 | 36.67         | 7.56     | 7.04     | 0.10     |\\n|                    | 16B            | 49.65  | 36.67 | 0.41          | 7.04     | 10.97    | 0.10     |\\n| **CodeGen-Multi**  | 350M           | 10.85  | 1.86  | 5.89          | 0.00     | 0.83     | 0.00     |\\n|                    | 2B             | 23.00  | 6.71  | 10.54         | 5.18     | 3.62     | 0.00     |\\n|                    | 6B             | 40.45  | 22.52 | 26.96         | 8.39     | 6.21     | 0.10     |\\n|                    | 16B            | 46.58  | 28.51 | 5.89          | 14.18    | 8.18     | 0.10     |\\n| **Ours**           | 125M           | 1.06   | 1.76  | 10.54         | 0.52     | 1.76     | 0.00     |\\n|                    | 672M           | 16.51  | 10.43 | 19.11         | 4.66     | 3.93     | 0.10     |\\n|                    | 2B             | 28.18  | 13.33 | 24.90         | 5.07     | 6.52     | 0.10     |\\n|                    | 13B            | 33.14  | 25.52 | 44.52         | 10.56    | 8.49     | 0.10     |\"}"}
{"id": "Bo7eeXm6An8", "page_num": 60, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"We train using 210B tokens for mono-lingual models, and 630B tokens for multi-lingual models with 210B tokens from each language. Across all models, we use max sequence length of 2048, and use larger batch size for larger models, while reducing max steps accordingly to train all models with same amount of per-language tokens. For example, for 13B, we use batch size of 1024 and max steps of 100,000 with 2048 sequence length, resulting in total 210B training tokens for each language. For multi-lingual models, there are three languages and we increase max steps by three times to 630B tokens. We use AdamW optimizer (Loshchilov & Hutter, 2018) with $\\\\beta_1 = 0.9$, $\\\\beta_2 = 0.95$, and $\\\\epsilon = 10^{-8}$. We use warm up steps of 2000 steps with cosine annealing after peak learning rate, and the minimum learning rate being 10% of corresponding peak learning rate, weight decay of 0.01, and gradient clipping of 1.0. We rescale the initialization weight standard deviation for larger models following (Shoeybi et al., 2019) for better training stability. Our training pipeline is based on PyTorch Lightning and we use bfloat16 (Kalamkar et al., 2019) and DeepSpeed (Rasley et al., 2020) for training optimization. We randomly split 0.1% data as validation set. The validation loss curve for different sizes of multi-lingual and monolingual models are shown in Fig. 24.\\n\\nFigure 24: Validation loss curves for 128M, 672M, 2.7B and 13B multi-lingual and mono-lingual models.\\n\\nObservations on validation losses versus performance\\n\\nWe plot the validation loss of multi/mono-lingual models on each programming languages in Figure 25. We can see that the trend of validation loss roughly follows log-linear relationship with respect to model sizes. By comparing the validation loss curves between multi-lingual models and mono-lingual models, we can see that mono-lingual models consistently achieves lower loss than multi-lingual ones.\"}"}

{"id": "1vCnDyQkjg", "page_num": 5, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Instruction: I want to play video games for a while, then go to sleep.\\n\\n[Start of Background Information]\\nThe room has objects: [bed, chair, table, laptop].\\nThe [Object: laptop] is upon the [Object: table].\\nThe [Object: bed] has parts: [pillow, mattress].\\nThe human has joints: [pelvis, left hip, left knee, left foot].\\n\\n[End of Background Information]\\n\\nGiven the instruction and background information, generate 1 task plan according to the following rules and examples.\\n\\n1. Each task plan should be composite into detailed steps.\\n2. Each step should contain meaningful joint-part pairs.\\n\\nStep 1: Get close to the chair.\\nStep 2: Sit on the chair.\\nPair 1: {chair, seat surface, pelvis, contact, up}.\\nStep 3: Play video games.\\n\\nWe build the controller upon AMP (Peng et al., 2021). AMP is a goal-conditioned reinforcement learning framework incorporated with an adversarial discriminator to model the motion prior. Its objective is defined by a reward function \\\\( R(s_t, a_t, s_{t+1}, G) = w_G R_G(s_t, a_t, s_{t+1}, G) + w_S R_S(s_t, s_{t+1}) \\\\).\\n\\nThe task reward \\\\( R_G \\\\) defines the high-level goal \\\\( G \\\\) an agent should achieve. The style reward \\\\( R_S \\\\) encourages the agent to imitate low-level behaviors from motion datasets. \\\\( w_G \\\\) and \\\\( w_S \\\\) are empirical weights of \\\\( R_G \\\\) and \\\\( R_S \\\\), respectively.\\n\\n\\\\( s_t, a_t, s_{t+1} \\\\) are the state at time \\\\( t \\\\), the action at time \\\\( t \\\\), the state at time \\\\( t+1 \\\\), respectively. The style reward \\\\( R_S \\\\) is modeled using an adversarial discriminator \\\\( D \\\\), which is trained according to the objective:\\n\\n\\\\[\\n\\\\begin{align*}\\n&\\\\text{arg min}_D -E_{d_M(s_t, s_{t+1})} \\\\log D(s_A(s_t, a_t), s_{A(t+1)}) \\\\\\\\\\n&-E_{d_\\\\pi(s_t, s_{t+1})} \\\\log 1 - D(s_A(s_t, a_t), s_{A(t+1)}) + w_{gp} E_{d_M(s_t, s_{t+1})} \\\\nabla \\\\phi D(\\\\phi) = (s_A(s_t, a_t), s_{A(t+1)})^2,\\n\\\\end{align*}\\n\\\\]\\n\\nwhere \\\\( d_M(s_t, s_{t+1}) \\\\) and \\\\( d_\\\\pi(s_t, s_{t+1}) \\\\) denote the likelihood of a state transition from \\\\( s_t \\\\) to \\\\( s_{t+1} \\\\) in the dataset \\\\( M \\\\) and the policy \\\\( \\\\pi \\\\) respectively.\\n\\nWe adopt the key design of motion discriminator for realistic motion modeling. In our implementation, we feed 10 adjacent frames together into the discriminator to assess the style. Our main contribution to the controller parts lies in unifying different tasks. As shown in the left part of Fig. 4 (a), AMP (Peng et al., 2021), as well as most of the previous methods (Juravsky et al., 2022; Zhao et al., 2023), design specified task observations, task objectives, and hyperparameters to train task-specified control policy. In contrast, we unify different tasks into Chains of Contacts and devise a TaskParser to process the uniform representation.\\n\\nTaskParser. As the core of the Unified Controller, the TaskParser is responsible for formulating CoC into uniform task observations and task objectives. It also sequentially fetches steps for multi-round interaction execution.\\n\\nGiven one specific contacting pair \\\\( \\\\{o, p, j, c, d\\\\} \\\\), for task observation, the TaskParser collects the corresponding position \\\\( v_j \\\\in \\\\mathbb{R}^3 \\\\) of the joint \\\\( j \\\\), and point clouds \\\\( v_p \\\\in \\\\mathbb{R}^{m \\\\times 3} \\\\) of the object part \\\\( p \\\\) from the simulation environment, where \\\\( m \\\\) is the point number of point clouds. It selects the nearest point \\\\( v_{np} \\\\in v_p \\\\) from \\\\( v_p \\\\) to \\\\( v_j \\\\) as the target point for contact. We formulate task observation of the single pair as \\\\( \\\\{v_{np} - v_j, c, d\\\\} \\\\). For the task observation in the network, we map \\\\( c \\\\) and \\\\( d \\\\) into digital numbers, but we still use the same notation for simplicity. Combining these contact pairs together, we get the uniform task observations \\\\( s_U = \\\\{\\\\{v_{np1} - v_j1, c1, d1\\\\}, \\\\{v_{np2} - v_j2, c2, d2\\\\}, ..., \\\\{v_{npn} - v_jn, cn, dn\\\\}\\\\} \\\\).\\n\\nThe task reward \\\\( R_G = R_G(\\\\cdot) \\\\) is the summarization of all contact pair rewards:\\n\\n\\\\[\\nR_G = \\\\sum_{k=1}^{n} w_k R_k,\\n\\\\]\\n\\nWe model each contact reward \\\\( R_k \\\\) according to the contact type \\\\( c_k \\\\). When \\\\( c_k = \\\\text{contact} \\\\), the contact reward encourages the joint \\\\( j \\\\) to be close to the part \\\\( p \\\\), satisfying the specified direction \\\\( d \\\\).\"}"}
{"id": "1vCnDyQkjg", "page_num": 6, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Design 1\\nUnified Interface\\nTaskParser\\nUnified Policy\\nDesign 3\\nDesign 2\\nModel 1\\nModel 2\\nModel 3\\n\\nPrevious:\\nIsolated designs for different tasks\\nOurs: Unified designs for all tasks\\n\\n(b) Ego-centric Heightmap\\n(a) Framework Comparison\\n\\nTask 1\\nTask 2\\nTask 3\\n\\nFigure 4: Design Visualization.\\n(a) Our framework ensures a unified design across tasks using the unified interface and the TaskParser. (b) The ego-centric height map in a ScanNet scene is depicted by green dots, with darker shades indicating greater height.\\n\\nTable 2: Performance Evaluation on the ScenePlan Dataset.\\n\\n| Source       | Success Rate (%) | Contact Error | Success Steps |\\n|--------------|------------------|---------------|---------------|\\n| PartNet (Mo et al., 2019) | 91.1             | 63.2          | 39.7          |\\n|              | 0.038            | 0.073         | 0.101         |\\n| wo Adaptive Weights | 21.2             | 5.3           | 0.1           |\\n|              | 0.181            | 0.312         | 0.487         |\\n| wo Heightmap  | 61.6             | 45.7          | 0.0           |\\n|              | 0.068            | 0.076         | -             |\\n| ScanNet (Dai et al., 2017) | 76.1             | 43.5          | 32.2          |\\n|              | 0.067            | 0.101         | 0.311         |\\n\\n\\\\[ \\\\begin{align*}\\nR_k = \\\\begin{cases} \\n  w_{\\\\text{dis}} \\\\exp\\\\left(-w_{dk} \\\\left| d_k \\\\right| \\\\right) + w_{\\\\text{dir}} \\\\max\\\\left(d_k \\\\hat{d}_k, 0\\\\right), & c_k = \\\\text{contact} \\\\\\\\\\n  1 - \\\\exp\\\\left(-w_{dk} \\\\left| d_k \\\\right| \\\\right), & c_k = \\\\text{not contact} \\\\\\\\\\n  1, & c_k = \\\\text{not care}\\n\\\\end{cases} \\n\\\\end{align*} \\\\]\\n\\nwhere \\\\( d_k = v_{np} - v_{j} \\\\) indicates the \\\\( k \\\\)th distance vector, \\\\( \\\\hat{d}_k \\\\) is the unit direction vector specified by direction \\\\( d_k \\\\), and \\\\( c_k \\\\) is the \\\\( k \\\\)th contact type. \\\\( w_{\\\\text{dis}}, w_{\\\\text{dir}}, w_{dk} \\\\) are corresponding weights. We set the scale interval of \\\\( R_k \\\\) as \\\\([0, 1]\\\\) and use \\\\( \\\\exp \\\\) to ensure it.\\n\\nSimilar to the formulation of contact reward, the TaskParser considers a step to be completed if All \\\\( k = 1, 2, ..., n \\\\) satisfy: if \\\\( c_k = \\\\text{contact} : \\\\left| d_k \\\\right| < 0.1 \\\\) and \\\\( d_k \\\\hat{d}_k > 0.8 \\\\), if \\\\( c_k = \\\\text{not contact} : \\\\left| d_k \\\\right| > 0.1 \\\\), if \\\\( c_k = \\\\text{not care} \\\\), True.\\n\\nAdaptive Contact Weights.\\nThe formulation of 6 includes lots of weights to balance different contact parts of the rewards. Empirically setting them requires much laboring and is not generalizable to versatile tasks. To this end, we adaptively set these weights based on the current optimization process. The basic idea is to give parts of rewards that are hard to optimize high rewards while lowering the weights of easier parts. Given \\\\( R_1, R_2, ..., R_n \\\\), we heuristically set their weights to \\\\( w_k = 1 - R_k / \\\\max_{1 \\\\leq p \\\\leq n} R_p + e \\\\), (8)\\n\\nEgo-centric Heightmap.\\nThe humanoid must be scene-aware to avoid collision when navigating or interacting in a scene. We adopt similar approaches in Wang et al. (2022a); Won et al. (2022); Starke et al. (2019) that sample surrounding information as the humanoid's observation. We build a square ego-centric heightmap that samples the height of surrounding objects (Fig. 4 (b)). It is important to extend our methods into real scanned scenarios such as ScanNet (Dai et al., 2017) in which various objects are densely distributed and easily collide.\\n\\n4 EXPERIMENTS\\n\\nExisting methods and datasets related to human-scene interactions mainly focus on short and limited tasks (Hassan et al., 2021a; Peng et al., 2021; Hassan et al., 2023; Wang et al., 2022b). To the best of our knowledge, we are the first method that supports arbitrary horizon interactions with language commands as input. To this end, we construct a novel dataset for training and evaluation. We also conduct various ablations with vanilla baselines and key components of our framework.\"}"}
{"id": "1vCnDyQkjg", "page_num": 7, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 5: Visual Examples Illustrating Tasks of Varying Difficulty Levels.\\n\\n4.1 DATASETS AND METRICS\\n\\nTo facilitate the training and evaluation of UniHSI, we construct a novel ScenePlan dataset comprising various indoor scenarios and interaction plans. The indoor scenarios are collected and constructed from object datasets and scanned scene datasets. We leverage our LLM Planner to generate interaction plans based on these scenarios. The training of our model also requires motion datasets to train the motion discriminator, which constrains our agents to interact in natural ways. We follow the practice of Hassan et al. (2023) to evaluate the performance of our method.\\n\\nScenePlan. We gather scenarios for ScenePlan from PartNet (Mo et al., 2019) and ScanNet (Dai et al., 2017) datasets. PartNet offers indoor objects with fine-grained part annotations, ideal for LLM Planners. We select diverse objects from PartNet and compose them into scenarios. For ScanNet, which contains real indoor room scenes, we collect scenes and annotate key object parts based on fragmented area annotations. We then employ the LLM Planner to generate various interaction plans from these scenarios. Our training set includes 40 objects from PartNet, with 5-20 plausible interaction steps generated for each object. During training, we randomly choose 1-4 objects from this set for each scenario and select their steps as interaction plans. The evaluation set consists of 40 PartNet objects and 10 ScanNet scenarios. We construct objects from PartNet into scenarios either manually or randomly. We generated 1,040 interaction plans for PartNet scenarios and 100 interaction plans for ScanNet scenarios. These plans encompass diverse interactions, including different types, horizons, and multiple objects.\\n\\nMotion Datasets. We use the SAMP dataset (Hassan et al., 2021a) and CIRCLE (Ara\u00fajo et al., 2023) as our motion dataset. SAMP includes 100 minutes of MoCap clips, covering common walking, sitting, and lying down behaviors. CIRCLE contains diverse right and left-hand reaching data. We use all clips in SAMP and pick 20 representative clips in CIRCLE for training.\\n\\nMetrics. We follow Hassan et al. (2023) that uses Success Rate and Contact Error (Precision in Hassan et al. (2023)) as the main metrics to measure the quality of interactions quantitatively. Success Rate records the percentage of trials that humanoids successfully complete every step of the whole plan. In our experiments, we consider a trial of \\\\( n \\\\) steps to be successfully completed if humanoids finish it in \\\\( n \\\\times 10 \\\\) seconds. We also record the average error of all contact pairs:\\n\\n\\\\[\\n\\\\text{ContactError} = \\\\frac{\\\\sum_{i,c \\\\neq 0} \\\\text{er}_i}{\\\\sum_{i,c \\\\neq 0} 1}, \\\\text{er}_i = ||d_{k,c_i}||, c_i = \\\\text{contact} \\\\min(0.3 - ||d_{k,c_i}||, 0). c_i = \\\\text{not contact}\\n\\\\]\\n\\nWe further record Success Steps, which denotes the average success step in task execution.\\n\\n4.2 PERFORMANCE ON SCENEPLAN\\n\\nWe initially conducted experiments on our ScenePlan dataset. To measure performance in detail, we categorize task plans into three levels: simple, medium, and hard. We classify plans within 3 steps as simple tasks, those with more than 3 steps but with a single object as medium-level tasks, and those with multiple objects as hard tasks. Simple task plans typically involve straightforward interactions. Medium-level plans encompass more diverse interactions with multiple rounds of transitions. Hard\"}"}
{"id": "1vCnDyQkjg", "page_num": 8, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 3: Ablation Study on Baseline Models and Vanilla Implementations.\\n\\n| Methods                          | Success Rate (%) | Contact Error (\u2193) |\\n|---------------------------------|------------------|------------------|\\n| **Methods**                     |                  |                  |\\n| Sit                             |                  |                  |\\n| Lie Down                        |                  |                  |\\n| Reach                           |                  |                  |\\n| NSM - Sit (Starke et al., 2019) | 75.0             | 0.19             |\\n| SAMP - Sit (Hassan et al., 2021a) | 75.0             | 0.06             |\\n| SAMP - Lie Down (Hassan et al., 2021a) | 50.0             | 0.05             |\\n| InterPhys - Sit (Hassan et al., 2023) | 93.7             | 0.09             |\\n| InterPhys - Lie Down (Hassan et al., 2023) | 80.0             | 0.30             |\\n| AMP (Peng et al., 2021)-Sit     | 77.3             | 0.090            |\\n| AMP-Lie Down                    | 21.3             | 0.112            |\\n| AMP-Reach                       |                  | 98.1             |\\n| AMP-Vanilla Combination (VC)    | 62.5             | 20.1             |\\n| UniHSI                          | 94.3             | 81.5             |\\n\\nFigure 6: Visual Ablations.\\n\\n(a) Our model exhibits superior natural and accurate performance compared to baselines in tasks such as \u201cSit\u201d and \u201cLie Down\u201d. (b) Our model demonstrates more efficient and effective training procedures.\\n\\nTask plans introduce multiple objects, requiring agents to navigate between these objects and interact with one or more objects simultaneously. Examples of tasks are illustrated in Fig. 5.\\n\\nAs shown in Table 2, UniHSI performs well in simple task plans, exhibiting a high Success Rate and low Error. However, as task plans become more diverse and complex, the performance of our model experiences a noticeable decline. Nevertheless, the Success Steps metric continues to increase, indicating that our model still performs well in parts of the plans. It's important to note that the scenarios in the ScenePlan test set are unseen during training, and scenes from ScanNet exhibit a modality gap with the training set. The overall performance on the test set demonstrates the versatile capability, robustness, and generalization ability of UniHSI.\\n\\n4.3 ABLATION STUDIES\\n\\n4.3.1 KEY COMPONENTS\\n\\nChoice of LLMs for UniHSI.\\n\\nWe evaluated different Language Model (LM) choices for the LLM Planner using 100 sets of language commands. We compared task plan Execution Success Rate (ESR) and Planning Correctness (PC) among humans, GPT-3.5OpenAI (2020), and GPT-4OpenAI (2023) across 10 tests per plan. PC is evaluated by humans, with choices of \u201ccorrect\u201d and \u201cnot correct\u201d. GPT-4 outperformed GPT-3.5, but both LLMs still lag behind human performance. Failures typically involved incomplete planning and out-of-distribution interactions, like GPT-3.5 occasionally skipping transitions or generating out-of-distribution actions like opening a laptop. While using more rules in prompts and GPT-4 can mitigate these issues, errors can still occur.\\n\\nAdaptive Weights.\\n\\nTable 2 demonstrates that removing Adaptive Weights from our controller leads to a substantial performance decline across all task levels. Adaptive Weights are crucial for optimizing various contact pairs effectively. They automatically adjust weights, reducing them for unused contact pairs.\"}"}
{"id": "1vCnDyQkjg", "page_num": 1, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Diverse Interactions with the same object\\nUnified and Long-horizon Control\\nWith Language Commands as Inputs\\nFine-granularity Control\\n\\nPut the book to the top shelf\\nPlay video games for a while\\nLean back and watch TV\\nLean forward and watch TV\\nLie on the bed, knees up\\n\\nFigure 1: UniHSI facilitates unified and long-horizon control in response to natural language commands, offering notable features such as diverse interactions with a singular object, multi-object interactions, and fine-granularity control.\\n\\nABSTRACT\\n\\nHuman-Scene Interaction (HSI) is a vital component of fields like embodied AI and virtual reality. Despite advancements in motion quality and physical plausibility, two pivotal factors, versatile interaction control and user-friendly interfaces, require further exploration for the practical application of HSI. This paper presents a unified HSI framework, named UniHSI, that supports unified control of diverse interactions through language commands. The framework defines interaction as \u201cChain of Contacts (CoC),\u201d representing steps involving human joint-object part pairs. This concept is inspired by the strong correlation between interaction types and corresponding contact regions. Based on the definition, UniHSI constitutes a Large Language Model (LLM) Planner to translate language prompts into task plans in the form of CoC, and a Unified Controller that turns CoC into uniform task execution. To support training and evaluation, we collect a new dataset named ScenePlan that encompasses thousands of task plans generated by LLMs based on diverse scenarios. Comprehensive experiments demonstrate the effectiveness of our framework in versatile task execution and generalizability to real scanned scenes.\\n\\nINTRODUCTION\\n\\nHuman-Scene Interaction (HSI) constitutes a crucial element in various applications, including embodied AI and virtual reality. Despite the great efforts in this domain to promote motion quality (Holden et al., 2017; Starke et al., 2019; 2020; Hassan et al., 2021b; Zhao et al., 2022; Hassan et al.,...\"}"}
{"id": "1vCnDyQkjg", "page_num": 2, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"versatile interaction control and the development of a user-friendly interface, are yet to be explored before HSI can be put into practical usage. This paper aims to provide an HSI system that supports versatile interaction control through language commands, one of the most uniform and accessible interfaces for users. Such a system requires: 1) Aligning language commands with precise interaction execution, 2) Unifying diverse interactions within a single model to ensure scalability. To achieve this, the initial effort involves the uniform definition of different interactions. We propose that interaction itself contains a strong prior in the form of human-object contact regions. For example, in the case of \u201clie down on the bed\u201d, it can be interpreted as \u201cfirst the pelvis contacting the mattress of the bed, then the head contacting the pillow\u201d. To this end, we formulate interaction as ordered sequences of human joint-object part contact pairs, which we refer to as Chain of Contacts (CoC). Unlike previous contact-driven methods, which are limited to supporting specific interactions through manual design, our interaction definition is generalizable to versatile interactions and capable of modeling multi-round transitions. The recent advancements in Large Language Models have made it possible to translate language commands into CoC. The structured formulation then can be uniformly processed for the downstream controller to execute.\\n\\nFollowing the above formulation, we propose UniHSI, the first Unified physical HSI framework with language commands as inputs. UniHSI consists of a high-level LLM Planner to translate language inputs into the task plans in the form of CoC and a low-level Unified Controller for executing these plans. Combining language commands and background information such as body joint names and object part layout, we harness prompt engineering techniques to instruct LLMs to plan interaction step by step. We design the TaskParser to support the unified execution. It serves as the core of the Unified Controller. Following CoC, the TaskParser collects information including joint poses and object point clouds from the physical environment, then formulates them into uniform task observations and task objectives.\\n\\nAs illustrated in Fig. 1, the Unified Controller models whole-body joints and arbitrary parts of objects in the scenarios to enable fine-granularity control and multi-object interaction. With different language commands, we can generate diverse interactions with the same object. Unlike previous methods that only model a limited horizon of interactions, like \u201csitting down\u201d, we design the TaskParser to evaluate the completion of the current steps and sequentially fetch the next step, resulting in multi-round and long-horizon transition control. The Unified control leverages the adversarial motion prior framework (Peng et al., 2021) that uses a motion discriminator for realistic motion synthesis and a physical simulation (Makoviychuk et al., 2021) to ensure physical plausibility. Another impressive feature of our framework is the training is interaction annotation-free. Previous methods typically require datasets that capture both target objects and the corresponding motion sequences, which demand numerous laboring. In contrast, we leverage the interaction knowledge of LLMs to generate interaction plans. It significantly reduces the annotation requirements and makes versatile interaction training feasible. To this end, we create a novel dataset named ScenePlan. It encompasses thousands of interaction plans based on scenarios constructed from PartNet (Mo et al., 2019) and ScanNet (Dai et al., 2017) datasets. We conduct comprehensive experiments on ScenePlan. The results illustrate the effectiveness of the model in versatile interaction control and good generalizability on real scanned scenarios.\"}"}
{"id": "1vCnDyQkjg", "page_num": 3, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 1: Comparative Analysis of Key Features between UniHSI and Preceding Methods.\\n\\n| Methods                  | Unified Interaction | Language Input | Long-horizon Transition | Interaction Annotation-free | Control Joints | Multi-object Interactions |\\n|--------------------------|---------------------|----------------|-------------------------|-----------------------------|----------------|---------------------------|\\n| NSM Starke et al. (2019) | \u2713                   | 3 (pelvis, hands) | \u2713                       |                             |                |                           |\\n| SAMP Hassan et al. (2021a) |                    | 1 (pelvis)       |                         |                             |                |                           |\\n| COUCH Zhang et al. (2022b) | \u2713                   | 3 (pelvis, hands) | \u2713                       |                             |                |                           |\\n| HUMANISE Wang et al. (2022b) | \u2713 \u2713               |                |                         |                             |                |                           |\\n| -ScenDiffuser Huang et al. (2023) | \u2713 \u2713               |                |                         |                             |                |                           |\\n| PADL Juravsky et al. (2022) | \u2713 \u2713 \u2713              |                |                         |                             |                |                           |\\n| InterPhys Hassan et al. (2023) |                    | 4 (pelvis, head, hands) | \u2713                       |                             |                |                           |\\n| Ours                     | \u2713 \u2713 \u2713               | 15 (whole-body) | \u2713                       |                             |                |                           |\\n\\nPhysical plausibility and prone to synthesizing motions with artifacts, such as penetration, floating, and sliding. The need for additional post-processing to mitigate these artifacts hinders the real-time applicability of these frameworks.\\n\\nPhysics-based Human-Scene Interaction.\\n\\nRecent advances in physics-based methods (e.g., (Peng et al., 2021; 2022; Hassan et al., 2023; Juravsky et al., 2022; Pan et al., 2023) hold promise for ensuring physical realism through physics-aware simulators. However, they have limitations: 1) They typically require separate policy networks for each task, limiting their ability to learn versatile interactions within a unified controller. 2) These methods often focus on basic action-based control, neglecting finer-grained interaction details. 3) They heavily rely on annotated motion sequences for human-scene interactions, which can be challenging to obtain. In contrast, our UniHSI redesigns human-scene interactions into a uniform representation, driven by world knowledge from our high-level LLM Planner. This allows us to train a unified controller with versatile interaction skills without the need for annotated motion sequences. Key feature comparisons are in Tab. 1.\\n\\nLanguages in Human Motion Control.\\n\\nIncorporating language understanding into human motion control has become a recent research focus. Existing methods primarily focus on scene-agnostic motion synthesis (Zhang et al., 2022a; Chen et al., 2023; Tevet et al., 2022a;b; Zhang et al., 2023a;b; Jiang et al., 2023) (Athanasiou et al., 2023). Generating human-scene interactions using language commands poses additional challenges because the output movements must align with the commands and be coherent with the environment. Zhao et al. (2022) generates static interaction gestures through rule-based mapping of language commands to specific tasks. Juravsky et al. (2022) utilized BERT (Devlin et al., 2018) to infer language commands, but their method requires pre-defined tasks and different low-level policies for task execution. Wang et al. (2022b) unified various tasks in a CV AE (Yao et al., 2022) network with a language interface, but their performance was limited due to challenges in grounding target objects and contact areas for the characters. Recently, there have been some explorations on LLM-based agent control. Brohan et al. (2023) uses fine-tuned VLM (Vision Language Model) to directly output actions for low-level robots. Rocamonde et al. (2023) employs CLIP-generated cos-similarity as RL training rewards. In contrast, UniHSI utilizes large language models to transfer language commands into the formation of Chain of Contacts and design a robust unified controller to execute versatile interaction based on the structured formation.\\n\\n3 METHODOLOGY\\n\\nAs shown in Fig. 2, UniHSI supports versatile human-scene interaction control following language commands. In the following subsections, we first illustrate how we design the unified interaction formulation as CoC (Sec. 3.1). Then we show how we translate language commands into the unified formulation by the LLM Planner (Sec. 3.2). Finally, we elaborate on the construction of the Unified Controller (Sec. 3.3).\"}"}
{"id": "1vCnDyQkjg", "page_num": 4, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 2: Comprehensive Overview of UniHSI. The entire pipeline comprises two principal components: the LLM Planner and the Unified Controller. The LLM Planner processes language inputs and background scenario information to generate multi-step plans in the form of CoC. Subsequently, the Unified Controller executes CoC step by step, producing interaction movements.\\n\\nWe construct each contact pair with five elements: an object $o$, an object part $p$, a humanoid joint $j$, the contact type $c$ of $j$ and $p$, and the relative direction $d$ from $j$ to $p$. The contact type includes \u201ccontact\u201d, \u201cnot contact\u201d, and \u201cnot care\u201d. The relative direction includes \u201cup\u201d, \u201cdown\u201d, \u201cfront\u201d, \u201cback\u201d, \u201cleft\u201d, and \u201cright\u201d. For example, one contact unit $\\\\{o, p, j, c, d\\\\}$ could be $\\\\{\\\\text{chair}, \\\\text{seat surface}, \\\\text{pelvis}, \\\\text{contact}, \\\\text{up}\\\\}$. In this way, we can formulate each $S$ as $S = \\\\{\\\\{o_1, p_1, j_1, c_1, d_1\\\\}, \\\\{o_2, p_2, j_2, c_2, d_2\\\\}, ...\\\\}$. (2)\\n\\nCoC is the output of the LLM Planner and the input of the Unified Controller.\\n\\n3.2 LARGE LANGUAGE MODEL PLANNER\\n\\nWe leverage LLMs as our planners to infer language commands $L$ into manageable plans $C$. As shown in Fig. 3, the inputs of the LLM Planner include language commands $L$, background scenario information $B$, humanoid joint information $J$ together with pre-set instructions, rules and examples. Specifically, $B$ includes several objects $O$ and their optional spatial layouts. Each object consists of several parts $P$, i.e., a chair could consist of arms, the back, and the seat. The humanoid joint information is pre-defined for all scenarios. We use prompt engineering to combine these elements together and instruct LLMs to output task plans. By modifying instructions in the prompts, we can generate specified numbers of plans for diverse ways of interactions. We can also let LLMs automatically generate plausible plans given the scenes. In this way, we build our interaction datasets to train and evaluate the Unified Controller.\\n\\n3.3 UNIFIED CONTROLLER\\n\\nThe Unified Controller takes multi-step plans $C$ and background scenarios in the form of meshes and point clouds as input and outputs realistic movements coherent to the environments.\"}"}
{"id": "1vCnDyQkjg", "page_num": 9, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2024\\n\\nor easily learned pairs and increasing them for more challenging pairs. This becomes especially vital as tasks become more complex.\\n\\nEgo-centric Heightmap. Removing the Ego-centric Heightmap results in performance degradation, especially for difficult tasks. This heightmap is essential for agent navigation within scenes, enabling perception of surroundings and preventing collisions with objects. This is particularly critical for challenging tasks involving complex scenarios and numerous objects. Additionally, the Ego-centric Heightmap is key to our model's ability to generalize to real scanned scenes.\\n\\n4.3.2 Design Comparison with Previous Methods\\n\\nBaseline Settings. We compared our approach to previous methods using simple interaction tasks like \u201cSit,\u201d \u201cLie Down,\u201d and \u201cReach.\u201d Direct comparisons are challenging due to differences in training data and code unavailability for a closely related method (Hassan et al., 2023). We integrated key design elements from Hassan et al. (2023) into our baseline model (Peng et al., 2021) to ensure fairness. Task observations and objectives were manually formulated for various tasks, following Hassan et al. (2023), with task objectives expressed as:\\n\\n\\\\[\\nR_G = 0.7R_{near} + 0.3R_{far}, \\\\text{ if distance} > 0.5m\\n\\\\]\\n\\n\\\\[\\nR_{near} + 0.3, \\\\text{ otherwise (10)}\\n\\\\]\\n\\nIn this equation, \\\\( R_{far} \\\\) encourages character movement toward the object, and \\\\( R_{near} \\\\) encourages specific task performance when the character is close, necessitating task-specific designs.\\n\\nWe also created a vanilla baseline by consolidating multiple tasks within a single model. We combined task observations from various tasks and included task choices within these observations. We randomly selected tasks and trained them with their respective rewards during training. This experiment involved a total of 70 objects (30 for sitting, 30 for lying down, and 10 for reaching) with 4096 trials per task and random variations in orientation and object placement during evaluation.\\n\\nQuantitative Comparison. In Table 3, UniHSI consistently outperforms or matches baseline implementations across various metrics. The performance advantage is most pronounced in complex tasks, especially the challenging \u201cLie Down\u201d task. This improvement stems from our approach of breaking tasks into multi-step plans, reducing task complexity. Additionally, our model benefits from shared motion transitions among tasks, enhancing its adaptability. Figure 6 (b) shows that our methods achieve higher success rates and converge faster than baseline implementations. Importantly, the vanilla combination of AMP (Peng et al., 2021) results in a noticeable performance drop in all tasks while our methods remain effective. This difference is because the vanilla combination introduces interference and inefficiencies in training, whereas our approach unifies tasks into consistent representations and objectives, enhancing multi-task learning.\\n\\nQualitative Comparison. In Figure 6 (a), we qualitatively visualize the performance of baseline methods and our model. Our model performs more naturally and accurately than the baselines in tasks like \u201cSit\u201d and \u201cLie Down\u201d. This is primarily attributed to the differences in task objectives. Baseline objectives (Eq. 10) model the combination of sub-tasks, such as walking close and sitting down, as simultaneous processes. Consequently, agents tend to perform these different goals simultaneously. For example, they may attempt to sit down even if they are not in the correct position or throw themselves like a projectile onto the bed, disregarding the natural task progression. On the other hand, our methods decompose tasks into natural movements through language planners, resulting in more realistic interactions.\\n\\n5 Conclusion\\n\\nUniHSI is a unified Human-Scene Interaction (HSI) system adept at diverse interactions and language commands. Defined as Chains of Contacts (CoC), interactions involve sequences of human joint-object part contact pairs. UniHSI integrates a Large Language Planner for command translation into CoC and a Unified Controller for uniform execution. Comprehensive experiments showcase UniHSI's effectiveness and generalizability, representing a significant advancement in versatile and user-friendly HSI systems.\\n\\nAcknowledgement. We acknowledge Shanghai AI Lab and NTU S-Lab for their funding support.\"}"}
{"id": "1vCnDyQkjg", "page_num": 10, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Joao Pedro Ara\u00fajo, Jiaman Li, Karthik Vetrivel, Rishi Agarwal, Jiajun Wu, Deepak Gopinath, Alexander William Clegg, and Karen Liu. Circle: Capture in rich contextual environments. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pp. 21211\u201321221, 2023.\\n\\nNikos Athanasiou, Mathis Petrovich, Michael J Black, and G\u00fcl Varol. Sinc: Spatial composition of 3d human motions for simultaneous action generation. arXiv preprint arXiv:2304.10417, 2023.\\n\\nEmad Barsoum, John Kender, and Zicheng Liu. Hp-gan: Probabilistic 3d human motion prediction via gan. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition Workshops, pp. 1418\u20131427, 2018.\\n\\nAnthony Brohan, Noah Brown, Justice Carbajal, Yevgen Chebotar, Xi Chen, Krzysztof Choromaniski, Tianli Ding, Danny Driess, Avinava Dubey, Chelsea Finn, et al. Rt-2: Vision-language-action models transfer web knowledge to robotic control. arXiv preprint arXiv:2307.15818, 2023.\\n\\nXin Chen, Biao Jiang, Wen Liu, Zilong Huang, Bin Fu, Tao Chen, and Gang Yu. Executing your commands via motion diffusion in latent space. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pp. 18000\u201318010, 2023.\\n\\nAngela Dai, Angel X Chang, Manolis Savva, Maciej Halber, Thomas Funkhouser, and Matthias Nie\u00dfner. Scannet: Richly-annotated 3d reconstructions of indoor scenes. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp. 5828\u20135839, 2017.\\n\\nJacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805, 2018.\\n\\nF\u00e9lix G Harvey, Mike Yurick, Derek Nowrouzezahrai, and Christopher Pal. Robust motion in-betweening. ACM Transactions on Graphics (TOG), 39(4):60\u20131, 2020.\\n\\nMohamed Hassan, Duygu Ceylan, Ruben Villegas, Jun Saito, Jimei Yang, Yi Zhou, and Michael J Black. Stochastic scene-aware motion prediction. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pp. 11374\u201311384, 2021a.\\n\\nMohamed Hassan, Partha Ghosh, Joachim Tesch, Dimitrios Tzionas, and Michael J Black. Populating 3d scenes by learning human-scene interaction. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pp. 14708\u201314718, 2021b.\\n\\nMohamed Hassan, Yunrong Guo, Tingwu Wang, Michael Black, Sanja Fidler, and Xue Bin Peng. Synthesizing physical character-scene interactions. arXiv preprint arXiv:2302.00883, 2023.\\n\\nDaniel Holden, Taku Komura, and Jun Saito. Phase-functioned neural networks for character control. ACM Transactions on Graphics (TOG), 36(4):1\u201313, 2017.\\n\\nSiyuan Huang, Zan Wang, Puhao Li, Baoxiong Jia, Tengyu Liu, Yixin Zhu, Wei Liang, and Song-Chun Zhu. Diffusion-based generation, optimization, and planning in 3d scenes. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pp. 16750\u201316761, 2023.\\n\\nBiao Jiang, Xin Chen, Wen Liu, Jingyi Yu, Gang Yu, and Tao Chen. Motiongpt: Human motion as a foreign language. arXiv preprint arXiv:2306.14795, 2023.\\n\\nJordan Juravsky, Yunrong Guo, Sanja Fidler, and Xue Bin Peng. Padl: Language-directed physics-based character control. In SIGGRAPH Asia 2022 Conference Papers, pp. 1\u20139, 2022.\\n\\nViktor Makoviychuk, Lukasz Wawrzyniak, Yunrong Guo, Michelle Lu, Kier Storey, Miles Macklin, David Hoeller, Nikita Rudin, Arthur Allshire, Ankur Handa, et al. Isaac gym: High performance gpu-based physics simulation for robot learning. arXiv preprint arXiv:2108.10470, 2021.\\n\\nKaichun Mo, Shilin Zhu, Angel X Chang, Li Yi, Subarna Tripathi, Leonidas J Guibas, and Hao Su. Partnet: A large-scale benchmark for fine-grained and hierarchical part-level 3d object understanding. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pp. 909\u2013918, 2019.\"}"}
{"id": "1vCnDyQkjg", "page_num": 11, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"OpenAI. GPT-3: Generative pre-trained transformer 3. https://openai.com/research/gpt-3, 2020.\\n\\nOpenAI. GPT-4 technical report, 2023.\\n\\nLiang Pan, Jingbo Wang, Buzhen Huang, Junyu Zhang, Haofan Wang, Xu Tang, and Yangang Wang. Synthesizing physically plausible human motions in 3D scenes. arXiv preprint arXiv:2308.09036, 2023.\\n\\nDario Pavllo, David Grangier, and Michael Auli. Quaternet: A quaternion-based recurrent model for human motion. arXiv preprint arXiv:1805.06485, 2018.\\n\\nXue Bin Peng, Ze Ma, Pieter Abbeel, Sergey Levine, and Angjoo Kanazawa. Amp: Adversarial motion priors for stylized physics-based character control. ACM Transactions on Graphics (ToG), 40(4):1\u201320, 2021.\\n\\nXue Bin Peng, Yunrong Guo, Lina Halper, Sergey Levine, and Sanja Fidler. Ase: Large-scale reusable adversarial skill embeddings for physically simulated characters. ACM Transactions On Graphics (TOG), 41(4):1\u201317, 2022.\\n\\nJuan Rocamonde, Victoriano Montesinos, Elvis Nava, Ethan Perez, and David Lindner. Vision-language models are zero-shot reward models for reinforcement learning. arXiv preprint arXiv:2310.12921, 2023.\\n\\nSebastian Starke, He Zhang, Taku Komura, and Jun Saito. Neural state machine for character-scene interactions. ACM Trans. Graph., 38(6):209\u20131, 2019.\\n\\nSebastian Starke, Yiwei Zhao, Taku Komura, and Kazi Zaman. Local motion phases for learning multi-contact character movements. ACM Transactions on Graphics (TOG), 39(4):54\u20131, 2020.\\n\\nGuy Tevet, Brian Gordon, Amir Hertz, Amit H Bermano, and Daniel Cohen-Or. Motionclip: Exposing human motion generation to clip space. In Computer Vision\u2013ECCV 2022: 17th European Conference, Tel Aviv, Israel, October 23\u201327, 2022, Proceedings, Part XXII, pp. 358\u2013374. Springer, 2022a.\\n\\nGuy Tevet, Sigal Raab, Brian Gordon, Yonatan Shafir, Daniel Cohen-Or, and Amit H Bermano. Human motion diffusion model. arXiv preprint arXiv:2209.14916, 2022b.\\n\\nJingbo Wang, Yu Rong, Jingyuan Liu, Sijie Yan, Dahua Lin, and Bo Dai. Towards diverse and natural scene-aware 3D human motion synthesis. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pp. 20460\u201320469, 2022a.\\n\\nZan Wang, Yixin Chen, Tengyu Liu, Yixin Zhu, Wei Liang, and Siyuan Huang. Humanise: Language-conditioned human motion generation in 3D scenes. Advances in Neural Information Processing Systems, 35:14959\u201314971, 2022b.\\n\\nJungdam Won, Deepak Gopinath, and Jessica Hodgins. Physics-based character controllers using conditional vaes. ACM Transactions on Graphics (TOG), 41(4):1\u201312, 2022.\\n\\nSijie Yan, Zhizhong Li, Yuanjun Xiong, Huahan Yan, and Dahua Lin. Convolutional sequence generation for skeleton-based action synthesis. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pp. 4394\u20134402, 2019.\\n\\nHeyuan Yao, Zhenhua Song, Baoquan Chen, and Libin Liu. Controlvae: Model-based learning of generative controllers for physics-based characters. ACM Transactions on Graphics (TOG), 41(6):1\u201316, 2022.\\n\\nJianrong Zhang, Yangsong Zhang, Xiaodong Cun, Shaoli Huang, Yong Zhang, Hongwei Zhao, Hongtao Lu, and Xi Shen. T2m-gpt: Generating human motion from textual descriptions with discrete representations. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), 2023a.\\n\\nMingyuan Zhang, Zhongang Cai, Liang Pan, Fangzhou Hong, Xinying Guo, Lei Yang, and Ziwei Liu. Motiondiffuse: Text-driven human motion generation with diffusion model. arXiv preprint arXiv:2208.15001, 2022a.\"}"}
{"id": "1vCnDyQkjg", "page_num": 12, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":null}"}

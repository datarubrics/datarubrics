{"id": "9RUHPlladgh", "page_num": 31, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"Figure 15: Shapes3D extrapolation. We show the qualitative extrapolation of a CNN model. The shape category is excluded because no order is clear.\"}"}
{"id": "9RUHPlladgh", "page_num": 32, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"Figure 16: MPI3D-Real extrapolation. We show the qualitative extrapolation of a CNN model. The shape category is excluded because no order is clear. Size is excluded because only two values are available.\"}"}
{"id": "9RUHPlladgh", "page_num": 33, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":null}"}
{"id": "9RUHPlladgh", "page_num": 34, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"Figure 18: CelebGlow extrapolation. We show the qualitative extrapolation of a DenseNet (ImageNet 1-K) model. This corresponds to the model with the highest correlation with the ground truth in Fig. 17 on the extrapolated factors (OOD factors). The person category is not extrapolated and used to measure correlations because no order is apparent.\"}"}
{"id": "9RUHPlladgh", "page_num": 19, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"The CelebGlow dataset is created based on the invertible generative neural network of Kingma et al. (Kingma & Dhariwal, 2018). We used their provided network that is pretrained on the Celeb-HQ dataset, and has labelled directions in the model-latent space that correspond to specific attributes of the dataset. Based on this latent space, we created the dataset as follows:\\n\\n1. In the latent space of the model, we sample from a high dimensional Gaussian with zero mean and a low standard deviation of 0.3 to avoid too much variability.\\n2. Next, we perform a latent walk into the directions that correspond to \\\"Smiling\\\", \\\"Age\\\" and \\\"Blondness\\\" in image space. To estimate the spacing, we rely on the function \\\\texttt{manipulate_range}. We perform 6 steps along each axis and all combinations (6x6x6 cube). As a scale parameter to the function, we use 0.8. Those factors were chosen so that the images differ significantly, but also to stay in the valid range of the model based on visual inspection.\\n3. We pass all latent coordinates through the glow network in the generative direction.\\n4. We further down-sample the images from 256x256x3 to 64x64x3 to match the resolution of common disentanglement datasets.\\n5. Finally, we store each image and the corresponding factor combination.\\n\\nThis procedure is repeated for 1000 samples to get $6 \\\\times 6 \\\\times 6 \\\\times 1000 = 216000$ samples in total, which is around the same size as other common datasets.\\n\\nAs described in the implementation details, we use common values from the literature to train the proposed models. Here, we investigate effects of such hyperparameters on the CNN architecture. Due to the combinatorial complexity, we do not perform a search for other architectures. As hyperparameters, we varied the number or training iterations (3 different numbers of iterations), we introduced 5 different strengths of regularization, 2 different depths for the CNN architecture [6 layers, 9 layers] and ran multiple random seeds for each combination.\\n\\nThe results on the extrapolation test on MPI3D set are shown in Fig. 9. Given this hyperparameter search, we find no improvement over our reported numbers for the CNN.\"}"}
{"id": "9RUHPlladgh", "page_num": 20, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"To narrow down the question \\\"why the generalization capabilities drop on real-world dataset MPI3D?\\\", we run a comparison on MPI3D dataset with real and synthetic images. The results on the MPI3D dataset with synthetic images is shown in Fig. 10 and Table 10. Comparing this with R-squared performances to MPI3D with real-world images (Fig. 4 and Table 9), we observe that the results do not change significantly (most results are in a 1-2sigma range). We conclude that the larger drops in performance on MPI3D compared to Shapes3D or dSprites, are not due to the real images as opposed to synthetic images. Instead, we hypothesize that it is due to the more realistic setup of the MPI3D dataset itself. For instance, it contains complex factors like rotation in 3D projected on 2D. Here, occluded parts of objects have to be guessed based on certain symmetry assumptions.\\n\\nThe setup of dSprites is non-injective, as different rotations map to the same image. E.g., the square at a rotation $90^\\\\circ$ is identical to the one rotated by $180^\\\\circ$ and therefore ambiguous. Thus, the training process is noisy. In an ablation study, we controlled for this by constraining the rotations to lie in $[0, 90)$. We again ran all our proposed models and report the $R^2$-Score in Fig. 11b.\"}"}
{"id": "9RUHPlladgh", "page_num": 21, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Comparing the new results with the original dSprites results shows: First, for the random test-train split, resolving the rotational ambiguity leads to almost perfect performance (close to 100% R-squared scores for most models). In the previous dSprites setup with rotational ambiguity, top accuracies are around 70-95% R-squared scores for most models. Second, large drops in performance can still be observed when we move towards the systematic out-of-distribution splits (composition, interpolation, and extrapolation). Also, our insights on how models extrapolate remain the same. Lastly, for the random split, the Rotation-EQ model shows non-perfect performance. Tracing this error to individual factors, it turns out this is due to limited capabilities in predicting the x, y positions. We hypothesize that this is due to limitations of convolutions in propagating spatial positions, as discussed in (Liu et al., 2018). The DenseNet performs perfectly on the train set and might be overfitting.\\n\\nWe conclude that the rotational ambiguity explains the drops on the random split. However, the clear drops in performance on the systematic splits remain nonetheless. Thus, the analysis we perform in the paper and the conclusions we draw remain the same.\\n\\n**DATA AUGMENTATIONS**\\n\\nWe investigate the effects of data augmentation during training time on the generalization performance in the extrapolation setting of our proposed benchmark. As data augmentations, we applied random erasing, Gaussian Noise, small shearings, and blurring. Note that we could not use arbitrary augmentations. For instance, shift augmentations would lead to ambiguities with the \\\"shift\\\" factor in dSprites. Next, we trained CNNs with and without data augmentations on all four datasets (dSprites, Shapes3D, MPI3D, CelebGlow) on the extrapolation splits with multiple random seeds.\\n\\nThe results are visualized in Fig. 12. For the mean performance, we observe no significant improvement by adding augmentations. However, the overall spread of the scores seems to decrease given augmentations on some datasets. We explain this by the fact that the augmentations enforce certain invariances that are beneficial for extrapolation tasks.\"}"}
{"id": "9RUHPlladgh", "page_num": 22, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 12: $R^2$-score on data augmentations. We depict the performance on the extrapolation setting with and without data augmentations for a CNN network with various random seeds on our considered datasets.\\n\\nWe here try to attribute the performance losses to individual OOD factors (see \u00a75.2). Thus, on the extrapolation setting, we modify the test-splits such that only a single factor is out-of-distribution. Next, we measure the overall performance across models (all fully supervised and transfer models) to demonstrate the effect of this factor. The results are depicted for all models in Fig. 13. Overall, factors like \\\"height\\\" on MPI3D that control the viewing of the camera and, subsequently, change attributes like the absolute position in the image of other factors (e.g., the tip of the robot arm) have a high effect.\\n\\nH.1 Datasets\\nEach dataset consists of multiple factors of variation and every possible combination of factors generates a corresponding image. Here, we list all datasets and their corresponding factor ranges. Note, to estimate the reported $R^2$-score, we normalize the factors by dividing each factor $y_i$ by $|y_{max,i} - y_{min,i}|$, i.e., all factors are in the range $[0,1]$.\\n\\ndSprites (Matthey et al., 2017), represents some low resolution binary images of basic shapes with the 5 FoVs shape $\\\\{0, 1, 2\\\\}$, scale $\\\\{0, \\\\ldots, 4\\\\}$, orientation $\\\\{0, \\\\ldots, 39\\\\}$, x-position $\\\\{0, \\\\ldots, 31\\\\}$, and y-position $\\\\{0, \\\\ldots, 31\\\\}$. Next, Shapes3D (Kim & Mnih, 2018) which is a similarly popular dataset with 3D shapes in a room scenes defined by the 6 FoVs floor color $\\\\{0, \\\\ldots, 9\\\\}$, wall color $\\\\{0, \\\\ldots, 9\\\\}$, object color $\\\\{0, \\\\ldots, 9\\\\}$, object size $\\\\{0, \\\\ldots, 7\\\\}$, object type $\\\\{0, \\\\ldots, 3\\\\}$ and azimuth $\\\\{0, \\\\ldots, 14\\\\}$. Lastly, we consider the challenging and more realistic dataset MPI3D (Gondal et al., 2019) containing real images of physical 3D objects attached to a robotic finger generated by 7 FoVs color $\\\\{0, \\\\ldots, 5\\\\}$, shape $\\\\{0, \\\\ldots, 5\\\\}$, size $\\\\{0, 1\\\\}$, height $\\\\{0, 1, 2\\\\}$, background color $\\\\{0, 1, 2\\\\}$, x-axis $\\\\{0, \\\\ldots, 39\\\\}$ and y-axis $\\\\{0, \\\\ldots, 39\\\\}$. Note that this dataset contains a non-injective generative model as square and ellipses have multiple rotational symmetries.\"}"}
{"id": "9RUHPlladgh", "page_num": 27, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 14: Interpolation / Extrapolation and modularity.\\n\\nof factors in each dataset. As an ablation, we also provide a randomly initialized version for each transfer learning model.\\n\\nH.5 COMPUTE\\n\\nAll models are run on the NVIDIA T4 Tensor Core GPUs on the AWS g4dn.4xlarge instances with an approximate total compute of 20,000 GPUh. To save computational cost, we gradually increased the number of seeds until we achieved acceptable p-values of $\\\\leq 0.05$. In the end, we have 3 random seeds per supervised model and 10 random seeds per hyperparameter setting for the un and weakly supervised models.\"}"}
{"id": "9RUHPlladgh", "page_num": 28, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"| Model                  | $R^2$-score on dSprites | $R^2$-score on dSprites rotation $[0, 90]$ |\\n|------------------------|-------------------------|------------------------------------------|\\n| BetaV AE               | 94.3\u00b1 0.3               | 94.8\u00b1 0.5                                |\\n| Ada-GV AE              | 99.8\u00b1 0.0               | 92.9\u00b1 3.8                                |\\n| SlowV AE               | 99.8\u00b1 0.0               | 99.5\u00b1 0.3                                |\\n| PCL                    | 99.7\u00b1 0.0               | 99.6\u00b1 0.0                                |\\n| MLP                    | 98.1\u00b1 0.1               | 76.7\u00b1 0.5                                |\\n| CNN                    | 100.0\u00b1 0.0              | 99.7\u00b1 0.0                                |\\n| CoordConv              | 100.0\u00b1 0.0              | 99.0\u00b1 0.6                                |\\n| Coordinate Based       | 83.6\u00b1 1.5               | 55.2\u00b1 1.5                                |\\n| Rotation-EQ            | 53.0\u00b1 0.3               | 71.3\u00b1 nan                                 |\\n| Rotation-EQ-big        | 43.9\u00b1 0.4               | 71.5\u00b1 0.0                                |\\n| Spatial Transformer    | 100.0\u00b1 0.0              | 99.4\u00b1 0.2                                |\\n| RN50                   | 100.0\u00b1 0.0              | 98.7\u00b1 0.4                                |\\n| RN101                  | 100.0\u00b1 0.0              | 98.0\u00b1 0.4                                |\\n| DenseNet               | 100.0\u00b1 0.0              | 99.6\u00b1 0.2                                |\\n| RN50 (ImageNet-21k)    | 100.0\u00b1 0.0              | 98.3\u00b1 0.3                                |\\n| RN101 (ImageNet-21k)   | 100.0\u00b1 0.0              | 99.6\u00b1 0.1                                |\\n| DenseNet (ImageNet-1k) | 87.0\u00b1 18.2              | 99.8\u00b1 0.1                                |\"}"}
{"id": "9RUHPlladgh", "page_num": 29, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"| Models               | BetaV AE     | Ada-GV AE   | SlowV AE     | PCL         | MLP          | CNN        | CoordConv   | Coordinate Based | Rotation-EQ | Rotation-EQ-big | Spatial Transformer | RN50 (ImageNet-21k) | RN101 (ImageNet-21k) | DenseNet (ImageNet-1k) | RN50           | RN101             |\\n|---------------------|--------------|-------------|--------------|-------------|--------------|------------|-------------|------------------|--------------|------------------|---------------------|----------------------|---------------------|-------------------|-----------------|-------------------|\\n|                     | 99.9\u00b1 0.1    | 99.4\u00b1 0.4   | 91.1\u00b1 9.2    | 99.8\u00b1 0.1   | 100.0\u00b1 0.0   | 100.0\u00b1 0.0 | 100.0\u00b1 0.0  | 100.0\u00b1 0.0        | 100.0\u00b1 0.0   | 100.0\u00b1 0.0        | 100.0\u00b1 0.0               | 100.0\u00b1 0.0               | 100.0\u00b1 0.0               | 99.3\u00b1 1.2         | 100.0\u00b1 0.0         |\\n| R\u00b2-score on Shapes3D | 68.4\u00b1 0.6    | 43.7\u00b1 3.1   | 66.2\u00b1 0.1    | 43.5\u00b1 0.3   | 75.3\u00b1 2.2    | 82.0\u00b1 0.6  | 74.4\u00b1 2.4   | 58.0\u00b1 3.9         | 22.7\u00b1 1.8    | 44.1\u00b1 5.1         | 57.7\u00b1 0.5               | 50.0\u00b1 3.7               | 49.1\u00b1 0.7               | 53.2\u00b1 15.0        | 50.1\u00b1 0.8         |\\n|                     |              |             |              |             |              |            |             |                  |              |                  |                     |                      |                     |                   |                 |\\n| Table 7             |              |             |              |             |              |            |             |                  |              |                  |                     |                      |                     |                   |                 |\\n|                     |              |             |              |             |              |            |             |                  |              |                  |                     |                      |                     |                   |                 |\\n| Table 8             |              |             |              |             |              |            |             |                  |              |                  |                     |                      |                     |                   |                 |\\n| R\u00b2-score on CelebGlow | 97.1\u00b1 3.8    | 100.0\u00b1 0.0  | 86.8\u00b1 17.7   | 53.2\u00b1 22.3  |              |            |             |                  |              |                  |                     |                      |                     |                   |                 |\"}"}
{"id": "9RUHPlladgh", "page_num": 30, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"| Model          | $R^2$ Score on MPI3D  | $R^2$ Score on MPI3D-Toy |\\n|---------------|------------------------|--------------------------|\\n| BetaV AE      | 79.4\u00b1 1.1              | 79.9\u00b1 0.4                |\\n| Ada-GV AE     | 64.5\u00b1 0.8              | 57.6\u00b1 1.2                |\\n| SlowV AE      | 89.0\u00b1 1.9              | 71.8\u00b1 1.3                |\\n| PCL           | 95.8\u00b1 0.7              | 97.4\u00b1 1.3                |\\n| MLP           | 97.0\u00b1 0.5              | 90.5\u00b1 0.6                |\\n| CNN           | 99.8\u00b1 0.0              | 99.5\u00b1 0.0                |\\n| CoordConv     | 98.6\u00b1 0.5              | 97.4\u00b1 1.8                |\\n| Coordinate Based | 93.5\u00b1 0.6            | 91.7\u00b1 2.6                |\\n| Rotation-EQ   | 95.3\u00b1 0.6              | 94.8\u00b1 0.7                |\\n| Rotation-EQ-big | 99.9\u00b1 0.0            | 99.9\u00b1 0.0                |\\n| Spatial Transformer | 99.8\u00b1 0.0       | 99.6\u00b1 0.1                |\\n| RN50          | 100.0\u00b1 0.0             | 99.9\u00b1 0.1                |\\n| RN101         | 100.0\u00b1 0.0             | 99.8\u00b1 0.1                |\\n| DenseNet      | 100.0\u00b1 0.0             | 99.9\u00b1 0.0                |\"}"}
{"id": "9RUHPlladgh", "page_num": 7, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 5: Extrapolation and modularity, $R^2$-score on subsets. In the extrapolation setting, we further differentiate between factors that have been observed during training (ID factors) and extrapolated values (OOD factors) and measure the performances separately. As a reference, we compare to a random split. A model is considered modular, if it still infers ID factors correctly despite other factors being OOD.\\n\\nConclusion: The performance generally decreases when factors are OOD regardless of the supervision signal and architecture. However, we also observed exceptions in Shapes3D where OOD generalization was largely successful except for extrapolation.\\n\\n5.2 ERRORS STEM FROM INFERRING OOD FACTORS\\n\\nWhile in the previous section we observed a general decrease in $R^2$ score for the interpolation and extrapolation splits, our evaluation does not yet show how errors are distributed among individual factors that are in- and out-of-distribution. In contrast to the previous section where multiple factors could be OOD simultaneously, here, we control data splits (Fig. 2) interpolation, extrapolation s.t. only a single factor is OOD. Now, we also estimate the $R^2$-score separately per factor, depending on whether they have individually been observed during training (ID factor) or are exclusively in the test set (OOD factor). For instance, if we only have images of a heart with varying scale and position, we query the model with hearts at larger scales than observed during training (OOD factor), but at a previously observed position (ID factor). For a formal description, see Appendix H.2. This controlled setup enables us to investigate the modularity of the tested models, as we can separately measure the performance on OOD and ID factors. As a reference for an approximate upper bound, we additionally report the performance of the model on a random train/test split. In Figs. 5 and 14, we observe significant drops in performance for the OOD factors compared to a random test-train split. In contrast, for the ID factors, we see that the models still perform close to the random split, although with much larger variance. For the interpolation setting (Appendix Fig. 14), this drop is also observed for MPI3D and dSprites but not for Shapes3D. Here, OOD and ID are almost on par with the random split. Note that our notion of modularity is based on systematic splits of individual factors and the resulting outputs. Other works focus on the inner behavior of a model by, e.g., investigating the clustering of neurons within the network (Filan et al., 2021). Preliminary experiments showed no correlations between the different notions of modularity.\\n\\nConclusion: The tested models can be fairly modular, in the sense that the predictions of ID factors remain accurate. The low OOD performances mainly stem from incorrectly extrapolated or interpolated factors. Given the low inter-/extrapolation (i.e., OOD) performances on MPI3D and dSprites, evidently no model learned to invert the ground-truth generative mechanism.\\n\\n5.3 MODELS EXTRAPOLATE SIMILARLY AND TOWARDS THE MEAN\\n\\nIn the previous sections, we observed that our tested models specifically extrapolate poorly on OOD factors. Here, we focus on quantifying the behavior of how different models extrapolate. To check whether different models make similar errors, we compare the extrapolation behavior across architectures and seeds by measuring the similarity of model predictions for the OOD factors described in the previous section. No model is compared to itself if it has the same random\"}"}
{"id": "9RUHPlladgh", "page_num": 8, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 6: Extrapolation towards the mean. We calculate (2) on the extrapolated OOD factors to measure the closeness towards the mean compared to the ground-truth. Here, the values are mostly in \\\\([0,1]\\\\). Thus, models tend to predict values in previously observed ranges.\\n\\nWe find that models collectively tend towards predicting the mean for each factor in the training distribution when extrapolating. To show this, we estimate the following ratio of distances\\n\\n\\\\[ r = \\\\frac{|f(x_i) - \\\\bar{y}_j|}{|y_{ij} - \\\\bar{y}_j|}, \\\\]\\n\\n(2)\\n\\nwhere \\\\(\\\\bar{y}_j = \\\\frac{1}{n} \\\\sum_{i=1}^{n} y_{ij}\\\\) is the mean of FoV \\\\(y_j\\\\). If values of (2) are \\\\(\\\\in [0,1]\\\\), models predict values which are closer to the mean than the corresponding ground-truth. We show a histogram over all supervised and transfer-based models for each dataset in Fig. 6. Models tend towards predicting the mean as only few values are \\\\(>1\\\\). This is shown qualitatively in Appendix Figs. 15 and 16.\\n\\nConclusion: Overall, we observe only small differences in how the tested models extrapolate, but a strong difference compared to the ground-truth. Instead of extrapolating, all models regress the OOD factor towards the mean in the training set. We hope that this observation can be considered to develop more diverse future models.\\n\\n5.4 ON THE RELATION BETWEEN DISENTANGLEMENT AND DOWNSTREAM PERFORMANCE\\n\\nPrevious works have focused on the connection between disentanglement and OOD downstream performance (Tr\u00e4uble et al., 2020; Dittadi et al., 2020; Montero et al., 2021). Similarly, for our systematic splits, we measure the degree of disentanglement using the DCI-Disentanglement (Eastwood & Williams, 2018) score on the latent representation of the embedded test and train data. Subsequently, we correlate it with the \\\\(R^2\\\\)-performance of a supervised readout model which we report in \u00a75.1. Note that the simplicity of the readout function depends on the degree of disentanglement, e.g., for a perfect disentanglement up to permutation and sign flips this would just be an assignment problem. For the disentanglement models, we consider the un-/weakly supervised models \\\\(\\\\beta\\\\)-VAE (Higgins et al., 2017), SlowVAE (Klindt et al., 2020), Ada-GVAE (Locatello et al., 2020a) and PCL (Hyvarinen & Morioka, 2017).\\n\\nWe find that the degree of downstream performance correlates positively with the degree of disentanglement (Pearson \\\\(\\\\rho = 0.63\\\\), Spearman \\\\(\\\\rho = 0.67\\\\)). However, the correlations vary per dataset and split (see Appendix Fig. 7). Moreover, the overall performance of the disentanglement models followed by a supervised readout on the OOD split is lower compared to the supervised models (see e.g. Fig. 4). In an ablation study with an oracle embedding that disentangles the test data up to permutations and sign flips, we found perfect generalization capabilities (\\\\(R^2_{test} \\\\geq 0.99\\\\)).\\n\\nConclusion: Disentanglement models show no improved performance in OOD generalization. Nevertheless, we observe a mostly positive correlation between the degree of disentanglement and the downstream performance.\\n\\n6 OTHER RELATED BENCHMARK STUDIES\\n\\nIn this section, we focus on related benchmarks and their conclusions. For related work in the context of inductive biases, we refer to \u00a73.\\n\\nCorruption benchmarks: Other current benchmarks focus on the performance of models when adding common corruptions (denoted by -C) such as noise or snow to current dataset test sets,\"}"}
{"id": "9RUHPlladgh", "page_num": 9, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"resulting in ImageNet-C, CIFAR-10-C, Pascal-C, Coco-C, Cityscapes-C and MNIST-C (Hendrycks & Dietterich, 2019; Michaelis et al., 2019; Mu & Gilmer, 2019). In contrast, in our benchmark, we assure that the factors of variations are present in the training set and merely have to be generalized correctly. In addition, our focus lies on identifying the ground truth generative process and its underlying factors. Depending on the task, the requirements for a model are very different. E.g., the ImageNet-C classification benchmark requires spatial invariance, whereas regressing factors such as, e.g., shift and shape of an object, requires in- and equivariance.\\n\\nAbstract reasoning: Model performances on OOD generalizations are also intensively studied from the perspective of abstract reasoning, visual and relational reasoning tasks (Barrett et al., 2018; Wu et al., 2019; Santoro et al., 2017; Villalobos et al., 2020; Zhang et al., 2016; Yan & Zhou, 2017; Funke et al., 2021; Zhang et al., 2018). Most related, (Barrett et al., 2018; Wu et al., 2019) also study similar interpolation and extrapolation regimes. Despite using notably different tasks such as abstract or spatial reasoning, they arrive at similar conclusions: They also observe drops in performance in the generalization regime and that interpolation is, in general, easier than extrapolation, and also hint at the modularity of models using distractor symbols (Barrett et al., 2018). Lastly, posing the concept of using correct generalization as a necessary condition to check whether an underlying mechanism has been learned has also been proposed in (Wu et al., 2019; Zhang et al., 2018; Funke et al., 2021).\\n\\nDisentangled representation learning: Close to our work, Montero et al. (Montero et al., 2021) also study generalization in the context of extrapolation, interpolation and a weak form of composition on dSprites and Shapes3D, but not the more difficult MPI3D-Dataset. They focus on reconstructions of unsupervised disentanglement algorithms and thus the decoder, a task known to be theoretically impossible (Locatello et al., 2018). In their setup, they show that OOD generalization is limited. From their work, it remains unclear whether the generalization along known factors is a general problem in visual representation learning, and how neural networks fail to generalize. We try to fill these gaps. Moreover, we focus on representation learning approaches and thus on the encoder and consider a broader variety of models, including theoretically identifiable approaches (Ada-GA VE, SlowVAE, PCL), and provide a thorough in-depth analysis of how networks generalize.\\n\\nPreviously, Tr\u00e4uble et al. (2020) studied the behavior of unsupervised disentanglement models on correlated training data. They find that despite disentanglement objectives, the learned latent spaces mirror this correlation structure. In line with our work, the results of their supervised post-hoc regression models on Shapes3D suggest similar generalization performances as we see in our respective disentanglement models in Figs. 4 and 11. OOD generalization w.r.t. extrapolation of one single FoV is also analyzed in (Dittadi et al., 2020). Our experimental setup in \u00a75.4 is similar to their 'OOD2' scenario. Here, our results are in accordance, as we both find that the degree of disentanglement is lightly correlated with the downstream performance.\\n\\nOthers: To demonstrate shortcuts in neural networks, Eulig et al. (2021) introduce a benchmark with factors of variations such as color on MNIST that correlate with a specified task but control for those correlations during test-time. In the context of reinforcement learning, Packer et al. (2018) assess models on systematic test-train splits similar to our inter-/extrapolation and show that current models cannot solve this problem. For generative adversarial networks (GANs), it has also been shown that their learned representations do not extrapolate beyond the training data (Jahanian et al., 2019).\"}"}
{"id": "9RUHPlladgh", "page_num": 10, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"ACKNOWLEDGEMENTS\\n\\nThe authors thank Steffen Schneider, Matthias Tangemann and Thomas Brox for their valuable feedback and fruitful discussions. The authors would also like to thank David Klindt, Judy Borowski, Dylan Paiton, Milton Montero and Sudhanshu Mittal for their constructive criticism of the manuscript. The authors thank the International Max Planck Research School for Intelligent Systems (IMPRS-IS) for supporting FT and LS. We acknowledge support from the German Federal Ministry of Education and Research (BMBF) through the Competence Center for Machine Learning (TUE.AI, FKZ 01IS18039A) and the Bernstein Computational Neuroscience Program T\u00fcbingen (FKZ: 01GQ1002). WB acknowledges support via his Emmy Noether Research Group funded by the German Science Foundation (DFG) under grant no. BR 6382/1-1 as well as support by Open Philanthropy and the Good Ventures Foundation. MB and WB acknowledge funding from the MICrONS program of the Advanced Research Projects Activity (IARPA) via Department of Interior/Interior Business Center (DoI/IBC) contract number D16PC00003.\"}"}
{"id": "9RUHPlladgh", "page_num": 15, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":null}"}
{"id": "9RUHPlladgh", "page_num": 16, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":null}"}
{"id": "9RUHPlladgh", "page_num": 17, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Our current study focuses on basic research and has no direct application or societal impact. Nevertheless, we think that the broader topic of generalization should be treated with great care. Especially oversimplified generalization and automation without a human in the loop could have drastic consequences in safety critical environments or court rulings.\\n\\nLarge-scale studies require a lot of compute due to multiple random seeds and exponentially growing sets of possible hyperparameter combinations. Following claims by Strubell et al. (Strubell et al., 2019), we tried to avoid redundant computations by orienting ourselves on current common values in the literature and by relying on systematic test runs. In a naive attempt, we tried to estimate the power consumption and greenhouse gas impact based on the used cloud compute instance. However, too many factors such as external thermal conditions, actual workload, type of power used and others are involved (Mytton, 2020; Fahad et al., 2019). In the future, especially with the trend towards larger network architectures, compute clusters should be required to enable options which report the estimated environmental impact. However, it should be noted that cloud vendors are already among the largest purchasers of renewable electricity (Mytton, 2020).\\n\\nFor an impact statement for the broader field of representation learning, we refer to Klindt et al. (2020).\"}"}
{"id": "9RUHPlladgh", "page_num": 18, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 1: Performances of the readout-MLP on the ground-truth.\\n\\n| Data set  | Modification | R-squared | Test  |\\n|-----------|--------------|-----------|-------|\\n| dSprites  | random       | 1.000     |       |\\n|           | random + sign-flip | 1.000     |       |\\n|           | composition  | 1.000     |       |\\n|           | composition + sign-flip | 1.000     |       |\\n|           | interpolation | 1.000     |       |\\n|           | interpolation + sign-flip | 1.000     |       |\\n|           | extrapolation | 1.000     |       |\\n|           | extrapolation + sign-flip | 1.000     |       |\\n| Shapes3D  | random       | 1.000     |       |\\n|           | random + sign-flip | 1.000     |       |\\n|           | composition  | 1.000     |       |\\n|           | composition + sign-flip | 1.000     |       |\\n|           | interpolation | 1.000     |       |\\n|           | interpolation + sign-flip | 1.000     |       |\\n|           | extrapolation | 1.000     |       |\\n|           | extrapolation + sign-flip | 1.000     |       |\\n| MPI3D-Real| random       | 1.000     |       |\\n|           | random + sign-flip | 1.000     |       |\\n|           | composition  | 1.000     |       |\\n|           | composition + sign-flip | 0.996     |       |\\n|           | interpolation | 1.000     |       |\\n|           | interpolation + sign-flip | 1.000     |       |\\n|           | extrapolation | 0.999     |       |\\n|           | extrapolation + sign-flip | 0.997     |       |\\n\\nFigure 7: Spearman Correlation of degree of disentanglement with downstream performances. We measure the DCI-Disentanglement metric on the 10-dimensional representation for $\\\\beta$-VAE, PCL, SlowVAE, and Ada-GVAE and the corresponding $R^2$-score on the downstream performance. All p-values are below 0.01 except for composition on Shapes3D which has p-value=0.14. Note that, we here provide Spearman's rank correlation instead Pearson as the p-values are slightly lower.\\n\\nHere, we narrow down the root cause of the limited extrapolation performance of disentanglement models in the OOD settings as observed in Figs. 4 and 11. More precisely, we investigate how the readout-MLP would perform on a perfectly disentangled representation. Therefore, we train our readout MLP directly on the ground-truth factors of variation for all possible test-train splits described in Fig. 2 and measured the $R^2$-score test error for each split. Here, the MLP only has to learn the identity function. In a slightly more evolved setting, termed sign-flip, we switched the sign input to train the readout-MLP on a mapping from -ground-truth to ground-truth. This mimics the identifiability guarantees of models like SlowVAE which are up to permutation and sign flips under certain assumptions. The $R$-squared for all settings in Table 1 are >.99, therefore the readout model should not be the limitation for OOD generalization in our setting if the representation is identified up to permutation and sign flips. Note that this experiment does not cover disentanglement up to point-wise nonlinearities or linear/affine transformations as required by other models.\\n\\nThe current disentanglement datasets such as dSprites, Shapes3D, MPI3D, and others are constructed based on highly controlled environments (Matthey et al., 2017; Kim & Mnih, 2018; Gondal et al., 2019). Here, common factors of variations are rotations or scaling of simple geometric objects, such as a square. For a more intuitive investigation of other factors, we created the CelebGlow dataset. Here, the factors of variations are smiling, blondness and age. Samples are shown in Fig. 8. Note that we rely on the Glow model instead of taking a real-world dataset, as this allows for a gradual control of individual factors of variation.\"}"}
{"id": "9RUHPlladgh", "page_num": 11, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"References\\n\\nPanos Achlioptas, Olga Diamanti, Ioannis Mitliagkas, and Leonidas Guibas. Learning representations and generative models for 3D point clouds. In International Conference on Machine Learning, pp. 40\u201349. PMLR, 2018.\\n\\nMartin Arjovsky, L\u00e9on Bottou, Ishaan Gulrajani, and David Lopez-Paz. Invariant risk minimization. arXiv preprint arXiv:1907.02893, 2019.\\n\\nAharon Azulay and Yair Weiss. Why do deep convolutional networks generalize so poorly to small image transformations? Journal of Machine Learning Research, 20(184):1\u201325, 2019.\\n\\nAndrei Barbu, David Mayo, Julian Alverio, William Luo, Christopher Wang, Dan Gutfreund, Josh Tenenbaum, and Boris Katz. ObjectNet: A large-scale bias-controlled dataset for pushing the limits of object recognition models. In Advances in Neural Information Processing Systems, pp. 9448\u20139458, 2019.\\n\\nElias Bareinboim and Judea Pearl. Controlling selection bias in causal inference. In Artificial Intelligence and Statistics, pp. 100\u2013108. PMLR, 2012.\\n\\nElias Bareinboim and Judea Pearl. Causal inference and the data-fusion problem. Proceedings of the National Academy of Sciences, 113(27):7345\u20137352, 2016.\\n\\nDavid Barrett, Felix Hill, Adam Santoro, Ari Morcos, and Timothy Lillicrap. Measuring abstract reasoning in neural networks. In International Conference on Machine Learning, pp. 511\u2013520. PMLR, 2018.\\n\\nPeter W Battaglia, Jessica B Hamrick, and Joshua B Tenenbaum. Simulation as an engine of physical scene understanding. Proceedings of the National Academy of Sciences, 110(45):18327\u201318332, 2013.\\n\\nYoshua Bengio, Aaron Courville, and Pascal Vincent. Representation learning: A review and new perspectives. IEEE Transactions on Pattern Analysis and Machine Intelligence, 35(8):1798\u20131828, 2013.\\n\\nM. Besserve, R. Sun, D. Janzing, and B. Sch\u00f6lkopf. A theory of independent mechanisms for extrapolation in generative models. In 35th AAAI Conference on Artificial Intelligence: A Virtual Conference, 2021.\\n\\nChristopher P Burgess, Irina Higgins, Arka Pal, Loic Matthey, Nick Watters, Guillaume Desjardins, and Alexander Lerchner. Understanding disentangling in \u03b2-VAE. arXiv preprint arXiv:1804.03599, 2018.\\n\\nRicky TQ Chen, Xuezhen Li, Roger Grosse, and David Duvenaud. Isolating sources of disentanglement in VAEs. In Proceedings of the 32nd International Conference on Neural Information Processing Systems, pp. 2615\u20132625, 2018.\\n\\nTaco Cohen and Max Welling. Group equivariant convolutional networks. In International Conference on Machine Learning, pp. 2990\u20132999. PMLR, 2016.\\n\\nTaco Cohen, Maurice Weiler, Berkay Kicanaoglu, and Max Welling. Gauge equivariant convolutional networks and the icosahedral CNN. In International Conference on Machine Learning, pp. 1321\u20131330. PMLR, 2019.\\n\\nPierre Comon. Independent component analysis, a new concept? Signal Processing, 36(3):287\u2013314, 1994.\\n\\nR\u00f3bert Csord\u00e1s, Sjoerd van Steenkiste, and J\u00fcrgen Schmidhuber. Are neural nets modular? inspecting functional modularity through differentiable weight masks. In International Conference on Learning Representations, 2021. URL https://openreview.net/forum?id=7uVcpu-gMD.\\n\\nAlexander D'Amour, Katherine Heller, Dan Moldovan, Ben Adlam, Babak Alipanahi, Alex Beutel, Christina Chen, Jonathan Deaton, Jacob Eisenstein, Matthew D Hoffman, et al. Underspecification presents challenges for credibility in modern machine learning. arXiv preprint arXiv:2011.03395, 2020.\\n\\nStanislas Dehaene. How We Learn: Why Brains Learn Better Than Any Machine... for Now. Penguin, 2020.\\n\\nJia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. ImageNet: A large-scale hierarchical image database. In 2009 IEEE Conference on Computer Vision and Pattern Recognition, pp. 248\u2013255. IEEE, 2009.\\n\\nAndrea Dittadi, Frederik Tr\u00e4uble, Francesco Locatello, Manuel W\u00fcthrich, Vaibhav Agrawal, Ole Winther, Stefan Bauer, and Bernhard Sch\u00f6lkopf. On the transfer of disentangled representations in realistic settings. arXiv preprint arXiv:2010.14407, 2020.\\n\\nCian Eastwood and Christopher KI Williams. A framework for the quantitative evaluation of disentangled representations. In In International Conference on Learning Representations, 2018.\"}"}
{"id": "9RUHPlladgh", "page_num": 12, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":null}"}
{"id": "9RUHPlladgh", "page_num": 13, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":null}"}
{"id": "9RUHPlladgh", "page_num": 14, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":null}"}
{"id": "9RUHPlladgh", "page_num": 1, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"An important component for generalization in machine learning is to uncover underlying latent factors of variation as well as the mechanism through which each factor acts in the world. In this paper, we test whether 17 unsupervised, weakly supervised, and fully supervised representation learning approaches correctly infer the generative factors of variation in simple datasets (dSprites, Shapes3D, MPI3D) from controlled environments, and on our contributed CelebGlow dataset. In contrast to prior robustness work that introduces novel factors of variation during test time, such as blur or other (un)structured noise, we here recompose, interpolate, or extrapolate only existing factors of variation from the training data set (e.g., small and medium-sized objects during training and large objects during testing). Models that learn the correct mechanism should be able to generalize to this benchmark. In total, we train and test 2000+ models and observe that all of them struggle to learn the underlying mechanism regardless of supervision signal and architectural bias. Moreover, the generalization capabilities of all tested models drop significantly as we move from artificial datasets towards more realistic real-world datasets. Despite their inability to identify the correct mechanism, the models are quite modular as their ability to infer other in-distribution factors remains fairly stable, providing only a single factor is out-of-distribution. These results point to an important yet understudied problem of learning mechanistic models of observations that can facilitate generalization.\\n\\nINTRODUCTION\\n\\nHumans excel at learning underlying physical mechanisms or inner workings of a system from observations (Funke et al., 2021; Barrett et al., 2018; Santoro et al., 2017; Villalobos et al., 2020; Spelke, 1990), which helps them generalize quickly to new situations and to learn efficiently from little data (Battaglia et al., 2013; Dehaene, 2020; Lake et al., 2017; T\u00e9gl\u00e1s et al., 2011). In contrast, machine learning systems typically require large amounts of curated data and still mostly fail to generalize to out-of-distribution (OOD) scenarios (Sch\u00f6lkopf et al., 2021; Hendrycks & Dietterich, 2019; Karahan et al., 2016; Michaelis et al., 2019; Roy et al., 2018; Azulay & Weiss, 2019; Barbu et al., 2019). It has been hypothesized that this failure of machine learning systems is due to shortcut learning (Kilbertus* et al., 2018; Ilyas et al., 2019; Geirhos et al., 2020; Sch\u00f6lkopf et al., 2021). In essence, machines seemingly learn to solve the tasks they have been trained on using auxiliary and spurious statistical relationships in the data, rather than true mechanistic relationships. Pragmatically, models relying on statistical relationships tend to fail if tested outside their training distribution, while models relying on (approximately) the true underlying mechanisms tend to generalize well to novel scenarios (Barrett et al., 2018; Funke et al., 2021; Wu et al., 2019; Zhang et al., 2018; Parascandolo et al., 2018; Sch\u00f6lkopf et al., 2021; Locatello et al., 2020a;b). To learn effective statistical relationships, the training data needs to cover most combinations of factors of variation (like shape, size, color, viewpoint, etc.). Unfortunately, the number of combinations scales exponentially with the number of factors. In contrast, learning the underlying mechanisms behind the factors of variation should greatly reduce the need for training data and scale more gently with the number of factors (Sch\u00f6lkopf et al., 2021; Peters et al., 2017; Besserve et al., 2021).\\n\\nBenchmark:\\n\\nOur goal is to quantify how well machine learning models already learn the mechanisms underlying a data generative process. To this end, we consider four image data sets where each image is described by a small number of independently controllable factors of variation such as shape, size, color, viewpoint, etc.\"}"}
{"id": "9RUHPlladgh", "page_num": 2, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"as scale, color, or size. We split the training and test data such that models that learned the under-\\nly mechanisms should generalize to the test data. More precisely, we propose several systematic\\nout-of-distribution (OOD) test splits like composition (e.g., \\\\( \\\\text{train} = \\\\text{small hearts, large squares} \\\\rightarrow \\\\text{test} = \\\\text{small squares, large hearts} \\\\)), interpolation (e.g., \\\\( \\\\text{small hearts, large hearts} \\\\rightarrow \\\\text{medium hearts} \\\\)) and extrapolation (e.g., \\\\( \\\\text{small hearts, medium hearts} \\\\rightarrow \\\\text{large hearts} \\\\)). While the factors of variation\\nare independently controllable (e.g., there may exist large and small hearts), the observations may\\nexhibit spurious statistical dependencies (e.g., observed hearts are typically small, but size may not\\nbe predictive at test time). Based on this setup, we benchmark 17 representation learning approaches\\nand study their inductive biases. The considered approaches stem from un-/weakly supervised dis-\\nentanglement, supervised learning, and the transfer learning literature.\\n\\nResults:\\nOur benchmark results indicate that the tested models mostly struggle to learn the under-\\ly mechanisms regardless of supervision signal and architecture. As soon as a factor of variation\\nis outside the training distribution, models consistently tend to predict a value in the previously ob-\\nserved range. On the other hand, these models can be fairly modular in the sense that predictions\\nof in-distribution factors remain accurate, which is in part against common criticisms of deep neural\\nnetworks (Greff et al., 2020; Csord\u00e1s et al., 2021; Marcus, 2018; Lake & Baroni, 2018).\\n\\nNew Dataset:\\nPrevious datasets with independent controllable factors such as dSprites, Shapes3D,\\nand MPI3D (Matthey et al., 2017; Kim & Mnih, 2018; Gondal et al., 2019) stem from highly struc-\\ntured environments. For these datasets, common factors of variations are scaling, rotation and simple\\ngeometrical shapes. We introduce a dataset derived from celebrity faces, named CelebGlow, with\\nfactors of variations such as smiling, age and hair-color. It also contains all possible factor com-\\nbinations. It is based on latent traversals of a pretrained Glow network provided by Kingma et al.\\n(Kingma & Dhariwal, 2018) and the Celeb-HQ dataset (Liu et al., 2015).\\n\\nWe hope that this benchmark can guide future efforts to find machine learning models capable of\\nunderstanding the true underlying mechanisms in the data. To this end, all data sets and evaluation\\nscripts are released alongside a leaderboard on GitHub.\\n\\n1\\n\\nPROBLEM SETTING\\n\\nAssume that we render each observation or image \\\\( x \\\\in \\\\mathbb{R}^d \\\\) using a\\n\u201ccomputer graphic model\u201d which takes as input a set of indepen-\\ndently controllable factors of variation (FoVs) \\\\( y \\\\in \\\\mathbb{R}^n \\\\) like size or\\n\\\\( \\\\text{color} \\\\). More formally, we assume a generative process of the form\\n\\\\( x = g(y) \\\\), where \\\\( g: \\\\mathbb{R}^n \\\\rightarrow \\\\mathbb{R}^d \\\\) is an injective and smooth function.\\n\\nIn the standard independently and identically distributed (IID) setting,\\nwe would generate the training and test data in the same way, i.e., we\\nwould draw \\\\( y \\\\) from the same prior distribution \\\\( p(y) \\\\) and then gener-\\nate the corresponding images \\\\( x \\\\) according to \\\\( g(\\\\cdot) \\\\). Instead, we here\\nconsider an OOD setting where the prior distribution \\\\( p_{\\\\text{tr}}(y) \\\\) during\\ntraining is different from the prior distribution \\\\( p_{\\\\text{te}}(y) \\\\) during testing.\\nIn fact, in all settings of our benchmark, the training and test distributions are completely disjoint,\\nmeaning that each point can only have non-zero probability mass in either\\n\\\\( p_{\\\\text{tr}}(y) \\\\) or \\\\( p_{\\\\text{te}}(y) \\\\). Cru-\\nially, however, the function \\\\( g \\\\) which maps between FoVs and observations is shared between train-\\ning and testing, which is why we refer to it as an\\ninvariant mechanism. As shown in the causal\\ngraphical model in Fig. 1, the factors of variations\\n\\\\( y \\\\) are independently controllable to begin with,\\nbut the binary split variable \\\\( s \\\\) introduces spurious correlations between the FoVs that are different\\nat training and test time as a result of selection bias (Storkey, 2009; Bareinboim & Pearl, 2012). In\\nparticular, we consider Random, Composition, Interpolation, and Extrapolation splits as illustrated\\nin Fig. 2. We refer to \u00a74.2 for details on the implementation of these splits.\\n\\nThe task for our machine learning models \\\\( f \\\\) is to estimate the factors of variations\\n\\\\( y \\\\) that generated\\nthe sample \\\\( x \\\\) on both the training and test data. In other words, we want that (ideally)\\n\\\\( f = g^{-1} \\\\).\\n\\nThe main challenge is that, during training, we only observe data from\\n\\\\( p_{\\\\text{tr}} \\\\) but wish to general-\\nize to \\\\( p_{\\\\text{te}} \\\\). Hence, the learned function \\\\( f \\\\) should not only invert\\n\\\\( g \\\\) locally on the training domain\\n\\\\( \\\\text{supp}(p_{\\\\text{tr}}(y)) \\\\subseteq \\\\mathbb{R}^n \\\\) but ideally globally. In practice, let\\n\\\\( D_{\\\\text{te}} = \\\\{(y_k, x_k)\\\\} \\\\) be the test data with\\n\\\\( y_k \\\\) drawn from \\\\( p_{\\\\text{te}}(y) \\\\) and let\\n\\\\( f: \\\\mathbb{R}^d \\\\rightarrow \\\\mathbb{R}^n \\\\) be the model. Now, the goal is to design and optimize the\\n\\nhttps://github.com/bethgelab/InDomainGeneralizationBenchmark\"}"}
{"id": "9RUHPlladgh", "page_num": 23, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2022\\n\\nis defined to be exclusively in the test set, the corresponding image is part of the test set. E.g. for the extrapolation case in dSprites, all images containing x-positions > 24 are part of the test set and the train set its respective complement $D_{\\\\text{test}}$. Composition can be defined equivalently to extrapolation but with interchanged test and train sets. The details of the splits are provided in Table 2 and 3. The resulting train vs. test sample number ratios are roughly 30 : 70. See Table 4. We will release the test and train splits to allow for a fair comparison and benchmarking for future work.\\n\\nFor the setting where only a single factor is OOD, we formally define this as $D_{\\\\text{one-ood}} = \\\\{ (y_{k}, x_{k}) \\\\in D_{\\\\text{test}} | \\\\exists ! i \\\\in N_{s}: y_{ki} \\\\neq y_{li} \\\\forall (y_{li}, x_{li}) \\\\in D_{\\\\text{tr}} \\\\}$. (3)\\n\\nHere, we used the superscript indices to refer to a sample and the subscript to denote the factor. Note that the defined set is only nonempty in the interpolation and extrapolation settings.\\n\\n### H.3 TRAINING\\n\\nAll models are implemented using PyTorch 1.7. If not specified otherwise, the hyperparameters correspond to the default library values.\\n\\nUn-/ weakly supervised\\n\\nFor the un-/weakly supervised models, we consider 10 random seeds per hyperparameter setup. As hyperparameters, we optimize one parameter of the learning objective per model similar to Table 2 from Locatello et al. (Locatello et al., 2020a). For the SlowVAE, we took the optimal values from Klindt et al. (Klindt et al., 2020) and tuned for $\\\\gamma \\\\in \\\\{1, 5, 10, 15, 20, 25\\\\}$. The PCL model itself does not have any hyperparameters (Hyvarinen & Morioka, 2017). For simplicity, we determine the optimal setup in a supervised manner by measuring the DCI-Disentanglement score (Eastwood & Williams, 2018) on the training split. The PCL and SlowVAE models are trained on pairs of images that only differ sparsely in their underlying factors of variation following a Laplace transition distribution, the details correspond to the implementation of Klindt et al. (Klindt et al., 2020). The Ada-GVAE models are trained on pairs of images that differ uniformly in a single, randomly selected factor. Other factors are kept fixed. This matches the strongest model from Locatello et al. (Locatello et al., 2020a) implemented on GitHub. All $\\\\beta$-VAE models are trained in an unsupervised manner. All un- and weakly supervised models are trained with the Adam optimizer with a learning rate of $0.0001$. We train each model for 500,000 iterations with a batch size of 64, which for the weakly supervised models, corresponds to 64 pairs. Lastly, we train a supervised readout model on top of the latents for 8 epochs with the Adam optimizer on the full corresponding training dataset and observe convergence on the training and test datasets - no overfitting was observed.\\n\\nFully supervised:\\n\\nAll fully supervised models are trained with the same training scheme. We use the Adam optimizer with a learning rate of 0.0005. The only exception is DenseNet, which is trained with a learning rate of $0.0001$, as we observe divergences on the training loss with the higher learning rate. We train each model with three random seeds for 500,000 iterations with a batch size of $b = 64$. As a loss function, we consider the mean squared error $\\\\text{MSE} = \\\\frac{1}{b} \\\\sum_{j=0}^{b} ||y_j - f_j(x_j)||^2$ per mini-batch.\\n\\nTransfer learning:\\n\\nThe pre-trained models are fine-tuned with the same loss as the fully supervised models. We train for 50,000 iterations and with a lower learning rate of $0.0001$. We fine-tune all model weights. As an ablation, we also tried only training the last layer while freezing the other weights. In this setting, we consistently observed worse results and, therefore, do not include them in this paper.\\n\\n### H.4 MODEL IMPLEMENTATIONS\\n\\nHere, we shortly describe the implementation details required to reproduce our model implementation. We denote code from Python libraries in grey. If not specified otherwise, the default parameters and nomenclature correspond to the PyTorch 1.7 library.\\n\\n5 https://github.com/bethgelab/slow_disentanglement/blob/master/scripts/dataset.py#L94\\n\\n6 https://github.com/google-research/disentanglement_lib/blob/master/disentanglement_lib/methods/weak/weak_vae.py#L62 and https://github.com/google-research/disentanglement_lib/blob/master/disentanglement_lib/methods/weak/weak_vae.py#L317\"}"}
{"id": "9RUHPlladgh", "page_num": 24, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 2: Interpolation and extrapolation splits.\"}"}
{"id": "9RUHPlladgh", "page_num": 25, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 3: Composition splits.\\n\\n| Dataset Split   | % Test | % Train | Total Samples |\\n|-----------------|--------|---------|---------------|\\n| dSprites random | 32.6   | 67.4    | 737280        |\\n| dSprites composition | 26.1  | 73.9    | 737280        |\\n| dSprites interpolation | 32.6 | 67.4    | 737280        |\\n| dSprites extrapolation | 32.6 | 67.4    | 737280        |\\n| Shapes3D random | 30.7   | 69.3    | 480000        |\\n| Shapes3D composition | 32.0 | 68.0    | 480000        |\\n| Shapes3D interpolation | 30.7 | 69.3    | 480000        |\\n| Shapes3D extrapolation | 30.7 | 69.3    | 480000        |\\n| MPI3D random    | 30.0   | 70.0    | 1036800       |\\n| MPI3D composition | 27.8  | 72.2    | 1036800       |\\n| MPI3D interpolation | 30.0 | 70.0    | 1036800       |\\n| MPI3D extrapolation | 30.0 | 70.0    | 1036800       |\\n\\nTable 4: Test train ratio.\\n\\n| Dataset Split | % Test | % Train |\\n|---------------|--------|---------|\\n| dSprites      |        |         |\\n| Shapes3D      |        |         |\\n| MPI3D         |        |         |\"}"}
{"id": "9RUHPlladgh", "page_num": 26, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"The un- and weakly supervised models $\\\\beta$-VAE, Ada-GV AE and SlowVAE all use the same encoder-decoder architecture as Locatello et al. (Locatello et al., 2020a). The PCL model uses the same architecture as the encoder as well and with the same readout structure for the contrastive loss as used by Hyv\u00e4rinen et al. (Hyvarinen & Morioka, 2017). For the supervised readout MLP, we use the sequential model $\\\\text{[Linear}(10, 40), \\\\text{ReLU}(), \\\\text{Linear}(40, 40), \\\\text{ReLU}(40, 40), \\\\text{Linear}(40, \\\\text{num}\\\\_\\\\text{ factors})]$.\\n\\nThe MLP model consists of $\\\\text{[Linear}(64*64*\\\\text{num}\\\\_\\\\text{channels}, 90), \\\\text{ReLU}(), \\\\text{Linear}(90, 90), \\\\text{ReLU}(), \\\\text{Linear}(90, 90), \\\\text{ReLU}(), \\\\text{Linear}(90, 45), \\\\text{ReLU}(), \\\\text{Linear}(22, \\\\text{num}\\\\_\\\\text{ factors})]$.\\n\\nThe architecture is chosen such that it has roughly the same number of parameters and layers as the CNN.\\n\\nThe CNN architecture corresponds the one used by Locatello et al. (Locatello et al., 2020a). We only adjust the number of outputs to match the corresponding datasets.\\n\\nThe CoordConv consists of a $\\\\text{CoordConv2D}$ layer following the PyTorch implementation with 16 output channels. It is followed by 5 ReLU-Conv layers with 16 in- and output channels each and a MaxPool2D layer. The final readout consists of $\\\\text{[Linear}(32, 32), \\\\text{ReLU}(), \\\\text{Linear}(32, \\\\text{num}\\\\_\\\\text{ factors})]$.\\n\\nThe SetEncoder concatenates each input pixel with its $i,j$ pixel coordinates normalized to $[0, 1]$. All concatenated pixels $(i, j, \\\\text{pixel-value})$ are subsequently processed with the same network which consists of $\\\\text{[Linear}(2+\\\\text{num}\\\\_\\\\text{ channels}), \\\\text{ReLU}(), \\\\text{Linear}(40, 40), \\\\text{ReLU}(), \\\\text{Linear}(40, 20), \\\\text{ReLU}()$]\\n\\nThis is followed by a mean pooling operation per image which guarantees an invariance over the order of the inputs, i.e. one could shuffle all inputs and the output would remain the same. As a readout, it follows a sequential fully connected network consisting of $\\\\text{[Linear}(20, 20), \\\\text{ReLU}(), \\\\text{Linear}(20, 20), \\\\text{ReLU}(), \\\\text{Linear}(20, \\\\text{num}\\\\_\\\\text{ factors})]$.\\n\\nThe rotationally equivariant network RotEQ is similar to the architecture from Locatello et al. (Locatello et al., 2020a). One difference is that it uses the $\\\\text{R2Conv}$ module from Weiler et al. (Weiler & Cesa, 2019) instead of the PyTorch Conv2d with an 8-fold rotational symmetry. We thus decrease the number of feature maps by a factor of 8, which roughly corresponds to the same computational complexity as the CNN. We provide a second version which does not decrease the number of feature maps and, thus, has the same number of trainable parameters as the CNN but a higher computational complexity. We refer to this version as RotEQ-big.\\n\\nTo implement the spatial transformer (STN) (Wu et al., 2019), we follow the PyTorch tutorial implementation which consists of two steps. In the first step, we estimate the parameters of a $(2, 3)$-shaped affine matrix using a sequential neural network with the following architecture\\n\\n$\\\\text{[Conv2d}(\\\\text{number\\\\_channels}, 8, \\\\text{kernel\\\\_size}=7), \\\\text{MaxPool2d}(2, \\\\text{stride}=2), \\\\text{ReLU}(), \\\\text{Conv2d}(8, 10, \\\\text{kernel\\\\_size}=5), \\\\text{MaxPool2d}(2, \\\\text{stride}=2), \\\\text{ReLU}(), \\\\text{Conv2d}(10, 10, \\\\text{kernel\\\\_size}=6), \\\\text{MaxPool2d}(2, \\\\text{stride}=2), \\\\text{ReLU}(), \\\\text{Linear}(10*3*3, 31), \\\\text{ReLU}(), \\\\text{Linear}(32, 3*2)]$.\\n\\nIn the second step, the input image is transformed by the estimated affine matrix and subsequently processed by a CNN which has the same architecture as the CNN described above.\\n\\nFor the transfer learning models ResNet50 (RN50) and ResNet101 (RN101) pretrained on ImageNet-21k (IN-21k), we use the big-transfer (Kolesnikov et al., 2020) implementation. For the RN50, we download the weights with the tag \\\"BiT-M-R50x1\\\", and for the RN101, we use the tag \\\"BiT-M-R101x3\\\". For the DenseNet trained on ImageNet-1k (IN-1k), we used the weights from densenet121. For all transfer learning methods, we replace the last layer of the pre-trained models with a randomly initialized linear layer which matches the number of outputs to the number of factors.\\n\\n7 https://github.com/walsvid/CoordConv\\n8 https://github.com/QUVA-Lab/e2cnn\\n9 https://pytorch.org/tutorials/intermediate/spatial_transformer_tutorial.html\\n10 https://colab.research.google.com/github/google-research/big_transfer/blob/master/colabs/big_transfer_pytorch.ipynb\"}"}
{"id": "9RUHPlladgh", "page_num": 3, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"model $f$ on the training set $D_{tr}$ such that it achieves a minimal R-squared distance between $y_k$ and $f(x_k)$ on the test set $D_{te}$.\\n\\nDuring training, models are allowed to sample the data from all non-zero probability regions $\\\\text{supp}(p_{tr}(y))$ in whatever way is optimal for its learning algorithm. This general formulation covers different scenarios and learning methods that could prove valuable for learning independent mechanisms. For example, supervised methods will sample an IID data set $D_{tr} = \\\\{(y_k, x_k)\\\\}$ with $y_k \\\\sim p_{tr}(y)$, while self-supervised methods might sample a data set of unlabeled image pairs $D_{tr} = \\\\{(x_k, \\\\tilde{x}_k)\\\\}$.\\n\\nWe aim to understand what inductive biases help on these OOD settings and how to best leverage the training data to learn representations that generalize.\\n\\n3. Inductive Biases for Generalization in Visual Representation Learning\\n\\nWe now explore different types of assumptions, or inductive biases, on the representational format ($\\\\S 3.1$), architecture ($\\\\S 3.2$), and dataset ($\\\\S 3.3$) which have been proposed and used in the past to facilitate generalization. Inductive inference and the generalization of empirical findings is a fundamental problem of science that has a long-standing history in many disciplines. Notable examples include Occam's razor, Solomonoff's inductive inference (Solomonoff, 1964), Kolmogorov complexity (Kolmogorov, 1998), the bias-variance-tradeoff (Kohavi et al., 1996; Von Luxburg & Sch\u00f6lkopf, 2011), and the no free lunch theorem (Wolpert, 1996; Wolpert & Macready, 1997). In the context of statistical learning, Vapnik and Chervonenkis (Vapnik & Chervonenkis, 1982; Vapnik, 1995) showed that generalizing from a sample to its population (i.e., IID generalization) requires restricting the capacity of the class of candidate functions\u2014a type of inductive bias. Since shifts between train and test distributions violate the IID assumption, however, statistical learning theory does not directly apply to our types of OOD generalization.\\n\\nOOD generalization across different (e.g., observational and experimental) conditions also bears connections to causal inference (Pearl, 2009; Peters et al., 2017; Hern\u00e1n & Robins, 2020). Typically, a causal graph encodes assumptions about the relation between different distributions and is used to decide how to \u201ctransport\u201d a learned model (Pearl & Bareinboim, 2011; Pearl et al., 2014; Bareinboim & Pearl, 2016; von K\u00fcgelgen et al., 2019). Other approaches aim to learn a model which leads to invariant prediction across multiple environments (Sch\u00f6lkopf et al., 2012; Peters et al., 2016; Heinze-Deml et al., 2018; Rojas-Carulla et al., 2018; Arjovsky et al., 2019; Lu et al., 2021). However, these methods either consider a small number of causally meaningful variables in combination with domain knowledge, or assume access to data from multiple environments. In our setting, on the other hand, we aim to learn from higher-dimensional observations and to generalize from a single training set to a different test environment.\\n\\nOur work focuses on OOD generalization in the context of visual representation learning, where deep learning has excelled over traditional learning approaches (Krizhevsky et al., 2012; LeCun et al., 2015; Schmidhuber, 2015; Goodfellow et al., 2016). In the following, we therefore concentrate on inductive biases specific to deep neural networks (Goyal & Bengio, 2020) on visual data. For details regarding specific objective functions, architectures, and training, we refer to the supplement.\"}"}
{"id": "9RUHPlladgh", "page_num": 4, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"1994; Hyv\u00e4rinen & Oja, 2000) and has also been studied under the term disentanglement (Bengio et al., 2013). Most recent approaches learn a deep generative model based on the variational auto-encoder (VAE) framework (Kingma & Welling, 2013; Rezende et al., 2014), typically by adding regularization terms to the objective which further encourage independence between latents (Higgins et al., 2017; Kim & Mnih, 2018; Chen et al., 2018; Kumar et al., 2018; Burgess et al., 2018).\\n\\nIt is well known that ICA/disentanglement is theoretically non-identifiable without additional assumptions or supervision (Hyv\u00e4rinen & Pajunen, 1999; Locatello et al., 2018). Recent work has thus focused on weakly supervised approaches which can provably identify the true independent latent factors (Hyv\u00e4rinen & Morioka, 2016; Hyvarinen & Morioka, 2017; Shu et al., 2019; Locatello et al., 2020a; Klindt et al., 2020; Khemakhem et al., 2020; Roeder et al., 2020). The general idea is to leverage additional information in the form of paired observations (\\\\(x_i, \\\\tilde{x}_i\\\\)) where \\\\(\\\\tilde{x}_i\\\\) is typically an auxiliary variable (e.g., an environment indicator or time-stamp) or a second view, i.e., \\\\(\\\\tilde{x}_i = g(\\\\tilde{y}_i)\\\\) with \\\\(\\\\tilde{y}_i \\\\sim p(\\\\tilde{y} | y_i)\\\\), where \\\\(y_i\\\\) are the FoVs of \\\\(x_i\\\\) and \\\\(p(\\\\tilde{y} | y_i)\\\\) depends on the method. We remark that such identifiability guarantees only hold for the training distribution (and given infinite data), and thus may break down once we move to a different distribution for testing. In practice, however, we hope that the identifiability of the representation translates to learning mechanisms that generalize.\\n\\nIn our study, we consider the popular \\\\(\\\\beta\\\\)-VAE (Higgins et al., 2017) as an unsupervised approach, as well as Ada-GV AE (Locatello et al., 2020a), Slow-V AE (Klindt et al., 2020) and PCL (Hyvarinen & Morioka, 2017) as weakly supervised disentanglement methods. First, we learn a representation \\\\(z \\\\in \\\\mathbb{R}^n\\\\) given only (pairs of) observations (i.e., without access to the FoVs) using an encoder \\\\(f_{\\\\text{enc}}: \\\\mathbb{R}^d \\\\rightarrow \\\\mathbb{R}^n\\\\). We then freeze the encoder (and thus the learned representation \\\\(z\\\\)) and train a multi-layer perceptron (MLP) \\\\(f_{\\\\text{MLP}}: \\\\mathbb{R}^n \\\\rightarrow \\\\mathbb{R}^n\\\\) to predict the FoVs \\\\(y\\\\) from \\\\(z\\\\) in a supervised way.\\n\\nThe learned inverse mechanism \\\\(f\\\\) in this case is thus given by \\\\(f = f_{\\\\text{MLP}} \\\\circ f_{\\\\text{enc}}\\\\).\\n\\n3.2 INDUCTIVE BIAS 2: ARCHITECTURAL (SUPERVISED LEARNING)\\n\\nThe physical world is governed by symmetries (Nother, 1915), and enforcing appropriate task-dependent symmetries in our function class may facilitate more efficient learning and generalization. The second type of inductive bias we consider thus regards properties of the learned regression function, which we refer to as architectural bias. Of central importance are the concepts of invariance (changes in input should not lead to changes in output) and equivariance (changes in input should lead to proportional changes in output). In vision tasks, for example, object localization exhibits equivariance to translation, whereas object classification exhibits invariance to translation. E.g., translating an object in an input image should lead to an equal shift in the predicted bounding box (equivariance), but should not affect the predicted object class (invariance).\\n\\nA famous example is the convolution operation which yields translation equivariance and forms the basis of convolutional neural networks (CNNs) (Le Cun et al., 1989; LeCun et al., 1989). Combined with a set operation such as pooling, CNNs then achieve translation invariance. More recently, the idea of building equivariance properties into neural architectures has also been successfully applied to more general transformations such as rotation and scale (Cohen & Welling, 2016; Cohen et al., 2019; Weiler & Cesa, 2019) or (coordinate) permutations (Zhang et al., 2019; Achlioptas et al., 2018). Other approaches consider affine transformations (Jaderberg et al., 2015), allow to trade off invariance vs dependence on coordinates (Liu et al., 2018), or use residual blocks and skip connections to promote feature re-use and facilitate more efficient gradient computation (He et al., 2016; Huang et al., 2017). While powerful in principle, a key challenge is that relevant equivariances for a given problem may be unknown a priori or hard to enforce architecturally. E.g., 3D rotational equivariance is not easily captured for 2D-projected images, as for the MPI3D data set.\\n\\nIn our study, we consider the following architectures: standard MLPs and CNNs, CoordConv (Liu et al., 2018) and coordinate-based (Sitzmann et al., 2020) nets, Rotationally-Equivariant (Rotation-EQ) CNNs (Cohen & Welling, 2016), Spatial Transformers (STN) (Jaderberg et al., 2015), ResNet (RN) 50 and 101 (He et al., 2016), and DenseNet (Huang et al., 2017). All networks \\\\(f\\\\) are trained to directly predict the FoVs \\\\(y \\\\approx f(x)\\\\) in a purely supervised fashion.\\n\\n3.3 INDUCTIVE BIAS 3: LEVERAGING ADDITIONAL DATA (TRANSFER LEARNING)\\n\\nThe physical world is modular: many patterns and structures reoccur across a variety of settings. Thus, the third and final type of inductive bias we consider is leveraging additional data through transfer learning. Especially in vision, it has been found that low-level features such as edges or\"}"}
{"id": "9RUHPlladgh", "page_num": 5, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"simple textures are consistently learned in the first layers of neural networks, which suggests their usefulness across a wide range of tasks (Sun et al., 2017). State-of-the-art approaches therefore often rely on pre-training on enormous image corpora prior to fine-tuning on data from the target task (Kolesnikov et al., 2020; Mahajan et al., 2018; Xie et al., 2020). The guiding intuition is that additional data helps to learn common features and symmetries and thus enables a more efficient use of the (typically small amount of) labeled training data. Leveraging additional data as an inductive bias is connected to the representational format \u00a73.1 as they are often combined during pre-training. In our study, we consider three pre-trained models: RN-50 and RN-101 pretrained on ImageNet-21k (Deng et al., 2009; Kolesnikov et al., 2020) and a DenseNet pretrained on ImageNet-1k (ILSVRC) (Russakovsky et al., 2015). We replace the last layer with a randomly initialized readout layer chosen to match the dimension of the FoVs of a given dataset and fine-tune the whole network for 50,000 iterations on the respective train splits.\\n\\n4 EXPERIMENTAL SETUP\\n\\n4.1 DATASETS\\n\\nWe consider datasets with images generated from a set of discrete Factors of Variation (FoVs) following a deterministic generative model. All selected datasets are designed such that all possible combinations of factors of variation are realized in a corresponding image. dSprites (Matthey et al., 2017), is composed of low resolution binary images of basic shapes with 5 FoVs: shape, scale, orientation, x-position, and y-position. Next, Shapes3D (Kim & Mnih, 2018), a popular dataset with 3D shapes in a room with 6 FoVs: floor, color, wall color, object color, object size, object type, and camera azimuth. Furthermore, with CelebGlow we introduce a novel dataset that has more natural factors of variations such as smiling, hair-color and age. For more details and samples, we refer to Appendix B. Lastly, we consider the challenging and realistic MPI3D (Gondal et al., 2019), which contains real images of physical 3D objects attached to a robotic finger generated with 7 FoVs: color, shape, size, height, background color, x-axis, and y-axis. For more details, we refer to Appendix H.1.\\n\\n4.2 SPLITS\\n\\nFor each of the above datasets, denoted by $D$, we create disjoint splits of train sets $D_{tr}$ and test sets $D_{te}$. We systematically construct the splits according to the underlying factors to evaluate different modalities of generalization, which we refer to as composition, interpolation, extrapolation, and random. See Fig. 2 for a visual presentation of such splits regarding two factors.\\n\\nComposition: We exclude all images from the train split if factors are located in a particular corner of the FoV hyper cube given by all FoVs. This means certain systematic combinations of FoVs are never seen during training even though the value of each factor is individually present in the train set. The related test split then represents images of which at least two factors resemble such an unseen composition of factor values, thus testing generalization w.r.t. composition.\\n\\nInterpolation: Within the range of values of each FoV, we periodically exclude values from the train split. The corresponding test split then represents images of which at least one factor takes one of the unseen factor values in between, thus testing generalization w.r.t. interpolation.\\n\\nExtrapolation: We exclude all combinations having factors with values above a certain label threshold from the train split. The corresponding test split then represents images with one or more extrapolated factor values, thus testing generalization w.r.t. extrapolation.\\n\\nRandom: Lastly, as a baseline to test our models performances across the full dataset in distribution, we cover the case of an IID sampled train and test set split from $D$. Compared to interpolation and extrapolation where factors are systematically excluded, here it is very likely that all individual factor values have been observed in a some combination.\\n\\nWe further control all considered splits and datasets such that $\\\\sim 30\\\\%$ of the available data is in the training set $D_{tr}$ and the remaining $\\\\sim 70\\\\%$ belong to the test set $D_{te}$. Lastly, we do not split along factors of variation if no intuitive order exists. Therefore, we do not split along the categorical variable shape and along the axis of factors where only two values are available.\"}"}
{"id": "9RUHPlladgh", "page_num": 6, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"4.3 EVALUATION\\n\\nTo benchmark the generalization capabilities, we compute the $R^2$-score, the coefficient of determination, on the respective test set. We define the $R^2$-score based on the MSE score per FoV $y_j$:\\n\\n$$R^2_i = 1 - \\\\frac{\\\\text{MSE}_i}{\\\\sigma^2_i},$$\\n\\nwhere $\\\\sigma^2_i$ is the variance per factor defined on the full dataset $D_{te}$. Under this score, $R^2_i = 1$ can be interpreted as perfect regression and prediction under the respective test set whereas $R^2_i = 0$ indicates random guessing with the MSE being identical to the variance per factor. For visualization purposes, we clip the $R^2$ to 0 if it is negative. We provide all unclipped values in the Appendix.\\n\\n5 EXPERIMENTS AND RESULTS\\n\\nOur goal is to investigate how different visual representation models perform on our proposed system of out-of-distribution (OOD) test sets. We consider un-/weakly supervised, fully supervised, and transfer learning models. We focus our conclusions on MPI3D-Real as it is the most realistic dataset. Further results on dSprites and Shapes3D are, however, mostly consistent.\\n\\nIn the first subsection, \u00a75.1, we investigate the overall model OOD performance. In Sections 5.2 and 5.3, we focus on a more in-depth error analysis by controlling the splits s.t. only a single factor is OOD during testing. Lastly, in \u00a75.4, we investigate the connection between the degree of disentanglement and downstream performance.\\n\\n5.1 MODEL PERFORMANCE DECREASES ON OOD TEST SPLITS\\n\\nIn Fig. 4 and Appendix Fig. 11, we plot the performance of each model across different generalization settings. Compared to the in-distribution (ID) setting (random), we observe large drops in performance when evaluating our OOD test sets on all considered datasets. This effect is most prominent on MPI3D-Real. Here, we further see that, on average, the performances seem to increase as we increase the supervision signal (comparing RN50, RN101, DenseNet with and without additional data on MPI3D). On CelebGlow, models also struggle to extrapolate. However, the results on composition and interpolation only drop slightly compared to the random split.\\n\\nFor Shapes3D (shown in the Appendix E), the OOD generalization is partially successful, especially in the composition and interpolation settings. We hypothesize that this is due to the dataset specific, fixed spatial composition of the images. For instance, with the object-centric positioning, the floor, wall and other factors are mostly at the same position within the images. Thus, they can reliably be inferred by only looking at a certain fixed spot in the image. In contrast, for MPI3D this is more difficult as, e.g., the robot finger has to be found to infer its tip color. Furthermore, the factors of variation in Shapes3D mostly consist of colors which are encoded within the same input dimensions.\"}"}

{"id": "VTF8yNQM66", "page_num": 34, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 26: We provide another example where Claude-2 solves the issue correctly and develops a solution similar to the gold patch. However, the gold patch solution is more cognizant of avoiding future potential issues that could be related to this code.\\n\\n| Setting                          |\\n|---------------------------------|\\n| **Model**: Claude 2 with Oracle retrieval |\\n| **Task Instance**: matplotlib |\\n| matplotlib-24362 |\\n\\n- Link to Issue: https://github.com/matplotlib/matplotlib/issues/24349\\n- Link to PR: https://github.com/matplotlib/matplotlib/pull/24362\\n\\n### Issue\\n\\n**[Bug]**: sharex and sharey don't accept 0 and 1 as bool values\\n\\n### Bug summary\\n\\nWhen using '0' or '1' in place of 'False' or 'True' in 'sharex' or 'sharex' arguments of 'pyplot.subplots' an error is raised.\\n\\n### Code for reproduction\\n\\n```python\\nimport matplotlib.pyplot as plt\\nfig, ax = plt.subplots(ncols=2, sharey=1)\\n```\\n\\n### Actual outcome\\n\\nWe get the following error:\\n\\n```\\nTraceback (most recent call last):\\n  File \"/***/matplotlib/lib/matplotlib/gridspec.py\", line 293, in subplots\\n    _api.check_in_list(['all', 'row', 'col', 'none'],\\n  File \"/***/matplotlib/lib/matplotlib/_api/__init__.py\", line 131, in check_in_list\\n    raise ValueError(msg)\\nValueError: 1 is not a valid value for sharey; supported values are 'all', 'row', 'col', 'none'\\n```\\n\\nUsing 'sharex' instead of 'sharey' produces the same error (albeit with the following warning: `UserWarning: sharex argument to subplots() was an integer. Did you intend to use subplot() (without 's')?`) but this is expected and not part of the present issue.\\n\\n### Expected outcome\\n\\nI expected values 1 and 0 to be understood as bool.\\n\\n---\\n\\n**Model Generated Patch**\\n\\n```\\ndiff --git a/lib/matplotlib/gridspec.py b/lib/matplotlib/gridspec.py\\nindex 06dd3f19f6..32ee7c306e 100644\\n--- a/lib/matplotlib/gridspec.py\\n+++ b/lib/matplotlib/gridspec.py\\n@@ -276,9 +276,9 @@\\nclass GridSpecBase:\\n    raise ValueError(\\\"GridSpec.subplots() only works for GridSpecs created with a parent figure\\\")\\n-\\n    if isinstance(sharex, bool):\\n    or sharex == 1\\n          sharex = \\\"all\\\"\\n```\\n\\n# This check was added because it is very easy to type 'subplots(1, 2, 1)' when 'subplot(1, 2, 1)' was intended.\"}"}
{"id": "VTF8yNQM66", "page_num": 35, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"def subplots(self, *, sharex=False, sharey=False, squeeze=True):\\n    if isinstance(sharex, bool):\\n        sharex = \\\"all\\\" if sharex else \\\"none\\\"\\n    if isinstance(sharey, bool):\\n        sharey = \\\"all\\\" if sharey else \\\"none\\\"\\n    # This check was added because it is very easy to type\\n    # 'subplots(1, 2, 1)' when 'subplot(1, 2, 1)' was intended.\\n    # In most cases, no error will ever occur, but mysterious behavior\\n    # will result because what was intended to be the subplot index is\\n    # instead treated as a bool for sharex. This check should go away\\n    # once sharex becomes kwonly.\\n    if isinstance(sharex, Integral):\\n        _api.warn_external(\\\"sharex argument to subplots() was an integer. Did you intend to use subplot() (without 's')?\\\")\\n        _api.check_in_list([\\\"all\\\", \\\"row\\\", \\\"col\\\", \\\"none\\\"], sharex=sharex, sharey=sharey)\"}"}
{"id": "VTF8yNQM66", "page_num": 36, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 27: In this example, we show an issue from astropy/astropy that Claude 2 does not solve correctly. The error is primarily due to the patch generation's attempt to directly solve the issue.\\n\\nSetting\\n- Model: Claude 2 with Oracle retrieval\\n- Task Instance: astropy\\n\\n- Link to Issue: https://github.com/astropy/astropy/issues/14363\\n- Link to PR: https://github.com/astropy/astropy/pull/14365\\n\\nIssue\\n\\n### Description\\n\\nascii.qdp assumes that commands in a QDP file are upper case, for example, for errors they must be \\\"READ SERR 1 2\\\" whereas QDP itself is not case sensitive and case use \\\"read serr 1 2\\\". As many QDP files are created by hand, the expectation that all commands be all-caps should be removed.\\n\\n### Expected behavior\\n\\nThe following qdp file should read into a 'Table' with errors, rather than crashing.\\n\\n```\\nread\\nserr 1 2\\n1 0.5 1 0.5\\n```  \\n\\n### How to Reproduce\\n\\nCreate a QDP file:\\n\\n```\\ncat > test.qdp\\nread\\nserr 1 2\\n1 0.5 1 0.5\\n<EOF>\\n```\\n\\n```python\\n>>> from astropy.table import Table\\n>>> Table.read('test.qdp', format='ascii.qdp')\\nWARNING: table_id not specified. Reading the first available table [astropy.io.ascii.qdp]\\nTraceback (most recent call last):\\n  ...raise ValueError(f'Unrecognized QDP line: {line}\\\"\\nValueError: Unrecognized QDP line: read serr 1 2\\n```\\n\\nRunning \\\"qdp test.qdp\\\" works just fine.\\n\\nModel Generated Patch\\n\\n```diff\\n--- a/astropy/io/ascii/qdp.py\\n+++ b/astropy/io/ascii/qdp.py\\n@@ -60,7 +60,7 @@\\n   ValueError: Unrecognized QDP line...\\n   \\n   _decimal_re = r\\\"[+-]?([+-]?\\\\d+(\\\\.[0-9]+)?)\\\\([eE]\\\\[+-\\\\]\\\\d]+)?\\\"\\n-  _command_re = r\\\"READ \\\\[TS\\\\]ERR\\\\s+([0-9]+)+\\\"\\n+  _command_re = r\\\"read \\\\[ts\\\\]err\\\\s+([0-9]+)+\\\"\\n\\n   sep = delimiter\\n   if delimiter is None:\\n```\"}"}
{"id": "VTF8yNQM66", "page_num": 37, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Gold Patch\\ndiff --git a/astropy/io/ascii/qdp.py b/astropy/io/ascii/qdp.py\\n--- a/astropy/io/ascii/qdp.py\\n+++ b/astropy/io/ascii/qdp.py\\n@@ -68,7 +68,7 @@\\ndef _line_type(line, delimiter=None):\\n    _new_re = rf\\\"NO({sep}NO)+\\\"\\n    _data_re = rf\\\"({_decimal_re}|NO|[-+]?nan)({sep}({_decimal_re}|NO|\\n    \\n    _type_re = rf\\\"\u02c6\\\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<\\ndata>{_data_re})?\\\\s*(\\\\!(?P<comment>.*))?\\\\s*$\\\"\\n-   _line_type_re = re.compile(_type_re)\\n+   _line_type_re = re.compile(_type_re, re.IGNORECASE)\\n    line = line.strip()\\n    if not line:\\n        return  # comment\\n@@ -306,7 +306,7 @@\\n    values = []\\n    for v in line.split(delimiter):\\n        if v == \\\"NO\\\":  # Remove this line\\n+        if v.upper() == \\\"NO\\\":  \\n        values.append(np.ma.masked)  \\n        else:\\n            # Understand if number is int or float\\nTests Fail to Pass\\nastropy/io/ascii/tests/test_qdp.py::test_roundtrip[True]\\nPass to Pass\\nastropy/io/ascii/tests/test_qdp.py::test_get_tables_from_qdp_file\\nastropy/io/ascii/tests/test_qdp.py::test_roundtrip[False]\\nastropy/io/ascii/tests/test_qdp.py::test_read_example\\nastropy/io/ascii/tests/test_qdp.py::test_roundtrip_example\\nastropy/io/ascii/tests/test_qdp.py::test_roundtrip_example_comma\\nastropy/io/ascii/tests/test_qdp.py::test_read_write_simple\\nastropy/io/ascii/tests/test_qdp.py::test_read_write_simple_specify_name\\nastropy/io/ascii/tests/test_qdp.py::test_get_lines_from_qdp\\nDiscussion.\\nThis issue requests a fix for handling QDP files; specifically, it asks for the expectation of the commands to be uppercase to be removed. In the model generated patch, the model locates the READ and ERR commands mentioned in the issue description in a regex pattern and edits it directly. However, within the same file, it is clear that the regex pattern is used in additional patterns, such as _type_re, and so a fix to the \\\"root\\\" regex pattern may not be appropriate. In addition, amidst multiple regex pattern variables, identifying the correct one to modify requires reasoning that can potentially be helped by execution. This error in this solution is reflected in the fact that it not only fails to pass the given unit tests, but also fails existing tests enforcing prior behavior.\"}"}
{"id": "VTF8yNQM66", "page_num": 42, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 30: Example of a SWE-Llama 13b generation that correctly solves a SWE-bench task instance.\\n\\nIn this example, the SWE-Llama generation is exactly the same as the solution.\\n\\n**Setting**\\n\\n- **Model**: SWE-Llama 13B with Oracle retrieval\\n- **Task Instance**: pydata\\n\\n- Link to Issue: https://github.com/pydata/xarray/pull/5130\\n- Link to PR: https://github.com/pydata/xarray/pull/5131\\n\\n**Issue**\\n\\nWhen displaying a DatasetGroupBy in an interactive Python session, the first line of output contains a trailing whitespace. The first example in the documentation demonstrate this:\\n\\n```python\\n>>> import xarray as xr, numpy as np\\n>>> ds = xr.Dataset(\\n...     {\"foo\": ((\"x\", \"y\"), np.random.rand(4, 3))},\\n...     coords={\"x\": [10, 20, 30, 40], \"letters\": (\"x\", list(\"abba\"))},\\n...     )\\n>>> ds.groupby(\"letters\")\\nDatasetGroupBy, grouped over 'letters'\\n2 groups with labels 'a', 'b'.\\n```\\n\\nThere is a trailing whitespace in the first line of output which is \\\"DatasetGroupBy, grouped over 'letters' \\\". This can be seen more clearly by converting the object to a string (note the whitespace before `n`):\\n\\n```python\\n>>> str(ds.groupby(\"letters\"))\\n\\\"DatasetGroupBy, grouped over 'letters' \\n2 groups with labels 'a', 'b'.\\\"\\n```\\n\\nWhile this isn't a problem in itself, it causes an issue for us because we use flake8 in continuous integration to verify that our code is correctly formatted.\\n\\n**Gold Patch**\\n\\n```python\\ndiff --git a/xarray/core/groupby.py b/xarray/core/groupby.py\\n--- a/xarray/core/groupby.py\\n+++ b/xarray/core/groupby.py\\n@@ -436,7 +436,7 @@\\n     def __iter__(self):\\n         return zip(self._unique_coord.values, self._iter_grouped())\\n\\n-    def __repr__(self):\\n-        return \"{}, grouped over {!r}\\n+    def __repr__(self):\\n+        return \"{}, grouped over {!r}\\n         {!r} groups with labels {!r}.\".\\n```\\n\\n**Model Generated Patch**\\n\\n```python\\ndiff --git a/xarray/core/groupby.py b/xarray/core/groupby.py\\n--- a/xarray/core/groupby.py\\n+++ b/xarray/core/groupby.py\\n@@ -436,7 +436,7 @@\\n     def __iter__(self):\\n         return zip(self._unique_coord.values, self._iter_grouped())\\n\\n-    def __repr__(self):\\n-        return \"{}, grouped over {!r}\\n+    def __repr__(self):\\n+        return \"{}, grouped over {!r}\\n         {!r} groups with labels {!r}.\".\\n```\"}"}
{"id": "VTF8yNQM66", "page_num": 43, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Tests Fail to Pass\\n\\nxarray/tests/test_groupby.py::test_groupby_repr[obj0-x]\\nxarray/tests/test_groupby.py::test_groupby_repr[obj0-y]\\nxarray/tests/test_groupby.py::test_groupby_repr[obj0-z]\\nxarray/tests/test_groupby.py::test_groupby_repr[obj0-month]\\nxarray/tests/test_groupby.py::test_groupby_repr[obj1-x]\\nxarray/tests/test_groupby.py::test_groupby_repr[obj1-y]\\nxarray/tests/test_groupby.py::test_groupby_repr[obj1-z]\\nxarray/tests/test_groupby.py::test_groupby_repr_datetime[obj0]\\nxarray/tests/test_groupby.py::test_groupby_repr_datetime[obj1]\\n\\nPass to Pass\\n\\nxarray/tests/test_groupby.py::test_consolidate_slices\\nxarray/tests/test_groupby.py::test_groupby_da_datetime\\nxarray/tests/test_groupby.py::test_groupby_duplicate_coordinate_labels\\nxarray/tests/test_groupby.py::test_groupby_input_mutation\\nxarray/tests/test_groupby.py::test_groupby_map_shrink_groups[obj0]\\n\\nAdditional Pass to Pass Tests omitted...\\n\\nDiscussion.\\nIn this problem, the model is asked to correct a trailing whitespace issue, and the issue shows a demonstration of the error that arises during usage, but does not explicitly point out the function to fix in the model. In the oracle retrieval setting, the model is given the xarray/core/groupby.py file to edit directly, but most locate the line to edit. In this situation, the model successfully reasons that in the interactive Python setting, the underlying function that is being invoked is actually the `repr` function. After locating the function, it must figure out where in the `return` statement the whitespace is located. At this point, the fix is quite evident, as there is an explicit space that the model removes. In this case, the model successfully passes all tests for verifying the correctness of this fix explicitly (10 fail to pass tests) while also maintaining the existing behavior of the file (16 pass to pass tests).\"}"}
{"id": "VTF8yNQM66", "page_num": 44, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 31: Example of a SWE-Llama 13b generation that correctly solves a SWE-bench task instance.\\n\\nIn this example, the SWE-Llama generation is different from the gold patch.\\n\\nSetting\\n\\n- Model: SWE-Llama 13B with Oracle retrieval\\n- Task Instance:\\n  - psf-requests-1724\\n  - Link to Issue: https://github.com/psf/requests/issues/1723\\n  - Link to PR: https://github.com/psf/requests/pull/1724\\n\\nIssue\\n\\nUnicode method names cause UnicodeDecodeError for some requests in Python 2.7. The following example works fine:\\n\\n```python\\nfiles = {u'file': open(u'/usr/bin/diff', u'rb')}\\nresponse = requests.request(method='POST', url=u'http://httpbin.org/post', files=files)\\n```\\n\\nBut the following example (using `method=u'POST'` instead of `method='POST'`) produces a UnicodeDecodeError:\\n\\n```python\\nfiles = {u'file': open(u'/usr/bin/diff', u'rb')}\\nresponse = requests.request(method=u'POST', url=u'http://httpbin.org/post', files=files)\\n```\\n\\nTraceback (most recent call last):\\n\\n```\\nFile .../Python.framework/Versions/2.7/.../.../.../.../.../.../.../...\\nmessage_body += message_body\\nUnicodeDecodeError: 'ascii' codec can't decode byte 0xcf in position 140: ordinal not in range(128)\\n```\\n\\nMy guess is that `u'POST'` is infecting the header with unicode when it should be a string. This is because `sessions.py:313` is simply:\\n\\n```python\\nreq.method = method.upper()\\n```\\n\\nGold Patch\\n\\n```diff\\ndiff --git a/requests/sessions.py b/requests/sessions.py\\n--- a/requests/sessions.py\\n+++ b/requests/sessions.py\\n@@ -12,7 +12,7 @@\\n from collections import Mapping\\n from datetime import datetime\\n-from .compat import cookielib, OrderedDict, [3 more omitted]\\n+from .compat import cookielib, OrderedDict, [3 omitted,\\n + builtin_str\\n from .cookies import cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar\\n from .models import Request, PreparedRequest\\n from .hooks import default_hooks, dispatch_hook\\n@@ -309,6 +309,9 @@\\n def request(self, method, url,\\n             params=None, **kwargs):\\n         if String, path to ssl client cert file\\n```\\n\\n```\\n+    method = builtin_str(method)\\n\\n44\\n```\"}"}
{"id": "VTF8yNQM66", "page_num": 45, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Discussion. Unlike the problem presented in Table 30, instead of an interactive python input, the model is given an error trace from a function invocation, where the steps to recreate the problem from a user's standpoint is offered. In addition, the issue also provides a suggestion during the last line on a potential fix for the problem. Once again in the oracle setting, the model takes advantage of the natural language suggestion and localizes the change to a line that is semantically quite similar to the suggestion (req.method = method.upper() compared to method = str(request.method).upper(). The model correctly addresses the issue, as reflected by all the passing tests. However, in this situation, we can see that the model is actually quite \u201clucky\u201d in its success. First, while the gold patch leverages built in functions that are used for uniformity in handling string formatting, the model\u2019s decision to use more primitive Python to tackle this issue would likely not be well-received by a human reviewer due to its inconsistency with the rest of the codebase. Further inspection of the builtin_str function, not shown in this figure, also reveals that it handles additional string formatting cases beyond what was portrayed in the issue. While the model solves the task this time, it is questionable whether this solution is robust to future issues.\"}"}
{"id": "VTF8yNQM66", "page_num": 46, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 32: This is another example where SWE-Llama13b solves the task successfully. This example is interesting because the model develops a somewhat novel solution compared to the reference that is arguably more efficient and cleaner.\\n\\nSetting\\n\u2022 Model: SWE-Llama 13B with Oracle retrieval\\n\u2022 Task Instance: django\\ndjango-11727\\n\u2013 Link to Issue: https://code.djangoproject.com/ticket/29376\\n\u2013 Link to PR: https://github.com/django/django/pull/11727\\n\\nIssue\\nAllow hiding the \u201cSave and Add Another\u201d button with a `show_save_and_add_another` context variable.\\n\\nTo provide better adjustability, to introduce new context variable.\\nE.g. if I want to hide button \u201cSave and add another\u201d, I can just modify `extra_context` - write False to the variable. For other buttons - \u201cSave\u201d and \u201cSave and continue editing\u201d, this already works exactly in this manner.\\n\\nGold Patch\\ndiff --git a/django/contrib/admin/templatetags/admin_modify.py b/django/contrib/admin/templatetags/admin_modify.py\\n--- a/django/contrib/admin/templatetags/admin_modify.py\\n+++ b/django/contrib/admin/templatetags/admin_modify.py\\n@@ -54,12 +54,20 @@\\n   def submit_row(context):\\n       is_popup = context['is_popup']\\n       save_as = context['save_as']\\n+      show_save_and_add_another = context.get('show_save_and_add_another', True)\\n\\n       # (7 lines omitted...)\\n+      can_save_and_add_another = (has_add_permission\\n+                                 and not is_popup\\n+                                 and (not save_as or add)\\n+                                 and can_save\\n+                                 and show_save_and_add_another\\n+                                 )\\n       can_save_and_continue = not is_popup\\n                                 and can_save\\n                                 and has_view_permission\\n                                 and show_save_and_continue\\n\\n       can_change = has_change_permission\\n                                 or has_editable_inline_admin_formsets\\n       ctx = Context(context)\\n@@ -70,10 +78,7 @@\\n   def submit_row(context):\\n       change and context.get('show_delete', True),\\n       'show_save_as_new': not is_popup\\n-      and has_change_permission\\n-      and change and save_as,\\n+      'show_save_and_add_another': can_save_and_add_another,\\n+      'show_save_and_continue': can_save_and_continue,\\n       'show_save': show_save and can_save,\"}"}
{"id": "VTF8yNQM66", "page_num": 47, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2024\\n\\nModel Generated Patch\\n\\ndiff --git a/django/contrib/admin/templatetags/admin_modify.py b/django/contrib/admin/templatetags/admin_modify.py\\n--- a/django/contrib/admin/templatetags/admin_modify.py\\n+++ b/django/contrib/admin/templatetags/admin_modify.py\\n@@ -72,7 +72,7 @@\\ndef submit_row(context):\\n     show_save_as_new = not is_popup and has_change_permission and change and save_as,\\n     show_save_and_add_another = (has_add_permission and not is_popup and\\n       -(not save_as or add) and can_save) or\\n+       (not save_as or add) and can_save and context.get('show_save_and_add_another', True),\\n     show_save_and_continue = can_save_and_continue,\\n     show_save = show_save and can_save,\\n\\nTests Fail to Pass\\n(test_override_show_save_and_add_another\\ntest_submit_row (admin_views.test_templatetags.Admin...)\\nPass to Pass\\n(test_choice_links (admin_views.test_templatetags.DateHierarchyTests)\\ntest_override_change_form_template_tags\\ntest_override_change_list_template_tags\\n\\nDiscussion.\\nFor this task instance that comes from the django/django repository, the model is asked to introduce a context variable that would allow a user to hide the \\\"Save and Add Another\\\" button via a context variable, similar to how it is done for two other existing buttons. The task is a bit more difficult compared to the prior two settings because no explicit stack trace or programmatic demonstration of the issue is offered. In this relatively under-specified setting that does not provide suggestion with regards to localizing the function correctly, the model successfully reasons that it should adjust the existing show_save_and_add_another key/value pair. When comparing the gold patch solution, it can be argued that the model generated patch produces a much more efficient solution in terms of lines edited, as it makes the smallest edit necessary to incorporate context as a flag for setting the show_save_and_add_another hidden status. However, similar to the discussion in Table 31, stylistically, the gold patch edits are much more consistent with the codebase, and additional changes that are not explicitly discussed in the issue are also made to adhere to what has been done in the codebase (i.e. the addition of a can_save_and_add_another field). This task is an example of a potentially exciting direction where via human guidance or better understanding of a codebase in general, models would then adjust their generations to not just make the functionally correct changes, but also the stylistically right ones, too.\"}"}
{"id": "VTF8yNQM66", "page_num": 48, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 33: This is an example where SWE-Llama13b writes an incorrect solution, but maintains prior behavior successfully. The difference in the model's generation and the gold patch here demonstrates how models tend to under-generate the necessary fixes.\\n\\n## Setting\\n- **Model**: SWE-Llama 13B with Oracle retrieval\\n- **Task Instance**: sphinx-doc\\n  - Link to Issue: https://github.com/sphinx-doc/sphinx/issues/11437\\n  - Link to PR: https://github.com/sphinx-doc/sphinx/pull/11445\\n\\n## Issue\\nUsing `rst_prolog` removes top level headings containing a domain directive.\\n\\n### Describe the bug\\nIf `rst_prolog` is set, then any documents that contain a domain directive as the first heading (e.g., `:mod:`) do not render the heading correctly or include the heading in the toctree. In the example below, if the heading of `docs/mypackage.rst` were `mypackage2` instead of `:mod:mypackage2`, then the heading displays correctly. Similarly, if you do not set `rst_prolog`, then the heading will display correctly. This appears to have been broken for some time because I can reproduce it in v4.0.0 of Sphinx.\\n\\n### How to Reproduce\\n```\\n$ sphinx-quickstart --no-sep --project mypackage --author me -v 0.1.0 --release 0.1.0 --language en docs\\n```\\n```\\necho -e 'Welcome\\n=======\\n\\n.. toctree::\\n\\n    mypackage\\n' > docs/index.rst\\n```\\n```\\necho -e ':mod:'mypackage2'\\n=================\\n\\nContent\\n\\nSubheading\\n----------\\n' > docs/mypackage.rst\\n```\\necho -e 'rst_prolog = \"\"\"\\n...\\n|psf|\\nreplace::  \\nPython Software Foundation\\n\"\"\"' >> docs/conf.py\\n```\\n```\\n$ sphinx-build -b html . _build\\n```\\n```\\n$ grep 'mypackage2' docs/_build/index.html\\n```\\n\\n## Model Generated Patch\\n```\\ndiff --git a/sphinx/util/rst.py b/sphinx/util/rst.py\\n--- a/sphinx/util/rst.py\\n+++ b/sphinx/util/rst.py\\n@@ -25,7 +25,7 @@\\n\\n logger = logging.getLogger(__name__)\\n-docinfo_re = re.compile(':\\\\w+:.*?')\\n+docinfo_re = re.compile(':\\\\w+:.*?\\n')\\n\\n symbols_re = re.compile(r'([!-/-@\\\\[-'{-\u02dc])')\\n\\nSECTIONING_CHARS = ['=', '-', '\u02dc']\\n```\\n\\n## Tests\\n\\n| Fail to Pass | Pass to Pass |\\n|--------------|-------------|\\n| 2            | 8           |\\n\\nAdditional Pass to Pass Tests omitted...\"}"}
{"id": "VTF8yNQM66", "page_num": 49, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Discussion.\\n\\nFor this task instance from the sphinx-doc/sphinx repository, a model is asked to write logic to fix a case where the title is incorrectly being rendered. Simply understanding the jargon being used and mapping such words to logic within the codebase is a significant challenge faced by the model. The model is given a command line call that can help with this, but grounding the terminology presented in the issues within the codebase is essential. From comparing the gold patch and model generated patch, it is clear that the model does not come close to solving the task. The model does generally identify that fixing the regex pattern is the correct action, as this is what the gold patch does, too. However, where the model and oracle retrieval setting collectively fall short is mainly due to the significant use of additional modules from both the codebase itself and third party libraries. This example highlights the importance and potential for training language models and designing inference procedures that allow for the automated discovery of such information.\"}"}
{"id": "VTF8yNQM66", "page_num": 2, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2024\\n\\nTasks are appealing as they pose challenging problems to LMs yet generated solutions can be easily verified by running unit tests. However, existing coding benchmarks, such as HumanEval (Chen et al., 2021), mostly involve self-contained problems that can be solved in a few lines of code. In the real world, software engineering is not as simple. Fixing a bug might involve navigating a large repository, understanding the interplay between functions in different files, or spotting a small error in convoluted code. Inspired by this, we introduce SWE-bench, a benchmark that evaluates LMs in a realistic software engineering setting. As shown in Figure 1, models are tasked to resolve issues (typically a bug report or a feature request) submitted to popular GitHub repositories. Each task requires generating a patch describing changes to apply to the existing codebase. The revised codebase is then evaluated using the repository's testing framework.\\n\\nSWE-bench offers several advantages over existing LM programming benchmarks. These include, a realistic setting that utilizes user-submitted issues and solutions, diverse inputs featuring unique code problems from 12 repositories, a robust framework for execution-based evaluation, and the ability to continuously update the benchmark with new instances, requiring minimal human intervention. We evaluate multiple state-of-the-art LMs on SWE-bench and find that they fail to solve all except the simplest issues. Using a BM25 retriever, Claude 2 is only able to resolve 1.96% of the issues.\\n\\nIn addition to SWE-bench our contributions include the release of a training dataset, SWE-bench-train, which is essential for advancing open model development in this challenging domain. This dataset comprises a collection of 19,000 non-testing task instances derived from 37 repositories. Utilizing SWE-bench-train, we release two fine-tuned models, SWE-Llama 7b and 13b, based on the CodeLlama (Roziere et al., 2023) model. We find that in some settings SWE-Llama 13b is competitive with Claude 2 and is capable of processing contexts exceeding 100,000 tokens.\"}"}
{"id": "VTF8yNQM66", "page_num": 3, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Through these stages of filtering, the original 90,000 PRs are filtered down to the 2,294 task instances which comprise SWE-bench. A final breakdown of these task instances across repositories is presented in Figure 3, and Table 1 highlights the key features of SWE-bench task instances. We highlight that the codebases are large with thousands of files, and the reference pull requests often make changes to multiple files at once. Technical details about SWE-bench\u2019s construction pipeline are discussed in Appendix A. Additional dataset statistics are in Appendix A.5.\\n\\n2.2 TASK FORMULATION\\n\\nModel input. A model is given an issue text description and a complete codebase. The model is then tasked to make an edit to the codebase to resolve the issue. In practice, we represent edits as patch files, which specify which lines in the codebase to modify in order to resolve the issue.\\n\\nEvaluation metrics. To evaluate a proposed solution, we apply the generated patch, using unix\u2019s patch program, to the codebase and then execute the unit and system tests associated with the task instance. If the patch applies successfully and all of these tests pass we consider the proposed solution to have successfully resolved the issue. The metric for our benchmark is the percentage of task instances that are resolved. Additional technical details in Appendix A.4.\\n\\n2.3 FEATURES OF SWE-BENCH\\n\\nTraditional benchmarks in NLP typically involve only short input and output sequences and consider somewhat \u201ccontrived\u201d problems created specifically for the benchmark. In contrast, SWE-bench\u2019s realistic construction setting imbues the dataset with unique properties, which we discuss below.\\n\\nReal-world software engineering tasks. Since each task instance in SWE-bench consists of a large and complex codebase and a description of a relevant issue, solving SWE-bench requires demonstrating sophisticated skills and knowledge possessed by experienced software engineers but are not commonly evaluated in traditional code generation benchmarks.\\n\\nContinually updatable. Our collection process can be easily applied to any Python repository on GitHub and requires minimal human intervention. Therefore, we can extend SWE-bench with a continual supply of new task instances and evaluate LMs on issues created after their training date, which ensures that the solution was not included in their training corpus.\\n\\nDiverse long inputs. Issue descriptions are typically long and detailed (195 words on average), and codebases regularly contain many thousands of files. Solving SWE-bench requires identifying the relatively small number of lines that need to be edited to solve an issue amongst a sea of context.\\n\\nRobust evaluation. For each task instance, there is at least one fail-to-pass test which was used to test the reference solution, and 40% of instances have at least two fail-to-pass tests. These tests evaluate whether the model addressed the problem in the issue. In addition, a median of 51 additional tests run to check whether prior functionality is properly maintained.\\n\\nCross-context code editing. Unlike prior settings that may constrain edit scope to an individual function or class (e.g., Chen et al., 2021; Cassano et al., 2022) or provide cloze-style fill-in blanks (e.g., Lu et al., 2021; Fried et al., 2023), SWE-bench does not provide such explicit guidance. Rather than merely having to produce a short code snippet, our benchmark challenges models to generate revisions in multiple locations of a large codebase. SWE-bench\u2019s reference solutions average editing 1.7 files, 3.0 functions, and 32.8 lines (added or removed).\\n\\nWide scope for possible solutions. The task of repository-scale code editing can serve as a level playing field to compare approaches ranging from retrieval and long-context models to decision-making agents, which could reason and act in code. SWE-bench also allows creative freedom, as models can generate novel solutions that may deviate from the reference PR.\\n\\n3 SWE-LAMA: FINE-TUNING CODE LAMA FOR SWE-BENCH\\n\\nIt is important to benchmark the performance of open models on SWE-bench alongside proprietary models. At the time of writing, only the CodeLlama models (Rozi`ere et al., 2023) are able to handle the very long contexts necessary. However, we observe that the off-the-shelf CodeLlama variants...\"}"}
{"id": "VTF8yNQM66", "page_num": 4, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 3: Distribution of SWE-bench tasks (in parenthesis) across 12 open source GitHub repositories that each contain the source code for a popular, widely downloaded PyPI package.\\n\\nTable 1: Average and maximum numbers characterizing different attributes of a SWE-bench task instance. Statistics are micro-averages calculated without grouping by repository.\\n\\n| Attribute                  | Mean   | Max   |\\n|----------------------------|--------|-------|\\n| Issue Text Length (Words)  | 195.1  | 4477  |\\n| Codebase # Files (non-test)| 3,010  | 5,890 |\\n| # Lines (non-test)         | 438K   | 886K  |\\n| Gold Patch # Lines edited  | 32.8   | 5888  |\\n| # Files edited             | 1.7    | 31    |\\n| # Func. edited             | 3      | 36    |\\n| Tests # Fail to Pass       | 9.1    | 1633  |\\n| # Total                    | 120.8  | 9459  |\\n\\nare not capable of following the detailed instructions to generate repository-wide code edits, and typically output placeholder responses or unrelated code. To better evaluate the capabilities of these models, we perform supervised fine-tuning on the 7 billion- and 13 billion-parameter CodeLlama-Python models. The resulting models are specialized repository editors that can run on consumer hardware and resolve GitHub issues.\\n\\nTraining data. We follow our data collection procedure and collect 19,000 issue-PR pairs from an additional 37 popular Python package repositories. In contrast to Section 2.1, we do not require that pull requests contribute test changes. This allows us to create a much larger training set to use for supervised fine-tuning. To eliminate the risk of data contamination, the set of repositories in the training data is disjoint from those included in the evaluation benchmark.\\n\\nTraining details. Given the instructions, an issue text from GitHub and the relevant code files as the prompt, we finetune SWE-Llama to generate the patch that solved the given issue (the \u201cgold patch\u201d). For memory efficiency, we fine-tune only the weights of the attention sublayer using LoRA Hu et al. (2022), and exclude training sequences with more than 30,000 tokens, reducing the effective size of the training corpus to 10,000 instances. More details are provided in Appendix B.\\n\\n4 EXPERIMENTAL SETUP\\n\\nIn this section we explain how inputs are constructed to run SWE-bench evaluation. In addition, we review the models that we evaluate in this work.\\n\\n4.1 RETRIEVAL-BASED APPROACH\\n\\nSWE-bench instances provide an issue description and a codebase as input to the model. While issues descriptions are usually short (195 words on average as shown in Table 1), codebases consist of many more tokens (438K lines on average) than can typically be fit into an LMs context window. Then the question remains of exactly how to choose the relevant context to provide to the model?\\n\\nTo address this issue for our baselines, we simply use a generic retrieval system to select the files to insert as context. In particular, we evaluate models under two relevant context settings: 1) sparse retrieval and 2) an oracle retrieval.\\n\\nSparse retrieval. Dense retrieval methods are ill-suited to our setting due to very long key and query lengths, and especially the unusual setting of retrieving code documents with natural language queries. Therefore, we choose to use BM25 retrieval (Robertson et al., 2009) to retrieve relevant files to provide as context for each task instance. We experiment with three different maximum context limits, and simply retrieve as many files as fits within the specified limit. We evaluate each model on all limits that fit within its context window and report the best performance. From observation, models perform best on the shortest context window, as shown in Table 2.\\n\\n\u201cOracle\u201d retrieval. For analysis purposes we also consider a setting where we \u201cretrieve\u201d the files edited by the reference patch that solved the issue on GitHub. This \u201coracle\u201d setting is less realistic, 4\"}"}
{"id": "VTF8yNQM66", "page_num": 5, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"since an engineer working on addressing an issue may not know a priori which files need to be modified. In addition, this setting is also not necessarily comprehensive since edited files alone may not include all the required context to understand exactly how software will behave when interacting with unseen parts of the code.\\n\\nWe compare the BM25 retrieval results with those of the \u201coracle\u201d retrieval setting, as shown in Table 3. We observe that in approximately 40% of instances, BM25 retrieves a superset of the oracle files for the 27,000-token context limit. However, in almost half of the instances with the 27,000-token limit, it retrieves none of the files from the \u201coracle\u201d context.\\n\\n4.2 INPUT FORMAT\\n\\nOnce the retrieved files are selected using one of the two methods above, we construct the input to the model consisting of task instructions, the issue text, retrieved files and documentation, and finally an example patch file and prompt for generating the patch file. Examples of instances and further details on this formulation are provided in Appendix D.\\n\\n4.3 MODELS\\n\\nDue to the need to process long sequence lengths, there are only a few models that are currently suitable for SWE-bench. Thus we evaluate ChatGPT-3.5 (gpt-3.5-turbo-16k-0613), GPT-4 (gpt-4-32k-0613), Claude 2, and SWE-Llama with their context limits shown in Table 4.\\n\\nTable 2: Model resolve rates with BM25 retrieval, with different maximum context lengths.\\n\\n| Max. Content | Claude 2 | SWE-Llama 7b | SWE-Llama 13b |\\n|--------------|----------|--------------|---------------|\\n| 13k          | 1.96     | 0.70         | 0.70          |\\n| 27k          | 1.87     | 0.48         | 0.31          |\\n| 50k          | 1.22     | 0.00         | 0.00          |\\n\\nTable 3: BM25 recall with respect to oracle files for different maximum context lengths.\\n\\n| Max. Content | BM25 Recall |\\n|--------------|-------------|\\n| 13k          | 29.58       |\\n| 27k          | 44.41       |\\n| 50k          | 51.06       |\\n\\n| Any          | Avg.        |\\n|--------------|-------------|\\n| 26.09        | 39.83       |\\n| 34.77        | 51.27       |\\n| 58.38        | 51.06       |\\n\\nTable 4: We compare the different context lengths and proportion of the \u201coracle\u201d retrieval setting covered. Models with shorter context lengths are thus inherently disadvantaged. Note that descriptions of token-lengths is a relative non-standard measure (e.g. Llama-tokenized sequences are 42% longer on average than the equivalent sequence tokenized for GPT-4).\\n\\nChatGPT-3.5 | GPT-4 | Claude 2 | SWE-Llama |\\n|------------|-------|----------|-----------|\\n| Max. Tokens| 16,385| 32,768   | 100,000   |\\n| \u2265100,000   | 58.1% | 84.1%    | 96.4%     |\\n| % of Instances | \u226594.8% |         |           |\\n\\n5 RESULTS\\n\\nWe report results for models using different retrieval mechanisms and prompting styles, then provide some analysis and insight into model performance and difficulty. We summarize models\u2019 performance using BM25 retrieval in Table 5. Across the board, models struggle significantly to resolve issues. The best performing model, Claude 2, is only able to resolve 1.96% of the issues.\\n\\nTo analyze the importance of the retriever to the overall system results, we present the \u201coracle\u201d retrieval results in Appendix Table 18. There, Claude 2 is able to resolve 4.8% of issues using the \u201coracle\u201d retriever. We further analyze the importance of context in the discussion below.\\n\\nDifficulty differs across repositories. When breaking performance down by repository, all models trend similarly across different repositories as show in Figure 4. Despite this, the issues resolved by each model do not necessarily overlap extensively. For example, in the \u201coracle\u201d setting Claude 2 and...\"}"}
{"id": "VTF8yNQM66", "page_num": 38, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 28: For this issue from the mwaskom/seaborn repository, the problem statement includes hyperlinks to images. As discussed in Section 5, a minor subset of SWE-bench tasks include images in them, making image understanding a small but important component to resolving issues that is unexplored by the initial baselines.\\n\\nSetting\\n\u2022 Model: Claude 2 with Oracle retrieval\\n\u2022 Task Instance: mwaskom/seaborn-3217\\n  \u2013 Link to Issue: https://github.com/mwaskom/seaborn/issues/2907\\n  \u2013 Link to PR: https://github.com/mwaskom/seaborn/pull/3217\\n\\nIssue\\nWidth computation after histogram slightly wrong with log scale\\n\\n```\\nso.Plot(tips, \\\"total_bill\\\")\\n  .add(so.Bars(alpha=.3, edgewidth=0), so.Hist(bins=4))\\n  .scale(x=\\\"log\\\")\\n```\\n\\n![image](https://user-images.githubusercontent.com/315810/178975852-d8fd830e-ae69-487d-be22-36531fca3f8f.png)\\n\\nIt becomes nearly imperceptible with more bins:\\n```\\nso.Plot(tips, \\\"total_bill\\\")\\n  .add(so.Bars(alpha=.3, edgewidth=0), so.Hist(bins=8))\\n  .scale(x=\\\"log\\\")\\n```\\n\\n![image](https://user-images.githubusercontent.com/315810/178976113-7026b3ae-0b87-48df-adc0-00e90d5aea94.png)\\n\\nThis is not about 'Bars'; 'Bar' has it too:\\n```\\nso.Plot(tips, \\\"total_bill\\\")\\n  .add(so.Bar(alpha=.3, edgewidth=0, width=1), so.Hist(bins=4))\\n  .scale(x=\\\"log\\\")\\n```\\n\\n![image](https://user-images.githubusercontent.com/315810/178975910-484df65f-4ce6-482e-9992-5d02faf6b9ea.png)\\n\\nModel Generated Patch\\n\\n```diff\\n--- a/seaborn/_core/plot.py\\n+++ b/seaborn/_core/plot.py\\n@@ -1327,9 +1327,7 @@\\n     elif \\\"width\\\" in df:\\n         view_width = view_df[\\\"width\\\"]\\n     else:\\n-        view_width = 0.8\\n-        # TODO what default?\\n-        spacing = scales[orient]._spacing(view_df.loc[view_idx, orient])\\n+        view_width = view_width\\n         width.loc[view_idx] = view_width * spacing\\n     df[\\\"width\\\"] = width\\n     if \\\"baseline\\\" in mark._mappable_props:\\n```\"}"}
{"id": "VTF8yNQM66", "page_num": 39, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Gold Patch\\n\\ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\\n--- a/seaborn/_core/plot.py\\n+++ b/seaborn/_core/plot.py\\n@@ -1377,10 +1377,9 @@\\ndef _unscale_coords(\\n- drop_cols = [ *coord_cols, \\\"width\\\"]\\n+ drop_cols = [ *coord_cols, \\\"width\\\"]\\n  if \\\"width\\\" in df else coord_cols\\n  out_df = df - .drop(drop_cols, axis=1)\\n+ .drop(coord_cols, axis=1)\\n     .reindex(df.columns, axis=1)\\n     # So unscaled columns retain their\\n@@ -1396,12 +1395,6 @@\\ndef _unscale_coords(\\n- if var == orient and \\\"width\\\" in view_df:\\n- width = view_df[\\\"width\\\"]\\n- out_df.loc[values.index, \\\"width\\\"] = (transform(values + width / 2) - transform(values - width / 2))\\n- return out_df\\n- diff --git a/seaborn/_marks/bar.py b/seaborn/_marks/bar.py\\n--- a/seaborn/_marks/bar.py\\n+++ b/seaborn/_marks/bar.py\\n@@ -29,17 +29,23 @@\\nclass BarBase(Mark):\\n+ transform = scales[orient]._matplotlib_scale.get_transform()\\n+ forward = transform.transform\\n+ reverse = transform.inverted().transform\\n+\\n+ other = {\\\"x\\\": \\\"y\\\", \\\"y\\\": \\\"x\\\"}[orient]\\n+\\n+ pos = reverse(forward(data[orient]) - data[\\\"width\\\"] / 2)\\n+ width = reverse(forward(data[orient]) + data[\\\"width\\\"] / 2) - pos\\n+ val = (data[other] - data[\\\"baseline\\\"]).to_numpy()\\n+ base = data[\\\"baseline\\\"].to_numpy()\\n+\\n(Remaining lines omitted...)\\n\\nTests\\nFail to Pass\\n(tests/_marks/test_bar.py::TestBars::test_log_scale)\\nPass to Pass\\n(tests/_marks/test_bar.py::TestBar::test_categorical_positions_vertical)\\n(tests/_marks/test_bar.py::TestBar::test_categorical_positions_horizontal)\\n(tests/_marks/test_bar.py::TestBar::test_numeric_positions_vertical)\\n(tests/_marks/test_bar.py::TestBar::test_numeric_positions_horizontal)\\n(tests/_marks/test_bar.py::TestBar::test_set_properties)\\n\\nAdditional Pass to Pass Tests omitted...\\n\\nDiscussion.\\nThe baseline model's inability to solve this issue can be directly attributed to a lack of an image input. We include this example to demonstrate that debugging real software issues may involve digesting images; this presents a whole separate body of understanding and reasoning-related challenges. Beyond the SWE-bench task, additional problems in software engineering, such as interpreting system design diagram, user interface specifications, and user feedback presents interesting vision-language challenges.\"}"}
{"id": "VTF8yNQM66", "page_num": 40, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 29: In this final example of a Claude 2 generation, the model must resolve an error related to resolving an error regarding cyclic dependencies. Claude 2's solution under-delivers on an otherwise complex problem.\\n\\nSetting\\n- **Model**: Claude 2 with Oracle retrieval\\n- **Task Instance**: sympy\\n\\n- Link to Issue: [GitHub Issue](https://github.com/pylint-dev/pylint/issues/3525)\\n- Link to PR: [GitHub Pull Request](https://github.com/pylint-dev/pylint/pull/4703)\\n\\nIssue\\nImports within TYPE_CHECKING can induce \\\"cyclic-import\\\"\\n\\nSuppose you have two modules: a.py and b.py. 'a' imports 'b', but 'b' needs 'a' in order to do type annotations, then this is usually done by importing 'a' within a 'TYPE_CHECKING' block.\\n\\nUnfortunately, this causes pylint to report \\\"cyclic-import\\\".\\n\\nPossibly related to [GitHub Issue](https://github.com/PyCQA/pylint/issues/3285)\\n\\nGold Patch\\n```python\\ndiff --git a/pylint/checkers/imports.py b/pylint/checkers/imports.py\\n--- a/pylint/checkers/imports.py\\n+++ b/pylint/checkers/imports.py\\n@@ -813,7 +813,9 @@\\ndef _get_imported_module(self, importnode, modname):\\n-\\ndef _add_imported_module(self, node, importedmodname):\\n+def _add_imported_module(\\n+    self, node: Union[astroid.Import, astroid.ImportFrom],\\n+    importedmodname: str\\n+    ) -> None:\\n+    \"\"\"notify an imported module, used to analyze dependencies\"\"\"\\n+    module_file = node.root().file\\n    context_name = node.root().name\\n    \\n    @lru_cache(maxsize=None)\\n```\"}"}
{"id": "VTF8yNQM66", "page_num": 41, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2024\\n\\n```\\ndiff --git a/pylint/checkers/imports.py b/pylint/checkers/imports.py\\nindex 4f3eed2..2b74a8d 100644\\n--- a/pylint/checkers/imports.py\\n+++ b/pylint/checkers/imports.py\\n@@ -49,6 +49,7 @@\\n import\\n copy\\n import\\n os\\n import\\n sys\\n from distutils\\n+from typing import TYPE_CHECKING\\n import sysconfig\\n from typing import Dict, List, Union\\n import astroid\\n@@ -61,6 +62,9 @@\\n from pylint.checkers.utils import (node_ignores_exception,)\\n from pylint.exceptions import EmptyReportError\\n+if TYPE_CHECKING:\\n+    from pylint.lint import PyLinter\\n+    from pylint.graph import DotBackend, get_cycles\\n from pylint.interfaces import IAstroidChecker\\n from pylint.reporters.ureports.nodes import Paragraph, VerbatimText, VNode\\n\\nTests Fail to Pass\\n(1)\\ntests/_marks/test_bar.py::TestBars::test_log_scale\\n\\nPass to Pass\\n(11)\\ntests/test_func.py::test_functionality[func_w0401_disabled_in_func.py]\\ntests/test_func.py::test_functionality[func_i0022.py]\\ntests/test_func.py::test_functionality[func_w0401.py]\\ntests/test_func.py::test_functionality[func_w0801.py]\\ntests/test_func.py::test_functionality[func_w0401_package]\\n\\nAdditional Pass to Pass Tests omitted...\\n\\nDiscussion.\\nIn this problem, the model is being asked to provide based handling for resolving cyclic imports, which pylint currently throws an error for. The gold patch has a detailed solution that involves conditional handling within the TYPE_CHECKING block, excludes the cyclic import messages, and has generally more specific handling. The model generated patch employs a \\\"Stack Overlow\\\" like solution; while creating a TYPE_CHECKING block is a popular solution for resolving imports, solving this issue for the codebase in particular requires a more nuanced solution than a general answer that may be available online.\"}"}
{"id": "VTF8yNQM66", "page_num": 26, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 19: % Resolved for models per repository represented in SWE-bench.\\n\\n| Model         | BM25 Retrieval | Oracle Retrieval |\\n|---------------|----------------|------------------|\\n| Claude 2      | 2.27\u2191          | 0.31\u2191            |\\n| ChatGPT-3.5   | 0.17\u2212          | 0.00\u2191            |\\n| GPT-4         | 0.00\u2212          | 0.00\u2212            |\\n| SWE-Llama 7b  | 0.35\u2191          | 0.35\u2191            |\\n| SWE-Llama 13b | 0.70\u2212          | 0.00\u2212            |\\n\\nTable 20: We compare models against each other using the BM25 and oracle retrieval settings as described in Section 4 on a 25% random subset (574 instances) of SWE-bench in the \u201coracle\u201d and BM25 27K retriever settings only. This is the same subset that GPT-4 is evaluated on, as mentioned in Table 5. The difference relative to percentages in Table 5 and Table 18 is included as a subscript.\\n\\nBehavior is maintained (all P2P tests pass) but the issue remains completely unresolved (0 F2P tests pass). Finally, if the issue is unresolved (0 F2P tests pass) and prior working behavior is reverted (some P2P tests fail), the codebase is left in a worse state, which we define to be a \u201cRegression.\u201d\\n\\nIn Table 23, we categorize patch generations that successfully applied according to these six cases. We find that of non-\u201cResolved\u201d issues, the majority of patch generations proposed by the model do not solve a single F2P test case from the corresponding task instance (\u201cNo-Op\u201d and \u201cRegression\u201d). Within the subset of these cases, the majority (60% to 70%) of cases are a No-Op, while the model breaks existing behavior for the remainder of these situations.\\n\\nGenerally, the cases where model generations pass some, but not all tests (\u201cBreaking Resolved\u201d, \u201cPartially Resolved\u201d, \u201cWork in Progress\u201d) cumulatively represent a smaller subset of problems relative to the other three categories. From manual inspection of several of these cases, it is clear that the model demonstrates some understanding of the task requirements. However, due to the baseline methods\u2019 limited view of the codebase that does not include information such as inter-file dependencies and functions\u2019 relationships, for many of these task instances often fail because a change that correctly resolves the immediate issue does not account for other modules that use and are affected by the changed entity. We include several case studies that directly highlight these shortcomings in Section F.\\n\\nOverall, these results highlight not just the difficulty of SWE-bench, but also point to the potential value of providing feedback via an execution environment that would allow models to run fixes against existing tests, then decide whether to continue editing or submit the patch for review.\\n\\nC.6 PATCH GENERATION EXTENDED ANALYSIS\\n\\nIn this section, we present a statistics to quantify various facets of patch generations following the metrics laid out in Table 8. In Table 24, we recalculate these values for all patch generations in the oracle retrieval setting for all models, regardless of whether or not the patch was applied.\"}"}
{"id": "VTF8yNQM66", "page_num": 27, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 21: We present an extended temporal analysis in this table, showing the % resolved for task instances across models in the \\\"Oracle\\\" retrieval setting, separated by different cutoff dates. The Year column refers to the subset of tasks that were created during the specified calendar year. In the Total column, we list the number of tasks that fall within the given year. The 25% column is the same information for the subset that GPT-4 was evaluated on. The remaining model-specific columns contain the % resolved metric.\\n\\nTable 22: We present the 6 possible outcomes for a patch generation that is applied successfully and then executed. The outcomes are distinguished by the number of F2P and P2P tests that pass.\\n\\nAcross all metrics, we find that patch generations across models are much closer in size to the characteristics of average gold edits. While some models still generate fewer lines relative to the corresponding Gold edit (e.g., Claude-2, ChatGPT-3.5, GPT-4), the SWE-Llama models edits are on average longer in most respects. When considering both Table 8 and Table 24, it becomes clear that models struggle with generating longer output sequences to be correctly formatted patches. Further inspection of such occurrences, as shown in our case studies in Section F, indicate that hallucinations, abiding to existing code style/structure, and referencing long range dependencies correctly are common errors that surface more frequently in longer generations.\\n\\nC.7 SOFTWARE ENGINEERING METRICS\\n\\nWe perform preliminary evaluations that explore using software engineering metrics to evaluate the efficiency and complexity of large code blocks integrated within a complex codebase. Unlike semantic similarity scoring functions for evaluating fluency and surface form likeness that are popular with traditional NLP benchmarks and have been adopted for code generation, metrics such as Cyclomatic complexity McCabe (1976) and Halstead complexity measures Halstead (1977) are founded upon logical abstractions (e.g., Abstract Syntax Trees) and software principles to quantify the complexity, efficiency, and readability of code as a scalar value. The patch generations and SWE-bench evaluation logs are rich sources of information that software engineering metrics and static analyzers can readily be applied to. Unlike small, code contest benchmarks where the insights of software engineering metrics are not meaningful due to the minuscule scope of the target functionality, SWE-bench's task is complex enough that practitioners can use these tools to gain well-structured, rigorous, and wide-ranging feedback signals on the complexity of a patch generation's change and its effect on the rest of the codebase.\\n\\nWe include our exploratory work here that demonstrates how software engineering metrics can reliably capture characteristics of code quality, and how comparing these statistics across two patches can provide automatic observations about model capabilities. We use the Radon package, a library for computing different software engineering metrics directly from source code.\"}"}
{"id": "VTF8yNQM66", "page_num": 28, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 23: Categorization of model generations that applied successfully by the cases defined in Table 22. As mentioned, GPT-4 was evaluated on a 25% subset (574 instances) of SWE-bench.\\n\\nTable 24: Average edits of model generated patches in the oracle retrieval setting across all patches (including unsuccessfully applied patches). For the task instances specific to each model, we calculate the same statistics across the gold patches.\\n\\n| Model            | Total Lines Added | Removed | Functions | Files |\\n|------------------|-------------------|---------|-----------|-------|\\n| Claude 2         | 27.2              | 6.6     | 3.3       | 1.2   |\\n| Gold             | 61.6              | 17.8    | 8.6       | 2.6   |\\n| ChatGPT-3.5      | 42.0              | 6.1     | 3.9       | 1.7   |\\n| Gold             | 44.5              | 12.7    | 5.5       | 2.1   |\\n| GPT-4            | 22.4              | 4.4     | 1.8       | 0.8   |\\n| Gold             | 50.3              | 14.0    | 6.5       | 2.3   |\\n| SWE-Llama 13b    | 68.9              | 9.5     | 4.3       | 2.5   |\\n| Gold             | 61.5              | 17.8    | 8.6       | 2.6   |\\n| SWE-Llama 7b     | 78.9              | 10.1    | 7.6       | 2.5   |\\n| Gold             | 65.1              | 18.8    | 9.0       | 2.7   |\\n\\nWe look specifically at successfully applied Claude 2 patch predictions in the \u201cOracle\u201d retrieval setting for the psf/requests repository, which several models perform best at as reflected in Figure 4. Per prediction, we apply the patch to the codebase, then calculate the Cyclomatic complexity and Halstead complexity scores for the modified functions. Cyclomatic complexity quantifies the control flow of a function, counting the number of independent execution paths through the source code (McCabe, 1976). A higher Cyclomatic complexity score suggests a more complex function that has higher likelihood of defects and usually suggests difficult maintainability. Halstead complexity counts the number of operators and operands in a program (Halstead, 1977). Per prediction, we also perform the same set of steps for the corresponding gold patch.\\n\\nWe find that software engineering metrics provides automatic qualitative insights into model performance. Consider the following simple case study in Figure 10. While the model patch prediction (left) is fewer lines (6 instead of 11) and modifies fewer files (1 instead of 2) compared to the gold reference solution (right), the model's edit places a conditional within a relatively complex and widely used HTTPAdapter class. This introduces two new potential execution outcomes, raising the Cyclomatic complexity of HTTPAdapter from 3 to 5. In contrast, while longer, the reference solution imports intra-module dependencies, modifies a logically simpler function in get connection, and defines a new error type InvalidProxyURL to capture the novel bug described by the issue.\\n\\nD.1 Retrieval Details\\n\\nSparse retrieval. During retrieval we make a slight augmentation to the documents by pre-pended files' contents with their file paths to better enable retrieval based on filenames that may be mentioned directly in the issue.\"}"}
{"id": "VTF8yNQM66", "page_num": 29, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Problem Statement: Misleading exception with invalid protocol in proxy variable. When the value of `https_proxy` or `HTTPS_PROXY` accidentally miss one `/` in the protocol, a traceback is thrown to the user which doesn\u2019t pinpoint that the issue is with the proxy configuration...\\n\\nFigure 10: Comparison of the Claude 2 prediction (left) and reference solution (right) patches for SWE-bench task instance psf_requests-4356. While the code generated by the patch is fewer lines of code and solves the problem correctly, the prediction patch introduces greater Cyclomatic complexity (`requests.adapters.py/HTTPAdapter`: 3 \u2192 5) compared to the gold solution (`requests/adapters.py:get_connection`: 2 \u2192 3, `requests/exceptions.py:InvalidHeader`: 0 \u2192 1). Changes that introduce new execution paths are boxed in blue. Parts of the gold patch have been truncated for appearance.\\n\\nOracle retrieval.\\n\\nOracle retrieval file paths are simply extracted directly from the reference solution\u2019s patch file excluding test files.\\n\\nD.2 INFERENCE SETTINGS\\n\\nSince generations are relatively expensive, we only generate a single patch file per instance. Following precedent in code generation for evaluation in Pass@1 (Chen et al., 2021; Rozi\u00e8re et al., 2023), we simply use greedy decoding for all models.\\n\\nD.3 PROMPT TEMPLATE EXAMPLE\\n\\nModels are prompted with the following general template with slight variations depending on the model used.\\n\\nYou will be provided with a partial code base and an issue statement explaining a problem to resolve.\\n\\n```\\n<issue>{ISSUE TEXT}</issue>\\n<code>\\n[start of README.md]\\n{README.md text}\\n[end of README.md]\\n[start of file_1.py]\\n{file_1.py text}\\n[end of file_1.py]\\n...\\n```\\n\\nHere is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, 29...\"}"}
{"id": "VTF8yNQM66", "page_num": 10, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"SWE-bench is collected entirely from public repositories with licenses that permit software usage that our contributions are in accordance with. Details of the licenses are included in Table 12.\\n\\nDuring the collection or evaluation processes, we do not collect information about GitHub users, and the SWE-bench task instances do not use GitHub data beyond what is offered via the public API and website. Our contributions do not involve any human subject participation; we do not perform crowdsourcing or recruit human task workers for any part of SWE-bench, including its collection and evaluation procedures along with the experiments. SWE-bench's filtering criteria for GitHub repositories based on popularity does not implicitly or explicitly rely on any discriminative or biased heuristics for repository selection. For the dataset release, we plan to open source the SWE-bench task instances, the collection and evaluation infrastructure, the experimental results, the training data used for fine-tuning SWE-Llama models, and the SWE-Llama model weights. Following best practice precedents, we will also put forth ample documentation to describe each component and its use, and we will also put in place convenient communication channels for soliciting feedback to improve SWE-bench. SWE-bench does not put forth any immediately harmful insights. We briefly discuss the potential impact of SWE-bench's usage in Section E.\\n\\nFor our submission, we have uploaded the entirety of the source code as a zipped file that has been properly anonymized. We have organized the codebase such that separate directories correspond to different contributions within the main paper (i.e. dataset collection, evaluation, open source model inference, SWE-Llama training, etc.). The source code contains inline documentation that details purpose and usage of different parts of the codebase. In addition, we also include the full set of 2294 SWE-bench task instances that contains all the components discussed in the main paper. Beyond the documentation in the source code, we include thorough technical details for the collection pipeline and evaluation procedures in Section A.2 and Section A.4 that complements the original details in Section 2 of the main paper. These sections fully cover the logic presented in the code and can be helpful for understanding it. Moving forward, as discussed in the ethics statement, we plan to more formally release SWE-bench to the public as an open source repository with thorough details that describes the benchmark, outlines the code, and details its usage. A major component of SWE-bench is the collection framework, which will be part of the open sourced code. Because of its easily maintainable design, as discussed in the main paper, our hope and belief is that SWE-bench should be highly reproducible.\\n\\nWe thank Danqi Chen, Tri Dao, Zexuan Zhong, Tianyu Gao, Will Merrill, Mengzhou Xia, Dan Friedman, Adithya Bhaskar, Austin Watkins, Aatmik Gupta, and Richard Zhu for their valuable feedback and advice. We acknowledge support from the National Science Foundation under Grant No. 2239363 and an Oracle Collaborative Research award. Any opinions, findings, conclusions, or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.\"}"}
{"id": "VTF8yNQM66", "page_num": 11, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Miltiadis Allamanis, Marc Brockschmidt, and Mahmoud Khademi. Learning to represent programs with graphs. arXiv preprint arXiv:1711.00740, 2017.\\n\\nBen Athiwaratkun, Sanjay Krishna Gouda, Zijian Wang, Xiaopeng Li, and Yuchen Tian et. al. Multi-lingual evaluation of code generation models, 2023.\\n\\nJacob Austin, Augustus Odena, Maxwell Nye, Maarten Bosma, Henryk Michalewski, David Dohan, Ellen Jiang, Carrie Cai, Michael Terry, Quoc Le, and Charles Sutton. Program synthesis with large language models, 2021.\\n\\nSamuel R. Bowman and George E. Dahl. What will it take to fix benchmarking in natural language understanding?, 2021.\\n\\nFederico Cassano, John Gouwar, Daniel Nguyen, Sydney Nguyen, Luna Phipps-Costin, Donald Pinckney, Ming-Ho Yee, Yangtian Zi, Carolyn Jane Anderson, Molly Q Feldman, Arjun Guha, Michael Greenberg, and Abhinav Jangda. Multipl-e: A scalable and extensible approach to benchmarking neural code generation, 2022.\\n\\nSaikat Chakraborty and Baishakhi Ray. On multi-modal learning of editing source code, 2021.\\n\\nSaikat Chakraborty, Yujian Li, Matt Irvine, Ripon Saha, and Baishakhi Ray. Entropy guided spectrum based bug localization using statistical language model. arXiv preprint arXiv:1802.06947, 2018.\\n\\nMark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, and Jared Kaplan et. al. Evaluating large language models trained on code, 2021.\\n\\nTri Dao, Dan Fu, Stefano Ermon, Atri Rudra, and Christopher R\u00e9. Flashattention: Fast and memory-efficient exact attention with io-awareness. Advances in Neural Information Processing Systems, 35:16344\u201316359, 2022.\\n\\nXiang Deng, Yu Gu, Boyuan Zheng, Shijie Chen, Samuel Stevens, Boshi Wang, Huan Sun, and Yu Su. Mind2web: Towards a generalist agent for the web, 2023.\\n\\nTuan Dinh, Jinman Zhao, Samson Tan, Renato Negrinho, Leonard Lausen, Sheng Zha, and George Karypis. Large language models of code fail at completing code with potential bugs. arXiv preprint arXiv:2306.03438, 2023.\\n\\nXueying Du, Mingwei Liu, Kaixin Wang, Hanlin Wang, Junwei Liu, Yixuan Chen, Jiayi Feng, Chaofeng Sha, Xin Peng, and Yiling Lou. Classeval: A manually-crafted benchmark for evaluating llms on class-level code generation, 2023.\\n\\nSarah Fakhoury, Saikat Chakraborty, Madan Musuvathi, and Shuvendu K. Lahiri. Towards generating functionally correct code edits from natural language issue descriptions, 2023.\\n\\nZhiyu Fan, Xiang Gao, Martin Mirchev, Abhik Roychoudhury, and Shin Hwei Tan. Automated repair of programs from large language models, 2023.\\n\\nDaniel Fried, Armen Aghajanyan, Jessy Lin, Sida Wang, Eric Wallace, Freda Shi, Ruiqi Zhong, Wen tau Yih, Luke Zettlemoyer, and Mike Lewis. Incoder: A generative model for code infilling and synthesis, 2023.\\n\\nXiang Gao, Yannic Noller, and Abhik Roychoudhury. Program repair, 2022.\\n\\nClaire Le Goues, Michael Pradel, and Abhik Roychoudhury. Automated program repair. Communications of the ACM, 62(12):56\u201365, 2019.\\n\\nDavid Gros, Prem Devanbu, and Zhou Yu. Ai safety subproblems for software engineering researchers, 2023.\\n\\nRahul Gupta, Soham Pal, Aditya Kanade, and Shirish Shevade. Deepfix: Fixing common c language errors by deep learning. In Proceedings of the aaai conference on artificial intelligence, volume 31, 2017.\"}"}
{"id": "VTF8yNQM66", "page_num": 12, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":null}"}
{"id": "VTF8yNQM66", "page_num": 13, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Jiawei Liu, Chunqiu Steven Xia, Yuyao Wang, and Lingming Zhang. Is your code generated by chatgpt really correct? rigorous evaluation of large language models for code generation. arXiv preprint arXiv:2305.01210, 2023a.\\n\\nNelson F. Liu, Kevin Lin, John Hewitt, Ashwin Paranjape, Michele Bevilacqua, Fabio Petroni, and Percy Liang. Lost in the middle: How language models use long contexts, 2023b. arXiv:2307.03172.\\n\\nShangqing Liu, Yanzhou Li, Xiaofei Xie, and Yang Liu. Commitbart: A large pre-trained model for github commits, 2023c.\\n\\nXiao Liu, Hao Yu, Hanchen Zhang, Yifan Xu, Xuanyu Lei, and Hanyu Lai et. al. Agentbench: Evaluating llms as agents, 2023d.\\n\\nShuai Lu, Daya Guo, Shuo Ren, Junjie Huang, Alexey Svyatkovskiy, and Ambrosio Blanco et. al. Codexglue: A machine learning benchmark dataset for code understanding and generation. CoRR, abs/2102.04664, 2021.\\n\\nPetros Maniatis, Daniel Tarlow, and Google DeepMind. Large sequence models for soft-ware development activities, 2023. URL https://blog.research.google/2023/05/large-sequence-models-for-software.html.\\n\\nFernando Mart\u0131\u0301nez-Plumed, Pablo Barredo, Se\u00b4an \u00b4O h \u00b4Eigeartaigh, and Jos\u00b4e Hern\u00b4andez-Orallo. Research community dynamics behind popular ai benchmarks. Nature Machine Intelligence, 3:581\u2013589, 2021. URL https://api.semanticscholar.org/CorpusID:236610014.\\n\\nThomas J. McCabe. A complexity measure. IEEE Transactions on Software Engineering, SE-2(4):308\u2013320, 1976. doi: 10.1109/TSE.1976.233837.\\n\\nMartin Monperrus. Automatic software repair. ACM Computing Surveys, 51(1):1\u201324, jan 2018. doi: 10.1145/3105906. URL https://doi.org/10.1145%2F3105906.\\n\\nManish Motwani and Yuriy Brun. Better automatic program repair by using bug reports and tests together, 2023.\\n\\nNiklas Muennighoff, Qian Liu, Armel Zebaze, Qinkai Zheng, Binyuan Hui, Terry Yue Zhuo, Swayam Singh, Xiangru Tang, Leandro von Werra, and Shayne Longpre. Octopack: Instruction tuning code large language models, 2023.\\n\\nGabriel Orlanski, Kefan Xiao, Xavier Garcia, Jeffrey Hui, Joshua Howland, Jonathan Malmaud, Jacob Austin, Rishabh Singh, and Michele Catasta. Measuring the impact of programming language distribution, 2023.\\n\\nSimon Ott, Adriano Barbosa-Silva, Kathrin Blagec, Janina Brauner, and Matthias Samwald. Mapping global dynamics of benchmark creation and saturation in artificial intelligence. Nature Communications, 13, 2022. URL https://api.semanticscholar.org/CorpusID:247318891.\\n\\nStephen Robertson, Hugo Zaragoza, et al. The probabilistic relevance framework: Bm25 and beyond. Foundations and Trends\u00ae in Information Retrieval, 3(4):333\u2013389, 2009.\\n\\nBaptiste Rozi`ere, Jonas Gehring, Fabian Gloeckle, Sten Sootla, Itai Gat, and Xiaoqing Ellen Tan et. al. Code llama: Open foundation models for code, 2023.\\n\\nDavid Schlangen. Language tasks and language games: On methodology in current natural language processing research, 2019.\\n\\nDominik Sobania, Martin Briesch, Carol Hanna, and Justyna Petke. An analysis of the automatic bug fixing performance of chatgpt, 2023.\\n\\nAarohi Srivastava, Abhinav Rastogi, Abhishek Rao, and Abu Awal Md Shoeb et. al. Beyond the imitation game: Quantifying and extrapolating the capabilities of language models, 2023.\\n\\nRosalia Tufano, Luca Pascarella, Michele Tufano, Denys Poshyvanyk, and Gabriele Bavota. Towards automating code review activities, 2021.\"}"}
{"id": "VTF8yNQM66", "page_num": 18, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2024\\n\\nWe create executable contexts for every version of a repository, as discussed in greater detail in \u00a7 A.3.\\n\\nAfter filtering through all the PRs from a repository and converting those that satisfy the aforementioned criteria into candidate task instances, the next step is to validate the usability of each task instance via execution. This procedure is broken down into three steps. First, we create executable contexts for each release version of a repository. Next, we check whether the solution $\\\\delta$ and tests $T$ can be applied, installed, and run successfully on top of codebase $C$. Finally, we examine each task instance's execution log to verify a specific set of behaviors to ensure that the task is usable and fair for model evaluation.\\n\\nExecutable Contexts.\\n\\nWe choose to create executable contexts per release version after experimenting with various degrees of granularity with regards to what definition level to define virtual environments for. Defining task instance-specific contexts is most conducive to ensuring end-to-end installation success, but comes at the cost of laborious manual handcrafting. On the other hand, a repository-specific context based on the latest version of a repository is typically too coarse of a definition that is not compatible with older versions' requirements. We find that release versions are a good proxy for capturing the dependency requirements across a subset of task instances, striking a manageable balance between installation success and manual effort. We manually create each executable context by examining the codebase of the latest task instance for each version. Based on the source code and documentation typically found in the repository\u2019s README and CONTRIBUTING guides, we find out the Python version, necessary dependencies, and installation command.\\n\\nValidation Engine.\\n\\nThe purpose of the validation engine is to verify candidate task instances. Specifically, this step checks first, that the solution $\\\\delta$ and tests $T$ can be applied to codebase $C$, and second, that the codebase can be properly installed and run within the corresponding virtual environment. To do this, we perform validation repository-by-repository, where for each repository\u2019s set of task instances, we perform the following procedure:\\n\\n1. Create executable contexts as conda envs. based on latest task instance per version.\\n2. Group task instances by version.\\n3. Iterate across each task instances group, where for each task instance, we perform the following within the corresponding conda env.\\n   a. Remove any file changes and checkout the task instance\u2019s base commit. This sets the repository to codebase $C$.\\n   b. Run the installation command to instantiate codebase $C$.\\n   c. Apply the test patch $T$ to codebase $C$.\\n   d. Run the testing script, determined from test patch $T$, to generate test result logs $\\\\log_{pre}$.\\n   e. Apply the solution $\\\\delta$ patch to the codebase $C$ with tests $T$.\\n   f. Run the testing script from part (d) again to generate test result logs $\\\\log_{post}$.\\n\\nThe testing command consists of the testing framework used by the repository (e.g. pytest, tox) with paths specified in $T$ appended. The testing command would run any and all tests that are specified within the contents of each file path. If any of the steps (a) through (f) fails, the candidate task instance is discarded from consideration. With moderate variation across repositories, we observe that this step generally removes half of the candidate task instances.\\n\\nExamining Validation Logs.\\n\\nLast but not least, we check the logs $\\\\log_{pre}$ and $\\\\log_{post}$ created by the validation engine for specific properties. First, to guard against arbitrary naming choices, we check $\\\\log_{pre}$ for ImportError and AttributeError occurrences, which are potentially indicative of dependency naming related errors that would trivial and near-impossible to address correctly. To this end, we remove all task instances with such errors in their $\\\\log_{pre}$ from consideration. Next, we compare the test results to check that the task instance is non-trivial, indicated by at least one or more tests having a fail status before the solution $\\\\delta$ is applied, then a pass status after. To check this, we first define several repository-specific parsers to convert $\\\\log_{pre}$ and $\\\\log_{post}$ into mappings of test $t_i \\\\in T$ to a status $s \\\\in \\\\{\\\\text{fail}, \\\\text{pass}\\\\}$. Given these two data structures, we then check that there\"}"}
{"id": "VTF8yNQM66", "page_num": 19, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"exists at least one \\\\( t \\\\) where \\\\( s \\\\) changes from fail to pass. If no such tests are found, the task instance is removed from consideration.\\n\\nIf a task instance fulfills these two criteria, then it is included in the evaluation dataset. Table 10 displays a summary of how many task instances were removed from consideration across the construction process and execution based validation steps. We save all finalized task instances to a single .json file that is open sourced and available for download.\\n\\nAlongside the task instances, we also create a corresponding folder containing the ground truth test results. For each task instance, from their respective log pre and log post test-to-status mappings, we create a test results data structure where the keys are FAIL TO FAIL, FAIL TO PASS, PASS TO FAIL, and PASS TO PASS, and the values are lists of tests. By \u201ccaching\u201d these results, we remove the need to re-run the solution \\\\( \\\\delta \\\\) at evaluation time (although re-running is an available option). We use this data structure to verify task completion, as discussed in Section A.4.\\n\\nA.4 EVALUATION PROCEDURE\\n\\nFigure 8: Visualization of the evaluation pipeline at an individual task instance level. During evaluation, the Patch is model generated. A prediction \\\\( \\\\hat{\\\\delta}.patch \\\\) must be applied successfully and produce the same results as the corresponding task instance's D for task completion.\\n\\nWe provide a visualization of the evaluation procedure in Figure 8. The evaluation procedure scores the model's \\\\( \\\\hat{\\\\delta}.patch \\\\) generation with respect to the behavior of the solution \\\\( \\\\delta \\\\). At a finer-grained level, the evaluation procedure can be broken down into four separate steps, highlighted by the numbered steps in Figure 8. First, the codebase and problem statement are visible and given to the...\"}"}
{"id": "VTF8yNQM66", "page_num": 20, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"LM; the LM then generates a \\\\( \\\\hat{\\\\delta} \\\\). In the evaluation step, the following steps are performed per prediction on the target task instance:\\n\\n1. Remove any file changes and checkout the task instance's base commit. This sets the repository to codebase \\\\( C \\\\).\\n2. Activate the executable context corresponding to the task instance's version.\\n3. Run installation command to instantiate codebase \\\\( C \\\\).\\n4. Apply test patch \\\\( T \\\\) to codebase \\\\( C \\\\).\\n5. Apply prediction patch \\\\( \\\\hat{\\\\delta} \\\\) to codebase \\\\( C \\\\) with tests \\\\( T \\\\).\\n6. If the previous step fails, we attempt to fix prediction patch \\\\( \\\\hat{\\\\delta} \\\\) automatically and reapply it.\\n7. Run the testing script, determined from test patch \\\\( T \\\\), to generate test result logs \\\\( \\\\log \\\\hat{\\\\delta} \\\\).\\n\\nSteps 1 through 4 reliably do not fail due to verification during the task instance validation process. If applying the prediction patch (Step 5) fails, we attempt to repair the prediction patch file by removing unnecessary context lines and recalculating the header values (Step 6). If the remaining patch fails again or running the test command (Step 7) fails, then the prediction is automatically given a score of 0. Assuming these steps succeed, the output log \\\\( \\\\log \\\\hat{\\\\delta} \\\\) can then be converted to a test-to-status mapping, identical in structure to the via the appropriate, repository-specific parser introduced in \u00a7 A.3.\\n\\nEvaluation Metrics Calculation.\\nTo determine task completion, we compare the test-to-status mapping parsed from \\\\( \\\\log \\\\hat{\\\\delta} \\\\) with the list of tests corresponding to the \\\\texttt{FAIL TO PASS} and \\\\texttt{PASS TO PASS} keys from the ground truth test results data structure. Determining task completion is straightforward; we check that all \\\\texttt{FAIL TO PASS} and \\\\texttt{PASS TO PASS} tests are found and have a pass status in the evaluation test-to-status mapping. If a test is missing or has a non-pass status, it is considered a fail status. As defined and used in the main paper, a task is considered solved if all tests across \\\\texttt{FAIL TO PASS} and \\\\texttt{PASS TO PASS} pass.\\n\\nA.5 EVALUATION TEST CHARACTERIZATION\\nWe include an expanded form of Table 1 that includes repository specific statistics in Table 11. Table 12 presents a brief description of each repository extracted from the repository's documentation along with the repository's associated open source license. The associated licenses all permit non-commercial usage of the original library source code as long as the permissions in the original licenses are upheld and retained. In addition to the original statistics presented in Table 1, we introduce three new values. The \\\\texttt{# Lines Added} and \\\\texttt{# Lines Removed} together sum up to \\\\texttt{Lines Edited}. \\\"Added\\\" refers to the number of new lines that are introduced, while \\\"Removed\\\" are pre-existing lines taken out by the solution. The \\\\texttt{| T | (Pass to Pass)} statistic refers to the number of tests that were passing before the solution \\\\( \\\\delta \\\\) was applied during the validation pipeline. Unlike \\\\texttt{fail to pass} tests that are intended to characterize the problem statement \\\\( P \\\\) and determine if a revision addresses the issue, \\\\texttt{pass to pass} tests are included to ensure that the revision does not break or violate any existing expected behavior. These tests are extracted during the validation log examination phase as discussed in \u00a7 A.3. We note that \\\\texttt{fail to fail} tests and \\\\texttt{pass to fail} tests are not considered during evaluation, and those statistics are not reflected in the above table.\\n\\nTask Instance Issue Categories.\\nTo provide a better sense of the types of problems that SWE-bench task instances include, we perform simple analyses on the issues, identified by the issue numbers field, for each task instance. Per issue, we inspect metadata, specifically tags, to characterize the type of contribution put forth by the PR. Table 13 groups and shows several examples of the 2,289 tags we found across all issues. While the absolute majority of issues are associated with bug fixes, SWE-bench's task instances are associated with a diverse set of code changes with purposes beyond debugging and error correction.\\n\\nAttribute Distributions.\\nIn Figure 9, we present plots of the cumulative distribution function for attributes introduced in Table 1. From these plots, we see that the median SWE-bench task instance has a problem description of 140 words, and will take place within a codebase containing just shy of 1900 files and 400K lines. The corresponding reference solution \\\\( \\\\delta \\\\) will usually edit a single function.\"}"}
{"id": "VTF8yNQM66", "page_num": 21, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"Figure 9: Cumulative Distribution Functions for different attributes of SWE-bench task instances.\"}"}
{"id": "VTF8yNQM66", "page_num": 22, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 11: Average numbers characterizing different attributes of a SWE-bench task instance grouped by repository. In addition to the statistics presented in Table 1, we also introduce three new values: \u03b4 # Lines Added, \u03b4 # Lines Removed, and T | (Pass to Pass).\\n\\n| Repository           | Summary          | License          |\\n|----------------------|------------------|------------------|\\n| astropy/astropy      | Astronomy and astrophysics core library | BSD 3-Clause     |\\n| django/django        | Web framework for building web applications | BSD 3-Clause     |\\n| pallets/flask        | Lightweight framework for small web apps | BSD 3-Clause     |\\n| matplotlib/matplotlib| Plotting library for creating visuals | Custom           |\\n| pylint-dev/pylint    | Static code analyser for Python | GPL 2.0          |\\n| pytest-dev/pytest    | Testing framework for Python | MIT              |\\n| psf/requests         | Simple, elegant library for writing HTTP requests | Apache-2.0       |\\n| scikit-learn/scikit-learn | Machine Learning in Python | BSD 3-Clause     |\\n| mwaskom/seaborn      | Statistical data visualization in Python | BSD 3-Clause     |\\n| sphinx-doc/sphinx    | Library for creating documentation | Custom           |\\n| sympy/sympy         | Computer algebra system written in Python | Custom           |\\n| pydata/xarray       | N-D labeled arrays and datasets | Apache-2.0       |\\n\\nTable 12: Summary and licenses for all GitHub repositories that task instances were extracted from.\\n\\nWithin a file, changing \u223c15 lines, and has a single fail to pass test to verify the correctness of the change along with pass to pass tests to check whether existing behavior is preserved.\\n\\nPatch Fix Rate. We present Table 14, which presents summary statistics of how many task instances each model generated patches for (out of 2294), how many of these patches applied successfully, and how many of the successfully applied patches required undergoing the patch fixing procedure introduced in Appendix A.4. We find that fixed patches tend to make up a smaller percentage of the SWE-Llama patches that successfully applied, suggesting that SWE-Llama's fine tuning procedure has a positive effect on generating well-formatted patches. For closed source models, fewer patches apply successfully, and of the ones that do, a greater percentage require the post-generation fix, suggesting that models still struggle with patch generation and structured outputs in general.\"}"}
{"id": "VTF8yNQM66", "page_num": 23, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2024\\n\\nTable 13: Categories of tags associated with issues from SWE-bench's task instances.\\n\\n| Category   | Count | Examples                                                                 |\\n|------------|-------|--------------------------------------------------------------------------|\\n| Bug        | 442   | \\\"Bug\\\" (179); \\\"type:bug\\\" (114); \\\"bug\\\" (57); \\\"type: bug\\\" (48); \\\"Bug :beetle:\\\" (23); \\\"status: confirmed bug\\\" (20); |\\n| Feature    | 167   | \\\"type:enhancement\\\" (47); \\\"Enhancement\\\" (25); \\\"New feature\\\" (24); \\\"Feature Request\\\" (22); \\\"type: enhancement\\\" (19); \\\"Enhancement :star:\\\" (15); \\\"New Feature\\\" (7); \\\"enhancement\\\" (6); |\\n| Regression | 39    | \\\"type: regression\\\" (14); \\\"Regression\\\" (14); \\\"regression\\\" (8); |\\n| Other      | 1641  | \\\"help wanted\\\" (71); \\\"good first issue\\\" (66); \\\"printing\\\" (58); \\\"extensions:autodoc\\\" (58); \\\"Easy\\\" (57); \\\"Easy to Fix\\\" (54); \\\"domains:py\\\" (27); \\\"core\\\" (26); \\\"sets\\\" (23); \\\"Wrong Result\\\" (23); \\\"units\\\" (22); \\\"Good first issue\\\" (21); |\\n\\nTable 14: Statistics for how many patches for 2,294 task instances were generated, applied successfully, and required a post-generation fix to apply successfully for each [model, retrieval setting] combination during evaluation. The GPT-4 BM25 27k and \\\"Oracle\\\" settings were ran on the 25% subset. The GPT-4 \\\"Oracle\\\"-collapsed setting was run on the full SWE-bench test set.\\n\\nA.6 DEVELOPMENT SET CHARACTERIZATION\\n\\nIn addition to the evaluation test set, we also provide a development set for evaluating models and tuning hyperparameters before running on the final test set. Following the style of tables and graphs from before, we present similar statistics to characterize the 225 development task instances (slightly more than 10% of the main evaluation set) collected from 6 open source repositories with licenses permitting such usage. The development set was collected following the exact same set of methodologies and filters as the main evaluation set. In addition to the pre-existing steps, we also filter the development set to keep task instances that were created after January 1, 2019. Similar to Table 12, in Table 15, we briefly summarize the purpose and licenses of the 6 selected repositories.\\n\\nFollowing Table 13, we also list the tags associated with the development set tasks in Table 16, again showcasing the diversity and coverage of task types beyond fixing bugs. Compared to the main evaluation tasks, we can also see tags (e.g., \\\"Crash :collision:;, \\\"io\\\") that refer to issues presenting problems which are unique to the repositories in the development set.\\n\\nFollowing Table 1, we present the same set of repository-specific average statistics for the 6 repositories in the development set in Table 17. Across the entire development set, each task instance has 19.9 average / 2 median F2P tests. There are 171.3 average / 79.0 median P2P tests, and 191.2 average / 101.0 median tests in total per task instance.\"}"}
{"id": "VTF8yNQM66", "page_num": 24, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Optimization. We finetune using LoRA (Hu et al., 2022) with $r=16$, $\\\\alpha=16$, dropout $=0.05$, on the query, key, value, and output projection matrices of every attention sublayer. We train with a learning rate of $6 \\\\times 10^{-4}$ and a batch size of 32 sequences per gradient step for a maximum of 4 epochs. During training, we save checkpoints every 50 steps, and after training, select the best checkpoint based on the validation loss on a held-out 100 instances. SWE-Llama 7b was initialized with CodeLlama-Python 7b and trained in 20 hours on 4 NVIDIA A100s. SWE-Llama 13b was initialized with CodeLlama-Python 13b and trained in 47 hours on 8 NVIDIA A100s. We used DeepSpeed Ulysses (Jacobs et al., 2023) and Flash Attention (Dao et al., 2022) to enable long context training.\\n\\n**C.1 RESULTS WITH \u201cORACLE\u201d RETRIEVAL**\\n\\nUsing the \u201coracle\u201d retrieval method described in Section 4.1, we show the general performance results in Table 18. Naturally, providing only the files edited by the reference solution's pull request, model performance improves compared to the noisier BM25 retrieval setting.\\n\\n**C.2 EVALUATION TEST SET**\\n\\nWe include a repository-by-repository breakdown of model performance in Table 19 that corresponds to Figure 4 in the main paper. As discussed, in the main paper, performance differs heavily across repositories.\\n\\n**C.3 GPT-4 EVALUATION SUBSET RESULTS**\\n\\nIn this section, we present the statistics shown in Table 5 for the 25% random subset that GPT-4 was tested in Table 20. As the selection of the subset is random, we find that the % Resolved and % Apply rates are consistent with the main results, and not significantly skewed towards being simpler or more difficult than the general evaluation set.\"}"}
{"id": "VTF8yNQM66", "page_num": 25, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 17: Average numbers characterizing different attributes of a SWE-bench task instance grouped by repository for repositories in the development dataset. The same statistics presented in Table 11 are also shown here.\\n\\n| Model          | % Resolved | % Apply | % Resolved | % Apply |\\n|----------------|------------|---------|------------|---------|\\n| Claude         | 1.96       | 43.07   | 4.80       | 62.82   |\\n| ChatGPT-3.5    | 0.17       | 26.33   | 0.52       | 21.80   |\\n| GPT-4          | 0.00       | 14.83   | 1.74       | 34.00   |\\n| SWE-Llama 7b   | 0.70       | 51.74   | 3.01       | 65.52   |\\n| SWE-Llama 13b  | 0.70       | 53.62   | 3.97       | 66.78   |\\n\\nTable 18: We compare models against each other using the BM25 and oracle retrieval settings as described in Section 4. The main results table, Table 5, presents the results for the different models when using BM25 only.\\n\\n* Due to budget constraints we evaluate GPT-4 on a 25% random subset of SWE-bench in the \u201cOracle\u201d and BM25 27K retriever settings only.\\n\\nC.4 EXTENDED TEMPORAL ANALYSIS\\n\\nIn this section, we present an extended temporal analysis of task instances solved by year that follows the analysis shown in Table 7 of the evaluation section in the main paper. In Table 21, we present the % Resolved statistic across models under the \u201cOracle\u201d retrieval setting for 6 different temporal partitions that group tasks by the years in which the issues were created. It is evident from the table that there is no consistent correlation between model performance and year, supporting our conclusion that despite having potentially seen older versions of code within its pre-training datasets, understanding and implementing in fixes in SWE-bench is a difficult task that requires understanding and cannot be accomplished feasibly or consistently via memoization of observed data.\\n\\nC.5 F2P, P2P RATE ANALYSIS\\n\\nIn the main paper results, we present the \u201c% Resolved\u201d statistic that indicates how many task instances were completely solved by the different models. In this section, we provide more fine-grained insight into the gap of task instances where 1. The model\u2019s patch generation was applied successfully and 2. The task instance was not resolved. Assuming a patch is applied successfully, we define 6 cases in Table 22 that fully capture the distribution of all possible outcomes based on the pass/fail results of F2P and P2P tests. In addition to the \u201cResolved\u201d outcome that has been established, we introduce five new terms. The \u201cBreaking Resolved\u201d outcome refers to when the desired behavior of the issue has been accomplished (all F2P tests pass), but not all prior behavior is maintained (not all P2P tests pass). \u201cPartially Resolved\u201d refers to when prior behavior of a codebase was maintained (all P2P tests pass); however, the desired behavior is not fully accomplished (not all F2P tests pass). The \u201cWork in Progress\u201d case is when the desired behavior is not fully accomplished (not all F2P tests pass) and the prior behavior of the codebase is not maintained (not all P2P tests pass). A \u201cNo-Op\u201d is when a code change does not have any effect on the original codebase; prior\"}"}
{"id": "VTF8yNQM66", "page_num": 30, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2024\\n\\nA single patch file can contain changes to multiple files.\\n\\n```patch\\n--- a/file.py\\n+++ b/file.py\\n@@ -1,27 +1,35 @@\\ndef euclidean(a, b):\\n    if b == 0:\\n        return a\\n    return euclidean(b, a % b)\\n\\ndef bresenham(x0, y0, x1, y1):\\n    points = []\\n    dx = abs(x1 - x0)\\n    dy = abs(y1 - y0)\\n    x, y = x0, y0\\n    sx = -1 if x0 > x1 else 1\\n    sy = -1 if y0 > y1 else 1\\n    err = dx / 2.0\\n    while x != x1:\\n        points.append((x, y))\\n        err -= dy\\n        if err < 0:\\n            x += sx\\n            err += dy\\n            y += sy\\n    while y != y1:\\n        points.append((x, y))\\n        err -= dx\\n        if err < 0:\\n            x += sx\\n            err += dy\\n            y += sy\\n    points.append((x, y))\\n    return points\\n```\\n\\nI need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply. Please respond with a single patch file in the format shown above.\\n\\n```\\n```\"}"}
{"id": "VTF8yNQM66", "page_num": 31, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Experiments using slightly more or fewer lines of instructions or examples seemed to not affect overall performance substantially, except for the findings of experiments stated in Section 5.\\n\\nAs reasoning on code has emerged as a foundational skill underlying many LM's capability, a potential future of machine-automated software engineering raises many important questions and has important potential ramifications with regards to AI Safety (Gros et al., 2023). It is important to address questions on how to ensure AI-generated code is faithful to human intents and what guardrails might be in place when human objectives are misinterpreted by code agents that then carry out the task. To observe such problems in a controlled setting and manifest their solutions, we hope SWE-bench might serve as a testbed for designing safe, robust measures towards aligned, verifiable, and safe AI-driven software engineering.\\n\\nIn this section, we provide five additional qualitative analyses of generations from both Claude 2 and SWE-Llama generations (Oracle retrieval setting) following the style of Section 5.1. Claude 2 qualitative studies can be found in Tables 25 and 26. Tables 27, 28, and 29 are task instances that Claude 2 did not address correctly. SWE-Llama qualitative studies are covered across Tables 30, 31, 32, 33, 34. For Tables 30, 31, and 32, we present task instances solved correctly by SWE-Llama 13b. In Table 33 and 34, we present two task instances where SWE-Llama 13b does not address the issue correctly, pointing out a subset of the reasoning and generation skills that models may not be adept at enough to accomplish the task at hand.\\n\\nThe observations we make across these sections corroborate with the points stated in the main paper, which is that models tend to struggle with multi-line and multi-file changes, are more adept when the required fix is relatively short, and need help with understanding the codebase in an efficient manner.\"}"}
{"id": "VTF8yNQM66", "page_num": 32, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 25: In this example, Claude 2 correctly addresses an issue from scikit-learn/scikit-learn. However, as demonstrated in the discussion, while the solution is correct, it demonstrates models' tendency to write primitive Python and not employ existing methods within the codebase.\\n\\n| Setting | Model: Claude 2 with Oracle retrieval |\\n|---------|--------------------------------------|\\n| Task Instance: | scikit-learn | scikit-learn-13328 |\\n\\n\u2013 Link to Issue: [GitHub Pull Request](https://github.com/scikit-learn/scikit-learn/pull/13314)\\n\u2013 Link to PR: [GitHub Issue](https://github.com/scikit-learn/scikit-learn/issues/13328)\\n\\n**Issue**\\n\\n**TypeError when supplying a boolean X to HuberRegressor fit**\\n\\n**#### Description**\\n\\n'TypeError' when fitting 'HuberRegressor' with boolean predictors.\\n\\n**Steps/Code to Reproduce**\\n\\n```python\\nimport numpy as np\\nfrom sklearn.datasets import make_regression\\nfrom sklearn.linear_model import HuberRegressor\\n\\n# Random data\\nX, y, coef = make_regression(n_samples=200, n_features=2, noise=4.0, coef=True, random_state=0)\\nX_bool = X > 0\\nX_bool_as_float = np.asarray(X_bool, dtype=float)\\n\\n# Works\\nhuber = HuberRegressor().fit(X, y)\\n# Fails (!)\\nhuber = HuberRegressor().fit(X_bool, y)\\n# Also works\\nhuber = HuberRegressor().fit(X_bool_as_float, y)\\n```\\n\\n**Expected Results**\\n\\nNo error is thrown when 'dtype' of 'X' is 'bool' (second line of code in the snippet above, `huber = HuberRegressor().fit(X_bool, y)`). Boolean array is expected to be converted to 'float' by 'HuberRegressor.fit' as it is done by, say 'LinearRegression'.\\n\\n**Actual Results**\\n\\n'TypeError' is thrown:\\n\\n```\\n(Remaining lines omitted)\\n```\\n\\n**Gold Patch**\\n\\n```bash\\ndiff --git a/sklearn/linear_model/huber.py b/sklearn/linear_model/huber.py\\n--- a/sklearn/linear_model/huber.py\\n+++ b/sklearn/linear_model/huber.py\\n@@ -251,7 +251,8 @@\\n     def fit(self, X, y, sample_weight=None):\\n         self :\\n             object\\n-        X, y = check_X_y(- X, y, copy=False, accept_sparse=['csr'], y_numeric=True)\\n+        X, y, copy=False, accept_sparse=['csr'], y_numeric=True,\\n+        dtype=[np.float64, np.float32])\\n         if sample_weight is not None:\\n             sample_weight = np.array(sample_weight)\\n             check_consistent_length(y, sample_weight)\\n```\"}"}
{"id": "VTF8yNQM66", "page_num": 33, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Model Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Generated Patch\\n\\n---\\n\\nModel Genera"}
{"id": "VTF8yNQM66", "page_num": 50, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 34: In this final example, SWE-Llama 13b not only does not solve the task, but also corrupts existing behavior in the model. This example demonstrates the need for models to understand the codebase beyond the scope of the required edits.\\n\\n| Setting |\\n|---------|\\n| Model: SWE-Llama 13B with Oracle retrieval |\\n| Task Instance: scikit-learn |\\n\\n- Link to Issue: https://github.com/scikit-learn/scikit-learn/issues/8798\\n- Link to PR: https://github.com/scikit-learn/scikit-learn/pull/13241\\n\\n**Issue**\\n\\nDifferences among the results of KernelPCA with rbf kernel\\n\\n**Description**\\n\\nWhen I run KernelPCA for dimension reduction for the same datasets, the results are different in signs.\\n\\n**Steps/Code to Reproduce**\\n\\nJust to reduce the dimension to 7 with rbf kernel:\\n\\n```python\\npca = KernelPCA(n_components=7, kernel='rbf', copy_X=False, n_jobs=-1)\\npca.fit_transform(X)\\n```\\n\\n**Expected Results**\\n\\nThe same result.\\n\\n**Actual Results**\\n\\nThe results are the same except for their signs:\\n\\n```\\n[-0.44457 -0.18155 -0.10873 0.13548 -0.14371 -0.05746 0.18124]\\n[ 0.44457 0.18155 0.10873 -0.13548 -0.14371 -0.05746 -0.18124]\\n[-0.44457 -0.18155 0.10873 0.13548 0.14371 0.057469 0.18124]\\n```\\n\\n**Gold Patch**\\n\\n```diff\\n--- a/sklearn/decomposition/kernel_pca.py\\n+++ b/sklearn/decomposition/kernel_pca.py\\n@@ -8,6 +8,7 @@\\n    from ..utils import check_random_state\\n    from ..utils.extmath import svd_flip\\n    from ..utils.validation import check_is_fitted, check_array\\n+   from ..utils.extmath import svd_flip\\n    from ..base import BaseEstimator, TransformerMixin, _UnstableOn32BitMixin\\n\\n@@ -210,6 +211,10 @@\\n         def _fit_transform(self, K):\\n             maxiter=self.max_iter,\\n             v0=v0)\\n+           # flip eigenvectors' sign to enforce deterministic output\\n+           self.alphas_, _ = svd_flip(self.alphas_,\\n+                                       np.empty_like(self.alphas_).T)\\n+           # sort eigenvectors in descending order\\n+           indices = self.lambdas_.argsort()\\n+           self.lambdas_ = self.lambdas_[indices]\\n```\\n```\"}"}
{"id": "VTF8yNQM66", "page_num": 51, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"A model is given an observation that the parities of the output from a call to the `fit_transform` function are flipped. The model is also given lines of Python code and its standard output that recreates the issue. The gold patch imports and uses the `svd_flip` function to solve this issue within a different line of the `_fit_transform` function. What's different about the model's failure for this task beyond the points discussed for the Table 33 example is that, in addition to understanding third party dependencies that its edits rely on, it is also important for a model to understand what other parts of the codebase in turn depend on the function it is changing. This example presents a different facet as to why processing long contexts extend beyond the local edit scope is a difficult but worthwhile challenge.\"}"}
{"id": "VTF8yNQM66", "page_num": 6, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 5: We compare models against each other using the BM25 retriever as described in Section 4.\\n\\n| Model          | % Resolved | % Apply |\\n|----------------|------------|---------|\\n| Claude 2       | 1.96       | 43.07   |\\n| ChatGPT-3.5    | 0.17       | 26.33   |\\n| GPT-4          | 0.00       | 14.83   |\\n| SWE-Llama 7b   | 0.70       | 51.74   |\\n| SWE-Llama 13b  | 0.70       | 53.62   |\\n\\nDue to budget constraints we evaluate GPT-4 on a 25% random subset of SWE-bench.\\n\\nFigure 4: Resolution rate for three models across the 12 repositories represented in SWE-bench in the \u201cOracle\u201d retrieval setting.\\n\\nSWE-Llama 13b perform comparably, with each model resolving 110 and 91 instances respectively. Yet of these instances, Claude 2 only solves 42% of the instances solved by SWE-Llama. This may also be related to the presence of images in issues, which can be encoded into the issue markdown with embedded image links (i.e. ![image][https://...]). Some repositories naturally feature more instances with images; for example 32% of matplotlib and 10% of seaborn instances contain embedded images in their issue text compared to just 2% of all instances. Solving these instances may require multi-modal LMs or some kind of external tool use to process images.\\n\\nDifficulty correlates with context length. Chat models may be pre-trained on long sequences of code but are typically asked to generate shorter code snippets with limited context provided to frame the question. As shown in Figure 5, we see that as total context length increases, Claude 2\u2019s performance drops considerably; behavior that is also observed in other models. In our evaluation settings, models see a lot of code that may not be directly related to solving the issue at hand, and they seem to frequently struggle with localizing problematic code needing to be updated. This result corroborates other studies showing that models become distracted by additional context and may be sensitive to the relative location of target sequences (Liu et al., 2023b). Even when increasing the maximum context size for BM25 would increase recall with respect to the oracle files, performance drops, as shown in Table 2, as models are simply ineffective at localizing problematic code.\\n\\nFigure 5: We compare the performance of Claude 2 on tasks partitioned by total input length and by only the issue length.\\n\\nTable 6: We show the results for the \u201cOracle\u201d-collapsed retrieval setting, which uses oracle files but collapses code that isn\u2019t directly modified by the PR \u00b1 15 lines.\\n\\n| Model          | % Resolved | % Apply |\\n|----------------|------------|---------|\\n| ChatGPT-3.5    | 1.09       | 40.93   |\\n| Claude 2       | 5.93       | 68.18   |\\n| GPT-4          | 3.40       | 48.65   |\\n\\nFurther investigating this, we provide an input ablation on the \u201coracle\u201d retrieval context, \u201coracle\u201d-collapsed, where retrieved files are collapsed entirely, except for the lines actually edited by the true pull request (with \u00b1 15 lines of buffer) shown in Table 6. In this setting, we see increases in performance, with GPT-4 jumping from 1.3% to 3.4% and Claude 2 from 4.8% to 5.9%.\"}"}
{"id": "VTF8yNQM66", "page_num": 7, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Difficulty does not correlate with issue resolution date. In Table 7 we show model results in the \u201coracle\u201d retrieval setting, partitioned by date, for PRs created before or after 2023. We find that for most models there\u2019s little difference in performance before or after this date, with the exception of GPT-4. We consider this result to be largely promising as it suggests that despite models having been exposed to some version of a repository\u2019s codebase, they are unlikely to \u201ccheat\u201d to address issues simply by generating a more recent version of the repository.\\n\\n|                         | Before 2023 | After 2023 |\\n|-------------------------|-------------|-------------|\\n| Claude 2                | 4.87        | 4.23        |\\n| ChatGPT-3.5             | 0.49        | 0.77        |\\n| GPT-4                   | 1.96        | 0.0         |\\n| SWE-Llama 7b            | 2.95        | 3.46        |\\n| SWE-Llama 13b           | 3.98        | 3.85        |\\n\\nDue to budget constraints, GPT-4 is evaluated on a 25% random subset of SWE-bench tasks, which may impact performance.\\n\\nFinetuned models are sensitive to context distribution shifts. The finetuned models SWE-Llama 7b and 13b perform surprisingly poorly with BM25 retrieved context. As these models were fine-tuned using the \u201coracle\u201d retrieval as context, we suspect this shift in context makes it difficult for the model to perform reliably. For instance, SWE-Llama was trained to edit every file included as context whereas in the BM25 setting many files provided in context are not expected to be changed.\\n\\nGenerating patches is easier than generating whole files. Models are often trained using standard code files and likely rarely see patch files. We generally formulate our task to have models generate patch files as opposed to recreating the entire file with their proposed change, since patch files will usually be a much more efficient representation of a file change. As shown in Table 5, we observe that models still struggle with generating well-formatted patch files. So we experiment with asking models to instead regenerate entire files with their proposed changes to resolve the issue. In this setting, we find that models generally perform worse at this task than when generating patch files; for instance, Claude 2 scores at 22% compared to 4.8% in the main table for \u201coracle\u201d retrieval.\\n\\nEven when controlling for instance length, generating on the shorter half of the task instances by input tokens yields 3.9% compared to 7.8% for generating patches with Claude 2.\\n\\nLanguage models tend to generate shorter, simpler edits. Model generated patch files tend to add and remove fewer lines than their respective gold patch. As shown in Table 8, compared to an average gold patch, model generated patch files that apply correctly are less than half the total length (74.5 versus 30.1 lines) of gold edit patch files, and rarely edit more than a single file.\\n\\n| Model              | Total Lines Added | Removed | Functions | Files |\\n|--------------------|-------------------|---------|-----------|-------|\\n| Claude 2           | 19.6              | 4.2     | 1.9       | 1.1   |\\n| Gold               | 44.1              | 12.0    | 5.8       | 2.1   |\\n| ChatGPT-3.5        | 30.1              | 3.8     | 2.7       | 1.6   |\\n| Gold               | 39.6              | 9.5     | 6.1       | 1.9   |\\n| GPT-4              | 20.9              | 4.4     | 1.5       | 1.0   |\\n| Gold               | 33.6              | 8.4     | 3.8       | 1.9   |\\n| SWE-Llama 13b      | 17.6              | 1.6     | 1.2       | 1.2   |\\n| Gold               | 37.8              | 10.0    | 4.4       | 1.9   |\\n| SWE-Llama 7b       | 16.7              | 1.3     | 1.2       | 1.2   |\\n| Gold               | 40.2              | 11.3    | 4.9       | 1.9   |\\n| Avg Gold           | 39.1              | 10.2    | 5.0       | 1.9   |\\n| All Gold           | 74.5              | 22.3    | 10.5      | 3.0   |\"}"}
{"id": "VTF8yNQM66", "page_num": 8, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"5.1 A Qualitative Analysis of SWE-Llama Generations\\n\\nWe select 11 generations from SWE-Llama and Claude 2 to better understand the quality of the task and generated patches under the \\\"oracle\\\" retrieval setting. Here we discuss an example from SWE-Llama and our overall findings, with in-depth analyses for other examples shown in Appendix F.\\n\\n```\\ndef format_docutils_params(self, fields):\\n    return self._format_fields(self._consume_fields())\\n\\n# type: (unicode) -> List[unicode]\\n```\\n\\n### Problem\\n\\nCurrently, napoleon renders the \\\"Other Parameters\\\" section as if napoleon.use_param was False, see source...\\n\\nFigure 6: We show an example of an formatted task instance, a model prediction, and the testing framework logs. In the patches, red highlights are deletions. Green highlights are additions. We'll consider the task instance from the Sphinx documentation generator, shown in Figure 6. The issue states that the napoleon extension of Sphinx is not properly formatting the documentation keyword \\\"Other Parameters\\\" when the config setting napoleon.use_param is set to True. The issue text further provides a detailed code snippet of where the problematic source code is suspected to be, as well as some code examples for reproducing the error and additional information related to package versions. For this particular instance, the model did not resolve the task, failing to pass some of the tests resolved by the gold solution. In the \\\"oracle\\\" retrieval setting, the model input provides this issue text along with some instructions, the full contents of files edited by the gold patch, and an example of the diff format we expect the answer to be in. The total model input consists of 1,558 lines of context or 20,882 tokens. When comparing the gold patch and the model's patch, we find an obvious mistake. While the model edits the correct function, _parse_other_parameters_section at line 684 in sphinx/ext/napoleon/docstring.py, it changes the function to behave as if napoleon.use_param were always True instead of checking the config setting first and copying what the _parse_parameters_section does, like the gold patch. In the tests, test_parameters_with_class_reference directly compares the documentation produced using a config where napoleon_use_param is set to False, which catches the model's error immediately.\\n\\nComparing results across all the examples we consider, we notice a few prominent trends in behavior. Models tend to write primitive Python code and do not leverage existing third-party libraries or the rest of the codebase for their solutions. Models' generations also reflect a \\\"greedy\\\" approach of solving the problem exactly, with little regard for code style or logical constraints that might be reflected by the codebase (i.e. using relative instead of absolute imports). In contrast, we observe that many gold patches will make structural improvements that cover a much larger scope of the codebase; these edits not only resolve the issue, but also anticipate and solve potential future issues.\\n\\n6 Related Work\\n\\nEvaluation of LMs. Several recent works for evaluating LMs have either proposed a collection of mutually distinct tasks spanning across multiple domains (Hendrycks et al., 2021; Liang et al., 2022; Srivastava et al., 2023) or turned to the web as an interactive setting featuring tasks that require...\"}"}
{"id": "VTF8yNQM66", "page_num": 9, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"multiple steps to solve (Yao et al., 2022; Zhou et al., 2023; Deng et al., 2023; Liu et al., 2023d). There are several drawbacks with such a \u201cpotpourri\u201d style setup. First, each task tends to narrowly focus on one or a few skills, resulting in challenges that are typically too simple, pigeonhole the model into a reduced role, and do not provide models with the bandwidth to exercise their versatility or potentially demonstrate new abilities (Srivastava et al., 2023). Consequently, a model's performance on such task conglomerations may not yield actionable, deep insights regarding its capabilities and how to improve them (Schlangen, 2019; Mart\u00ednez-Plumed et al., 2021; Bowman & Dahl, 2021). SWE-bench addresses these shortcomings, as our work demonstrates that it is significantly challenging, presents a wide range of possibilities for improving LMs to solve this task, and is easy to refresh over time with new task instances, each of which introduce novel, nuanced, and practical challenges.\\n\\nHumanEval (Chen et al., 2021) is the current standard in a long-standing pursuit of synthesizing code from natural language descriptions (Yu et al., 2018; Austin et al., 2021; Hendrycks et al., 2021; Li et al., 2022a; Zan et al., 2023). In the past year, subsequent benchmarks have sought to augment HumanEval with extensions to different languages (Cassano et al., 2022; Athiwaratkun et al., 2023; Orlanski et al., 2023), variations in edit scope (Yu et al., 2023; Du et al., 2023), similar but novel code completion tasks (Muennighoff et al., 2023), and more testing (Liu et al., 2023a). Simultaneously, separate works have sought to introduce new coding paradigms (Yin et al., 2022; Yang et al., 2023) or design library-specific problems (Lai et al., 2022; Zan et al., 2022). Instead of partitioning problems into siloed datasets and curtailing them for simplicity's sake, SWE-bench's collection procedure transforms the source code with minimal post-processing, preserving a much broader set of challenges grounded in real-world software engineering beyond closed form completion, such as patch generation, reasoning over long contexts, navigating a codebase directory, and capturing dependency-based relationships across modules.\\n\\nML for Software Engineering.\\n\\nTo overcome traditional program analysis techniques that may not scale or incorporate natural language, one direction of current software engineering research is to use neural networks, including LMs, to automate real-world software development processes (Maniatis et al., 2023; Zheng et al., 2023; Hou et al., 2023). Use cases include automating commit generation (Jung, 2021; Liu et al., 2023c), PR review (Yang et al., 2016; Li et al., 2022b; Tufano et al., 2021), bug localization Kim et al. (2019); Chakraborty et al. (2018), testing (Kang et al., 2023; Xia et al., 2023; Wang et al., 2023), and program repair (Gupta et al., 2017; Allamanis et al., 2017; Monperrus, 2018; Jiang et al., 2018; Goues et al., 2019; Gao et al., 2022; Dinh et al., 2023; Motwani & Brun, 2023). Most relevant to SWE-bench are works that have sought to apply LMs towards automated program repair (Xia & Zhang, 2022; 2023; Fan et al., 2023; Sobania et al., 2023), guiding code editing with commits (Chakraborty & Ray, 2021; Zhang et al., 2022; Fakhoury et al., 2023).\\n\\nHowever, none of the existing datasets (Just et al., 2014; Karampatsis & Sutton, 2019) present code context at the scale of SWE-bench. Moreover, SWE-bench can be easily extended to new programming languages and repositories, and it provides a significantly more realistic and challenging arena to carry out experiments towards augmenting LMs with software engineering tools and practices.\\n\\nLIMITATIONS AND FUTURE DIRECTIONS.\\n\\nSWE-bench task instances are all in Python; we hope to apply SWE-bench's task instance collection procedure to expand its coverage to more programming languages and domains. Second, our experiments aim to establish a baseline of the simplest and most straightforward approaches for this task; we do not intend to constrain future methodologies to the same type of approach and encourage future work to investigate different methods (e.g., agent-based approaches, tool augmented LMs). Lastly, while this work evaluates models using execution-based code testing, relying solely on this method is insufficient to guarantee reliable performance of model generations, as we find automated code generations from LMs can frequently be less comprehensive, efficient, or readable compared to human-written solutions.\\n\\nCONCLUSION.\\n\\nThe complexity of real-world software development processes extends far beyond just code completion. By drawing on the open-source collaborative pipeline, SWE-bench creates a faithful mirror of real world coding environments. This more realistic environment encourages creative solutions that can have immediate applicability in open-source software development. We hope that this benchmark and our other contributions can serve as valuable assets in the future development of LMs that are more practical, intelligent, and autonomous.\"}"}
{"id": "VTF8yNQM66", "page_num": 1, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Language models have outpaced our ability to evaluate them effectively, but for their future development it is essential to study the frontier of their capabilities. We find real-world software engineering to be a rich, sustainable, and challenging testbed for evaluating the next generation of language models. To this end, we introduce SWE-bench, an evaluation framework consisting of 2,294 software engineering problems drawn from real GitHub issues and corresponding pull requests across 12 popular Python repositories. Given a codebase along with a description of an issue to be resolved, a language model is tasked with editing the codebase to address the issue. Resolving issues in SWE-bench frequently requires understanding and coordinating changes across multiple functions, classes, and even files simultaneously, calling for models to interact with execution environments, process extremely long contexts and perform complex reasoning that goes far beyond traditional code generation tasks. Our evaluations show that both state-of-the-art proprietary models and our fine-tuned model SWE-Llama can resolve only the simplest issues. The best-performing model, Claude 2, is able to solve a mere 1.96% of the issues. Advances on SWE-bench represent steps towards LMs that are more practical, intelligent, and autonomous.\\n\\nIntroduction\\n\\nLanguage models (LMs) are rapidly being deployed in commercial products such as chatbots and coding assistants. At the same time, existing benchmarks have become saturated (Kiela et al., 2021; Ott et al., 2022) and fail to capture the frontier of what state-of-the-art LMs can and cannot do. There is a need for challenging benchmarks that more accurately reflect real-world applications of LMs to help shape their future development and usage (Srivastava et al., 2023).\"}"}
{"id": "VTF8yNQM66", "page_num": 14, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Chunqiu Steven Xia and Lingming Zhang. Less training, more repairing please: revisiting automated program repair via zero-shot learning. In Proceedings of the 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering, pp. 959\u2013971, 2022.\\n\\nChunqiu Steven Xia and Lingming Zhang. Conversational automated program repair, 2023.\\n\\nChunqiu Steven Xia, Matteo Paltenghi, Jia Le Tian, Michael Pradel, and Lingming Zhang. Universal fuzzing via large language models. arXiv preprint arXiv:2308.04748, 2023.\\n\\nJohn Yang, Akshara Prabhakar, Karthik Narasimhan, and Shunyu Yao. Intercode: Standardizing and benchmarking interactive coding with execution feedback, 2023.\\n\\nXin Yang, Raula Gaikovina Kula, Norihiro Yoshida, and Hajimu Iida. Mining the modern code review repositories: A dataset of people, process and product. In Proceedings of the 13th International Conference on Mining Software Repositories, pp. 460\u2013463, 2016.\\n\\nShunyu Yao, Howard Chen, John Yang, and Karthik Narasimhan. Webshop: Towards scalable real-world web interaction with grounded language agents, 2022.\\n\\nPengcheng Yin, Wen-Ding Li, Kefan Xiao, Abhishek Rao, Yeming Wen, Kensen Shi, Joshua Howland, Paige Bailey, Michele Catasta, Henryk Michalewski, Alex Polozov, and Charles Sutton. Natural language to code generation in interactive data science notebooks, 2022.\\n\\nHao Yu, Bo Shen, Dezhi Ran, Jiaxin Zhang, Qi Zhang, Yuchi Ma, Guangtai Liang, Ying Li, Tao Xie, and Qianxiang Wang. Codereval: A benchmark of pragmatic code generation with generative pre-trained models, 2023.\\n\\nTao Yu, Rui Zhang, Kai Yang, Michihiro Yasunaga, Dongxu Wang, Zifan Li, James Ma, Irene Li, Qingning Yao, Shanelle Roman, Zilin Zhang, and Dragomir Radev. Spider: A large-scale human-labeled dataset for complex and cross-domain semantic parsing and text-to-SQL task. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pp. 3911\u20133921, Brussels, Belgium, October-November 2018. Association for Computational Linguistics. doi: 10.18653/v1/D18-1425. URL https://aclanthology.org/D18-1425.\\n\\nDaoguang Zan, Bei Chen, Dejian Yang, Zeqi Lin, Minsu Kim, Bei Guan, Yongji Wang, Weizhu Chen, and Jian-Guang Lou. Cert: Continual pre-training on sketches for library-oriented code generation, 2022.\\n\\nDaoguang Zan, Bei Chen, Fengji Zhang, Dianjie Lu, Bingchao Wu, Bei Guan, Yongji Wang, and Jian-Guang Lou. Large language models meet nl2code: A survey, 2023.\\n\\nJiyang Zhang, Sheena Panthaplackel, Pengyu Nie, Junyi Jessy Li, and Milos Gligoric. Coditt5: Pretraining for source code and natural language editing, 2022.\\n\\nZibin Zheng, Kaiwen Ning, Jiachi Chen, Yanlin Wang, Wenqing Chen, Lianghong Guo, and Weicheng Wang. Towards an understanding of large language models in software engineering tasks. arXiv preprint arXiv:2308.11396, 2023.\\n\\nShuyan Zhou, Frank F. Xu, Hao Zhu, Xuhui Zhou, Robert Lo, Abishek Sridhar, Xianyi Cheng, Yonatan Bisk, Daniel Fried, Uri Alon, and Graham Neubig. Webarena: A realistic web environment for building autonomous agents, 2023.\"}"}
{"id": "VTF8yNQM66", "page_num": 15, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"A PPENDIX\\n\\nIn the appendix, we provide more thorough details regarding the dataset construction process, evaluation pipeline, and characterization of the SWE-bench benchmark.\\n\\nA BENCHMARK DETAILS\\n\\nThis section complements Section 2 with a more technical and fine-grained summary of the data collection, execution-based validation, and evaluation procedures, along with a fuller characterization of the task instances.\\n\\nA.1 HIGH LEVEL OVERVIEW\\n\\nPull request scraping.\\n\\nFrom a list of the top 5,000 most downloaded PyPI libraries during August 2023, we select the top 100 packages, identify each library's corresponding open-source GitHub repository, verify which packages have licenses allowing for free software use, and collect all PRs for these repositories via the GitHub developer API. We elect to source problems from well-trafficked repositories because widespread use usually suggests that the repository has extensive documentation, structured open-source development guidelines, and working, well-formatted code.\\n\\nTask instance construction.\\n\\nWe construct candidate task instances from PRs that satisfy three conditions. First, the PR's status must be Merged. A Merged status indicates that the PR's associated code changes were accepted and incorporated into its parent repository. Second, the PR resolves one or more issues in its repository. An issue is defined according to its canonical usage in GitHub as a digital ticket for tracking bugs, enhancements, or any general development goals for a software project. We scan a PR's title, body, and commit messages for linked issues (i.e. \\\"fixes #24\\\"). Third, the PR must introduce one or more new tests. A new test is counted when a PR's code changes edits a file path containing a testing-related keyword (e.g. \\\"test\\\", \\\"testing\\\").\\n\\nA PR that satisfies these criteria is then converted into a candidate task instance such as the example in Figure 7. The codebase \\\\( C \\\\) is identified by the repository's owner/name moniker and the pull request's base commit. Recovering the actual codebase from this information is straightforward. We create mirrors of the original GitHub repositories, where each mirror is uniquely identified as owner:name. Cloning a repository's corresponding mirror and checking out the base commit yields \\\\( C \\\\) in its pre-PR state. The problem statement \\\\( P \\\\) is an aggregate of all related issues' titles and descriptions along with any subsequent comments written before the timestamp of the PR's initial commit to avoid leakage of solution details. A PR's code changes are separated into a test patch and a gold patch \\\\( \\\\delta \\\\). \\\\( T \\\\) consists of all tests from files edited in the test patch. As shown in Figure 7, both \\\\( T \\\\) and \\\\( \\\\delta \\\\) are stored as patch files. Further details about parsing PR and semantic data is in Appendix A.2.\\n\\nExecution-based validation.\\n\\nWe verify the usability of a task instance via execution. For each candidate, we first define a virtual environment to serve as an execution context, then install \\\\( C \\\\) before applying any patches, and finally run \\\\( T \\\\) once before and once after the solution \\\\( \\\\delta \\\\) is applied.\\n\\nA candidate is removed from consideration for the final dataset if any step in the verification process fails. In addition, to ensure that a solution \\\\( \\\\delta \\\\) is non-trivial, we compare the pre-solution and post-solution validation logs to check for whether there are one or more tests in \\\\( T \\\\) where the status changes from fail to pass. Lastly, we exclude task instances with tests that invoke newly created functions or classes first introduced in the solution \\\\( \\\\delta \\\\). Since naming such constructs is typically an arbitrary process and usually not explicitly specified in the problem statement, resolving tests such as these may be an impossible task even for human developers. Information about execution contexts, codebase installation, determining test statuses from logs, and more are in Appendix A.3.\\n\\nContinuous Updates.\\n\\nSWE-bench's collection process is easily extensible to any open source code repositories, allowing for easy and low-maintenance extension to new programming languages and code domains. This design also provides SWE-bench with temporal robustness; as new language models trained on more recent source code are released over time, SWE-bench can simply be updated to produce new task instances based on PRs created after any LM's training date.\\n\\nhttps://hugovk.github.io/top-pypi-packages/\"}"}
{"id": "VTF8yNQM66", "page_num": 16, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Published as a conference paper at ICLR 2024\\n\\n```\\n1041    (self):\\n\\n1042 +    ... 9\\n```\\n\\n```\\ndef _get_loss(self, loss):\\n    if loss == 1:\\n        return 'categorical_crossentropy'\\n    if loss == 0:\\n        return 'auto'\\n    return 'binary_crossentropy'\\n\\nT est_patch\\n```\\n\\n```\\n418      stump_clf. ( , y_isnan). ( , y_isnan)\\n419\\n420 +  ():\\n421 +   # categorical_crossentropy should only be used if there\\n422 +   # are more than two classes present. PR #14869\\n423 +     \\n424 +   y  \\n425 +   gbrt  (loss )\\n426 +    pytest.raises( , match ):  gbrt. ( , y)\\n427 +\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks fi ne.\\n```\\n\\n```\\nA nd w orks"}
{"id": "VTF8yNQM66", "page_num": 17, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Concatenating these components' text data, we first remove any Markdown-style comments, then look through the remaining text for references to issue numbers (a pound # sign followed by a number) and check whether the word preceding the issue number reference is included in a set of keywords suggesting that the issue was resolved by the PR (e.g., \u201ccloses\u201d, \u201cfixes\u201d, \u201cresolves\u201d). The found issues are recorded in the issue numbers field, then separate web requests are made to retrieve each issue's data. To form the problem statement, each issue's title and body are added together and then concatenated with the next issue's if there are multiple. It is also during this step that the hints text field is created and collected from the PR's comment section, where text from comments created before the PR's initial commit. The intuition for this collection methodology is that such PR comments would likely contain natural language and pseudo-code suggestions to the original human task worker regarding how to complete the problem at hand. The experiments presented in this work do not make use of hints text, but we believe this information may be interesting for future investigations.\\n\\nCodebase. The codebase content is not stored in plaintext for every task instance. Rather, the task instance contains a reference to the relevant codebase via the repo and base commit field. Both fields are available in the original PR's data. To make retrieval of the codebase from these two elements reproducible and reliable, we create mirrors of the original repository. Mirrors for the repository constituting both the evaluation and fine tuning data are collected and open-sourced under the SWE-bench GitHub organization. Because an original repository's code may be subject to changes in its commit and edit history outside of the authors' control, we choose to create a mirror repository to ensure that later modifications to the codebase do not potentially render a task instance unusable due to a corruption or removal of the associated base commit. Additionally, we create a mirror instead of cloning and storing the latest version of a repository. This is because a mirror retains the original commit hashes, history, branches, and tags, serving as a faithful and complete history of the technical details of the original repository. A mirror does not retain stars, watchers, issues, or pull requests from the original repository.\\n\\nWe create a mirror from a repository after and within the same day when task instances were collected. The mirror retains the original repository's \\\"owner/name\\\" moniker, except that the \\\"/\\\" character is converted to a \\\"\\\\\\\" to confirm to GitHub naming conventions. Given this infrastructure, retrieving a task instance's codebase is straightforward. First, the correct mirror can be cloned from the SWE-bench organization using repo. Next, within the local copy of the mirror, checking out the base commit will reset the repository to codebase C. To proceed to another task instance from the same repository, git version control is used to automatically remove any modifications associated with the current task instance before checking out the next task instance's base commit.\\n\\nSolution, Test Patches. The solution \u03b4 and tests T are derived from the file changes data, or diff, of a PR. As mentioned in Section 2.1, the original diff along with solution \u03b4 and tests T are represented as a .patch file, a format for efficiently specifying transformations to line-based text files. Generally speaking, a .patch is structured as a list of blocks, where each block consists of a header and one or more hunks that collectively correspond to changes to a single file. The header contains metadata specifying a file path and line numbers, while the actual modifications to the target file are encoded as multiple lines prefixed by \\\"+\\\" and \\\"-\\\" to indicate additions and removals.\\n\\nTo create the tests T, we first identifying every unique block within the patch, then pick out and conglomerate blocks with file paths that contain testing-related keywords (e.g., \\\"tests\\\", \\\"testing\\\"). The remaining blocks are merged to form the solution \u03b4. We validate the robustness of the script written to parse correctly T and \u03b4 by applying both patches to the corresponding codebase C and running the tests; we then check that the results reproduce the behavior of the base PR's diff data.\\n\\nThe solution \u03b4 is saved as the patch field while the tests T are saved as the test patch field.\\n\\nRemaining Fields. The created at field is a timestamp that specifies when the base PR was created. We retain the created at field from the original data and use this field to perform temporal analysis of model performance. The version field is a string that corresponds to the release version, with respect to the repo, during which the PR was released. Depending on availability and the amount of effort required for each method, we create the version field by retrieving the information directly from the source code, building the repository locally and invoking code to display the version to standard output, or comparing the created at field with a timeline of release versions.\"}"}

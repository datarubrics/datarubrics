{"id": "bylZbZOsGA", "page_num": 45, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"So $\\\\triangle ABC$ and $\\\\triangle BCD$ are two triangles having the two angles $\\\\angle ABC$ and $\\\\angle BCA$ equal to the two (angles) $\\\\angle BCD$ and $\\\\angle CBD$, respectively, and one side equal to one side\u2014the (one) by the equal angles and common to them, (namely) $BC$. Thus, they will also have the remaining sides equal to the corresponding remaining (sides), and the remaining angle (equal) to the remaining angle [Prop. 1.26]. Thus, side $AB$ is equal to $CD$, and $AC$ to $BD$. Furthermore, angle $BAC$ is equal to $CDB$.\\n\\nAnd since angle $\\\\angle ABC$ is equal to $\\\\angle BCD$, and $\\\\angle CBD$ to $\\\\angle ACB$, the whole (angle) $\\\\angle ABD$ is thus equal to the whole (angle) $\\\\angle ACD$. And $BAC$ was also shown (to be) equal to $CDB$. Thus, in parallelogrammic figures the opposite sides and angles are equal to one another. And, I also say that a diagonal cuts them in half. For since $AB$ is equal to $CD$, and $BC$ (is) common, the two (straight-lines) $AB, BC$ are equal to the two (straight-lines) $DC, CB$, respectively. And angle $\\\\angle ABC$ is equal to angle $\\\\angle BCD$. Thus, the base $AC$ (is) also equal to $DB$, and triangle $\\\\triangle ABC$ is equal to triangle $\\\\triangle BCD$ [Prop. 1.4].\\n\\nThus, the diagonal $BC$ cuts the parallelogram $ACDB$ in half. (Which is) the very thing it was required to show.\"}"}
{"id": "bylZbZOsGA", "page_num": 46, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry makes the following inferences:\\n\\n\\\\[ WX \\\\parallel YZ \\\\land |WX| = |YZ| \\\\]\\n\\n\\\\[ \\\\therefore \\\\angle WYZ = \\\\angle XWY \\\\]\\n\\n\\\\[ |WX| = |YZ| \\\\]\\n\\n\\\\[ \\\\therefore \\\\triangle WYZ \\\\sim \\\\triangle YWX \\\\]\\n\\nGPT-4V correctly translates this semiformal proof to LeanEuclid as follows:\\n\\n**Diagrammatic input for UniGeo/Congruent/Thm07**\\n\\n**theorem prediction_thm07:**\\n\\n\\\\[\\n\\\\forall (W X Y Z : \\\\text{Point}) (WX XY WY YZ WZ : \\\\text{Line}),\\n\\\\]\\n\\n\\\\[\\n\\\\text{formTriangle} W X Y WX XY WY \\\\land \\\\text{formTriangle} W Y Z WY YZ WZ \\\\land X.\\\\text{opposingSides} Z WY \\\\\\\\\\n\\\\land |(W \u2212\u2212 X)| = |(Y \u2212\u2212 Z)| \\\\land \\\\neg WX.\\\\text{intersectsLine} YZ \\\\\\\\\\n\\\\rightarrow (\\\\triangle W:Y:Z).\\\\text{congruent} (\\\\triangle Y:W:X) :=\\n\\\\]\\n\\nby euclid_intros\\n\\nhave : \\\\angle W:Y:Z = \\\\angle X:W:Y := by euclid_apply proposition_29''' X Z W Y WX YZ WY euclid_finish\\n\\nhave : |(W \u2212\u2212 Y)| = |(W \u2212\u2212 Y)| := by euclid_finish\\n\\nhave : (\\\\triangle W:Y:Z).\\\\text{congruent} \\\\triangle Y:W:X := by euclid_finish\\neuclid_finish\\n\\nParallel/Thm06, GPT-4V, 5-shot.\\n\\nThe diagrammatic input for this proposition is shown in Fig. F. The theorem asserts that if \\\\( \\\\angle STW \\\\) and \\\\( \\\\angle TWV \\\\) are supplementary, then \\\\( SU \\\\) is parallel to \\\\( VX \\\\). The UniGeo proof makes the following inferences:\\n\\n\\\\[ \\\\angle STW \\\\text{ and } \\\\angle TWV \\\\text{ are supplementary} \\\\]\\n\\n\\\\[ \\\\therefore \\\\angle STW + \\\\angle TWV = 180^\\\\circ \\\\]\\n\\n\\\\[ \\\\therefore \\\\angle RTS + \\\\angle STW = 180^\\\\circ \\\\]\\n\\n\\\\[ \\\\therefore \\\\angle STW + \\\\angle TWV = \\\\angle RTS + \\\\angle STW \\\\]\\n\\n\\\\[ \\\\therefore \\\\angle TWV = \\\\angle RTS \\\\]\\n\\n\\\\[ \\\\therefore SU \\\\parallel VX \\\\]\\n\\nGPT-4V correctly translates this semiformal proof to LeanEuclid as follows:\\n\\n**theorem prediction_thm06:**\\n\\n\\\\[\\n\\\\forall (S U V X R Y T W : \\\\text{Point}) (SU VX RY : \\\\text{Line}), \\\\text{distinctPointsOnLine} S U SU \\\\land \\\\text{distinctPointsOnLine} V X VX \\\\land \\\\text{distinctPointsOnLine} R Y RY \\\\land \\\\text{twoLinesIntersectAtPoint} SU RY T \\\\land \\\\text{between} S T U \\\\land \\\\text{between} R T W \\\\land \\\\text{twoLinesIntersectAtPoint} VX RY W \\\\\\\\\\n\\\\]\\n\\n46\"}"}
{"id": "bylZbZOsGA", "page_num": 47, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nFigure F. Diagrammatic input for UniGeo/Parallel/Thm06\\n\\n\\\\[ \\\\begin{align*}\\n\\\\land & V \\\\ W \\\\ X \\\\\\\\\\n\\\\land & T \\\\ W \\\\ Y \\\\\\\\\\n\\\\land & V . \\\\text{sameSide} \\\\ S \\\\ R \\\\ Y \\\\\\\\\\n\\\\land & U . \\\\text{sameSide} \\\\ X \\\\ R \\\\ Y \\\\\\\\\\n\\\\angle & S : T : W + \\\\angle & T : W : V = \\\\rightarrow \\\\neg\\n\\\\end{align*} \\\\]\\n\\nby euclid_intros\\n\\nhave :\\n\\\\[ \\\\angle & R : T : S + \\\\angle & S : T : W = \\\\]\\nby euclid_apply proposition_13 S T R W SU R Y\\n\\neuclid_finish\\n\\nhave :\\n\\\\[ \\\\angle & S : T : W + \\\\angle & T : W : V = \\\\angle & R : T : S + \\\\angle & S : T : W := \\\\]\\nby euclid_finish\\n\\nhave :\\n\\\\[ \\\\angle & T : W : V = \\\\angle & R : T : S := \\\\]\\nby euclid_finish\\n\\nhave :\\n\\\\[ \\\\neg & V X . \\\\text{intersectsLine} \\\\ S U := \\\\]\\nby euclid_apply proposition_15 R W S U T R Y\\n\\neuclid_apply proposition_27' U V T W SU VX R Y\\n\\neuclid_finish\\n\\neuclid_finish\\n\\n47\"}"}
{"id": "bylZbZOsGA", "page_num": 29, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nInput:\\n\\nInformal Proof:\\n\\nTo draw a straight-line perpendicular to a given infinite straight-line from a given point which is not on it. Let $AB$ be the given infinite straight-line and $C$ the given point, which is not on ($AB$). So it is required to draw a straight-line perpendicular to the given infinite straight-line $AB$ from the given point $C$, which is not on ($AB$). For let point $D$ have been taken at random on the other side (to $C$) of the straight-line $AB$, and let the circle $EFG$ have been drawn with center $C$ and radius $CD$ \\\\[Post.\\\\text{\\\\~3}\\\\], and let the straight-line $EG$ have been cut in half at (point) $H$ \\\\[Prop.\\\\text{\\\\~1.10}\\\\], and let the straight-lines $CG$, $CH$, and $CE$ have been joined. I say that the (straight-line) $CH$ has been drawn perpendicular to the given infinite straight-line $AB$ from the given point $C$, which is not on ($AB$). For since $GH$ is equal to $HE$, and $HC$ (is) common, the two (straight-lines) $GH$, $HC$ are equal to the two (straight-lines) $EH$, $HC$, respectively, and the base $CG$ is equal to the base $CE$. Thus, the angle $CHG$ is equal to the angle $EHC$ \\\\[Prop.\\\\text{\\\\~1.8}\\\\], and they are adjacent. But when a straight-line stood on a(nother) straight-line makes the adjacent angles equal to one another, each of the equal angles is a right-angle, and the former straight-line is called a perpendicular to that upon which it stands \\\\[Def.\\\\text{\\\\~1.10}\\\\]. Thus, the (straight-line) $CH$ has been drawn perpendicular to the given infinite straight-line $AB$ from the given point $C$, which is not on ($AB$). (Which is) the very thing it was required to do.\\n\\nProof Setup:\\n\\ndef example : \\n\\n\u2200 (a b c : Point) (AB : Line), distinctPointsOnLine a b AB \u2227 \u00ac (c.onLine AB) \u2192 \u2203 h : Point, h.onLine AB \u2227 (\u2220 a:h:c) = (\u2220 b:h:c)  :\\n\\neuclid_intros\\n\\neuclid_apply (exists_point_opposite AB c) as d\\n\\neuclid_apply (circle_from_points c d) as EFG\\n\\neuclid_apply (intersections_circle_line EFG AB) as (e, g)\\n\\neuclid_apply (proposition_10 e g AB) as h\\n\\neuclid_apply (line_from_points c g) as CG\\n\\neuclid_apply (line_from_points c h) as CH\\n\\neuclid_apply (line_from_points c e) as CE\\n\\nuse h\\n\\neuclid_apply (proposition_8 h c g h c e CH CG AB CH CE AB)\\n\\neuclid_finish\\n\\nInformal Proof:\\n\\nIn any triangle, (if) one of the sides (is) produced (then) the external angle is equal to the (sum of the) two internal and opposite (angles), and the (sum of the) three internal angles of the triangle is equal to two right-angles. Let $ABC$ be a triangle, and let one of its sides $BC$ have been produced to $D$. I say that the external angle $ACD$ is equal to the (sum of the) two internal and opposite angles $CAB$ and $ABC$, and the (sum of the) three internal angles of the triangle---$ABC$, $BCA$, and $CAB$---is equal to two right-angles. For let $CE$ have been drawn through point $C$ parallel to the straight-line $AB$ \\\\[Prop.\\\\text{\\\\~1.31}\\\\]. And since $AB$ is parallel to $CE$, and $AC$ has fallen across them, the alternate angles $BAC$ and $ACE$ are equal to one another \\\\[Prop.\\\\text{\\\\~1.29}\\\\]. Again, since $AB$ is parallel to $CE$, and the straight-line $BD$ has fallen across them, the external angle $ECD$ is equal to the internal and opposite (angle) $ABC$ \\\\[Prop.\\\\text{\\\\~1.29}\\\\]. But $ACE$ was also shown (to be) equal to $BAC$. Thus, the whole angle $ACD$ is equal to the (sum of the) two internal and opposite (angles) $BAC$ and $ABC$. Let $ACB$ have been added to both. Thus, (the sum of) $ACD$ and $ACB$ is equal to the (sum of the) three (angles) $ABC$, $BCA$, and $CAB$. But, (the sum of) $ACD$ and $ACB$ is equal to two right-angles \\\\[Prop.\\\\text{\\\\~1.13}\\\\]. Thus, (the sum of) $ACB$, $CBA$, and $CAB$ is also equal to two right-angles. Thus, in any triangle, (if) one of the sides (is) produced (then) the external angle is equal to the (sum of the) two internal and opposite (angles), and the (sum of the) three internal angles of the triangle is equal to two right-angles. (Which is) the\"}"}
{"id": "bylZbZOsGA", "page_num": 30, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"To construct a parallelogram equal to a given triangle in a given rectilinear angle. Let $ABC$ be the given triangle, and $D$ the given rectilinear angle. So it is required to construct a parallelogram equal to triangle $ABC$ in the rectilinear angle $D$.\\n\\nLet $BC$ have been cut in half at $E$ [Prop. I.10], and let $AE$ have been joined. And let (angle) $CEF$, equal to angle $D$, have been constructed at the point $E$ on the straight-line $EC$ [Prop. I.23]. And let $AG$ have been drawn through $A$ parallel to $EC$ [Prop. I.31], and let $CG$ have been drawn through $C$ parallel to $EF$ [Prop. I.31]. Thus, $FECG$ is a parallelogram. And since $BE$ is equal to $EC$, triangle $ABE$ is also equal to triangle $AEC$. For they are on the equal bases, $BE$ and $EC$, and between the same parallels, $BC$ and $AG$ [Prop. I.38]. Thus, triangle $ABC$ is double (the area) of triangle $AEC$. And parallelogram $FECG$ is also double (the area) of triangle $AEC$. For it has the same base as ($AEC$), and is between the same parallels as ($AEC$) [Prop. I.41]. Thus, parallelogram $FECG$ is equal to triangle $ABC$. ($FECG$) also has the angle $CEF$ equal to the given (angle) $D$. Thus, parallelogram $FECG$, equal to the given triangle $ABC$, has been constructed in the angle $CEF$, which is equal to $D$. (Which is) the very thing it was required to do.\"}"}
{"id": "bylZbZOsGA", "page_num": 31, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\n**NOTICE: in the above example, there is exactly one argument to 'use' for every existentially quantified variables in the theorem statement.**\\n\\nInput:\\n\\nInformal Proof:\\nIf a triangle has two angles equal to one another then the sides subtending the equal angles will also be equal to one another. Let $ABC$ be a triangle having the angle $ABC$ equal to the angle $ACB$. I say that side $AB$ is also equal to side $AC$.\\n\\nFor if $AB$ is unequal to $AC$ then one of them is greater. Let $AB$ be greater. And let $DB$, equal to the lesser $AC$, have been cut off from the greater $AB$ [Prop. 1.3]. And let $DC$ have been joined [Post. 1]. Therefore, since $DB$ is equal to $AC$, and $BC$ (is) common, the two sides $DB$, $BC$ are equal to the two sides $AC$, $CB$, respectively, and the angle $DBC$ is equal to the angle $ACB$.\\n\\nThus, the base $DC$ is equal to the base $AB$, and the triangle $DBC$ will be equal to the triangle $ACB$ [Prop. 1.4], the lesser to the greater. The very notion (is) absurd [C.N. 5]. Thus, $AB$ is not unequal to $AC$. Thus, (it is) equal. Thus, if a triangle has two angles equal to one another then the sides subtending the equal angles will also be equal to one another. (Which is) the very thing it was required to show.\\n\\n--- End of Instruction ---\\n\\nD.3. Proof Formalization (UniGeo)\\n\\nTo formalize UniGeo proofs, we likewise include those inference rules which were used in our manual formalization, as well as the relevant theorems from *Elements*. Unlike for proofs from *Elements*, we randomly select shots from a separate test set of UniGeo proofs. The guidelines are slightly different from *Elements*, to accommodate the different style of input for UniGeo proofs.\\n\\n--- Definitions ---\\n\\n- Basic Geometric Sorts -\\n  \\n  - `axiom Point : Type`\\n  - `axiom Line : Type`\\n  - `axiom Circle : Type`\\n\\n- Inductive Types for Geometric Entities -\\n  \\n  - `inductive Angle | right | ofPoints (A B C : Point)`\\n  - `inductive Segment | endpoints (a b : Point)`\\n  - `inductive Triangle | ofPoints (a b c : Point)`\\n\\n- Notations and Macros for Geometric Entities -\\n  \\n  - \\\"|(a--b)|\\\" means the length of the line segment between point a and point b.\\n  - \\\"\u2220a:b:c\\\" means the degree of the angle formed by points a, b, and c.\\n  - \\\"\\\\(\\\\square\\\\)\\\" means the right angle.\\n  - \\\"\\\\(\\\\triangle a:b:c\\\\)\\\" means the triangle formed from points a, b and c.\\n  - \\\"Triangle.area \\\\(\\\\triangle a:b:c\\\\)\\\" means the area of the triangle formed by points a, b and c.\\n\\n- Relations and Axioms for Geometric Sorts -\\n  \\n  - `31`\"}"}
{"id": "bylZbZOsGA", "page_num": 32, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nnamespace Point\\n\\ndef onLine (a : Point) (L : Line) -- point a is on line L.\\ndef sameSide (a b : Point) (L : Line) -- point a and b are on the same side of line L.\\ndef opposingSides (a b : Point) (L : Line) -- point a and b are on the opposite sides of line L.\\ndef collinear : (a b c : Point) -- points a, b and c are collinear.\\nend Point\\n\\nnamespace Line\\n\\ndef intersectsLine (L M : Line) -- two lines L and M intersect at some point.\\ndef intersectsCircle (L : Line) (C : Circle) -- line L and circle C intersect.\\nend Line\\n\\nnamespace Circle\\n\\ndef onCircle (a: Point) (C: Circle) -- point a is on circle C.\\ndef insideCircle (a: Point) (C: Circle) -- point a is inside circle C.\\ndef outsideCircle (a: Point) (C: Circle) -- point a is outside circle C.\\ndef isCentre (a: Point) (C: Circle) -- point a is on the center circle C.\\ndef intersectsCircle (C1 C2: Circle) -- circle C1 and C2 intersect.\\nend Circle\\n\\nnamespace Triangle\\n-- triangle T1 and T2 are congruent (i.e satisfies the SAS, AAS, ASA or SSS condition)\\ndef congruent (T1 T2 : Triangle)\\ndef similar (T1 T2 : Triangle)\\ndef congruent_if (T1 T2: Triangle): congruent T1 T2\\n\u2192 match T1,T2 with\\n| (Triangle.ofPoints A B C) ,(Triangle.ofPoints D E F) =>\\n| (A--B)| = |(D--E)|\\n\u2227 (B--C)| = |(E--F)|\\n\u2227 (A--C)| = |(D--F)|\\n\u2227 \u2220A:B:C = \u2220D:E:F\\n\u2227 \u2220A:C:B = \u2220D:F:E\\n\u2227 \u2220B:A:C = \u2220E:D:F\\n-- If T1 and T2 are similar, then the corresponding angles and sides are equal.\\ndef similar_if (T1 T2: Triangle): similar T1 T2\\n\u2192 match T1,T2 with\\n| (Triangle.ofPoints A B C) ,(Triangle.ofPoints D E F) =>\\n| (A--B)| / |(D--E)| = |(B--C)| / |(E--F)|\\n\u2227 (A--B)| / |(D--E)| = |(B--C)| / |(E--F)|\\n\u2227 (C--A)| / |(F--D)| = |(A--B)| / |(D--E)|\\n\u2227 \u2220A:B:C = \u2220D:E:F\\n\u2227 \u2220A:C:B = \u2220D:F:E\\n\u2227 \u2220B:A:C = \u2220E:D:F\\n-- Geometric Relations\\n-- points a and b are distinct and on line L.\\ndef distinctPointsOnLine (a b : Point) (L : Line)\\ndef twoLinesIntersectAtPoint (AB BC : Line) (b : Point)\\ndef points a, b and c collinear and cyclically ordered.\\ndef between (a b c : Point)\\ndef point a, b and c form a triangle, where point a and b are on line AB, point b and c are on line BC, point a and c are on line CA.\\ndef formTriangle (a b c : Point) (AB BC CA : Line)\\ndef point a, b and c form a rectilinear angle where a \u2260 b and b \u2260 c.\\ndef formRectilinearAngle (a b c : Point) (AB BC : Line)\\ndef point a, b, d, c (in clockwise/counterclockwise order) form a parallelogram, a and b are on line AB, c and d are on line CD, a and c are on line AC, b and d are on line BD.\\ndef formParallelogram (a b c d : Point) (AB CD AC BD : Line)\\ndef point a, b, d, c (in clockwise/counterclockwise order) form a quadrilateral, a and b are on line AB, c and d are on line CD, a and c are on line AC, b and d are on line BD.\"}"}
{"id": "bylZbZOsGA", "page_num": 1, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nLogan Murphy\\nKaiyu Yang\\nJialiang Sun\\nZhaoyu Li\\nAnima Anandkumar\\nXujie Si\\n\\nAbstract\\n\\nAutoformalization involves automatically translating informal math into formal theorems and proofs that are machine-verifiable. Euclidean geometry provides an interesting and controllable domain for studying autoformalization. In this paper, we introduce a neuro-symbolic framework for autoformalizing Euclidean geometry, which combines domain knowledge, SMT solvers, and large language models (LLMs). One challenge in Euclidean geometry is that informal proofs rely on diagrams, leaving gaps in texts that are hard to formalize. To address this issue, we use theorem provers to fill in such diagrammatic information automatically, so that the LLM only needs to autoformalize the explicit textual steps, making it easier for the model. We also provide automatic semantic evaluation for autoformalized theorem statements. We construct LeanEuclid, an autoformalization benchmark consisting of problems from Euclid's *Elements* and the UniGeo dataset formalized in the Lean proof assistant. Experiments with GPT-4 and GPT-4V show the capability and limitations of state-of-the-art LLMs on autoformalizing geometry problems. The data and code are available at https://github.com/loganrjmurphy/LeanEuclid.\\n\\n1. Introduction\\n\\nEuclidean geometry is one of the oldest branches of mathematics. It has served as a test of human intelligence for more than two millennia and has recently been used to test AI. Substantial work has focused on solving geometry problems automatically (Wu, 2008), e.g., AlphaGeometry (Trinh et al., 2023) can solve some of the IMO geometry problems. These methods consume problems and produce solutions in structured formats. In this work, we address a complementary task, autoformalization: Can AI understand human-written problems/solutions and translate them automatically into formal theorems/proofs? Specifically, we focus on the setting where formal theorems/proofs can be verified by the Lean proof assistant (de Moura & Ullrich, 2021). Lean provides a language for writing formal proofs. It is popular among mathematicians and has a growing ecosystem of integration with large language models (LLMs), e.g., LeanDojo (Yang et al., 2023) and Lean Copilot (Song et al., 2024).\\n\\nWe demonstrate that Euclidean geometry provides an interesting and controllable domain for autoformalization. First, an automatic evaluation of autoformalized theorems is difficult in general but feasible in Euclidean geometry. Second, the logical gaps in informal proofs are well understood in Euclidean geometry, making it easier to faithfully formalize the proofs. Third, combining text-based and diagrammatic reasoning makes Euclidean geometry a natural domain to study multimodal reasoning models. Therefore, autoformalizing Euclidean geometry is an attractive target for AI.\\n\\nEvaluating Autoformalized Theorem Statements.\\n\\nDespite the promise of machine learning and LLMs in autoformalizing theorems (Wu et al., 2022), a major roadblock is the lack of reliable and automatic evaluation. Comparing the model output verbatim with ground truth would be too rigid since there are many valid ways to formalize a theorem. Checking the logical equivalence between two theorems is generally intractable. Researchers have resorted to proxy metrics such as the BLEU score (Papineni et al., 2002). However, LLMs can score high on such metrics without generating correct formalization (Jiang et al., 2023b). Alternatively, human evaluation is widely used as a last resort, but it is costly, especially if we want to use the results to improve the method iteratively.\\n\\nOur Approach to Evaluating Autoformalization.\\n\\nTo overcome the evaluation bottleneck, we introduce a new automatic approach for evaluating the semantics of autoformalized theorems. The key insight is that equivalence checking can be made feasible in specific domains (such as Euclidean geometry) by combining domain knowledge with automated reasoning tools, such as satisfiability modulo theories (SMT) solvers (Barrett & Tinelli, 2018).\\n\\nTo evaluate the autoformalized theorems, we develop a symbolic algorithm that computes the logical equivalence between two theorems. This algorithm is based on the Lean proof assistant and the SMT solver Z3 (De Moura & Clarke, 2008). We evaluate the algorithm on a dataset of formalized Euclidean geometry problems and find that it is able to correctly identify the logical equivalence between theorems in most cases. This approach provides a scalable and reliable method for evaluating autoformalized theorems, which we believe is a significant step towards building a fully automated system for autoformalization.\"}"}
{"id": "bylZbZOsGA", "page_num": 2, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nInformal Euclidean geometry problem: Equivalent?\\n\\nAutoformalized proof\\n\\nAutoformalized theorem\\n\\nGround truth theorem\\n\\n\\\\[ a \\\\parallel b : \\\\text{Point} \\\\]\\n\\n\\\\[ AB : \\\\text{Line} \\\\]\\n\\n\\\\[ \\\\text{BCD} \\\\cap \\\\text{ACE} : \\\\text{Circle} \\\\]\\n\\n\\\\[ \\\\text{isCenter}(a, \\\\text{BCD}) \\\\]\\n\\n\\\\[ \\\\text{isCenter}(b, \\\\text{ACE}) \\\\]\\n\\n\\\\[ \\\\text{onCircle}(a, \\\\text{BCD}) \\\\]\\n\\n\\\\[ \\\\text{onCircle}(b, \\\\text{ACE}) \\\\]\\n\\n\\\\[ \\\\vdash \\\\text{intersects}(\\\\text{BCD}, \\\\text{ACE}) \\\\]\\n\\nDiagrammatic reasoning gaps:\\n\\n\\\\[ \\\\vdash \\\\ldots \\\\]\\n\\nSMT-based symbolic reasoning engine:\\n\\n\\\\[ \\\\ldots \\\\]\\n\\nFigure 1. Left: Proposition 1 in Euclid's Elements (Book I). The or ange text involves diagrammatic reasoning: Euclid did not explicitly prove the two circles actually intersect, but the reader can use the diagram to implicitly fill in the logical gap.\\n\\nTop right: The model autoformalizes the problem into a formal theorem (proposition 1'), which is evaluated by checking its logical equivalence with the ground truth (proposition 1), leveraging domain knowledge and a symbolic automated reasoning engine based on SMT (satisfiability modulo theories) solvers.\\n\\nBottom right: A proof autoformalized by the model. Like Euclid's proofs, it does not need to handle diagrammatic reasoning explicitly. Lean can check the proof to identify a list of diagrammatic reasoning gaps, e.g., \\\"\\\\text{intersects}(\\\\text{BCD}, \\\\text{ACE})\\\". Then, it attempts to fill in all gaps automatically using the symbolic reasoning engine based on SMT solvers.\\n\\nAs Fig. 1 (Top right) shows, given a ground-truth formal theorem \\\\( T_{gt} \\\\) and the autoformalized theorem \\\\( T_{pred} \\\\) produced by a language model, we use the symbolic engine to try to prove their equivalence (\\\\( T_{gt} \\\\iff T_{pred} \\\\)). If successful, their logical gap is small enough to conclude that \\\\( T_{pred} \\\\) is correct.\\n\\nEven if the symbolic engine cannot prove \\\\( T_{gt} \\\\iff T_{pred} \\\\), it can provide partial results useful for a more fine-grained analysis. We validate this evaluation protocol by showing it correlates well with human evaluation.\\n\\nLeanEuclid: Formalizing Proofs and Diagrams.\\n\\nWe construct LeanEuclid, a benchmark for testing machine learning on autoformalizing Euclidean geometry. As in Fig 1 (Left), each example in LeanEuclid has an informal theorem, proof, and diagram in \\\\LaTeX, as well as a formal theorem and proof in Lean. Data examples in LeanEuclid are manually formalized into Lean from Euclid's Elements (Heiberg, 2007) and the UniGeo dataset (Chen et al., 2022).\\n\\nLeanEuclid serves as a benchmark for autoformalizing not only theorems but also proofs. Geometric proofs are challenging to formalize faithfully. Humans (ancient or modern, including Euclid himself) use diagrams to license proof steps without making every detail explicit. Fig. 1 shows an example of diagrammatic reasoning from Euclid's Elements.\\n\\nEuclid uses the intersection of two circles (\\\\( C \\\\)) without prov-ing its existence. Most readers would not find the proof problematic, as the two circles intersect in the diagram. Such implicit diagrammatic reasoning is ubiquitous in informal geometric proofs but needs to be handled explicitly in formal proofs (Beeson et al., 2019). Therefore, a naive attempt to autoformalize the proofs would be difficult, as it requires the model to fill in many diagrammatic reasoning gaps, with nothing to reference in the informal texts.\\n\\nTo mitigate diagrammatic gaps, LeanEuclid adopts a formal system named E (Avigad et al., 2009), introduced by philosophers for modeling diagrammatic reasoning in Euclid's Elements. It teases out a set of diagrammatic rules so that diagrammatic reasoning can be modeled as logical deductions. We implement E in Lean and provide proof automation to fill in diagrammatic reasoning gaps, using the same symbolic reasoning engine developed for equivalence checking. Our system enables formalizing all 48 theorems and proofs from Elements (Book I), following Euclid's original proofs as closely as possible, with diagrammatic reasoning carried out implicitly and automatically (see Fig. 1). The data is included in LeanEuclid, making autoformalizing Euclid's proofs feasible. The language model now only needs to autoformalize the explicit textual proof steps, leaving the \\\"obvious\\\" implicit reasoning to the symbolic engine.\"}"}
{"id": "bylZbZOsGA", "page_num": 3, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nUsing LeanEuclid, we experimentally investigate the capability of GPT-4 (OpenAI, 2023) and GPT-4V (with vision) on autoformalizing theorems and proofs in Euclidean geometry. With 5-shot prompting, GPT-4 can autoformalize only 18.9% of the theorems correctly, demonstrating the difficulty of LeanEuclid. GPT-4V performs slightly better (21.0%), showing the potential benefit of multimodal models. Furthermore, GPT-4V can autoformalize 23.1% of LeanEuclid proofs correctly, generating the entire proof without searching the space of individual steps. Finally, our study shows that imperfect autoformalized proofs can often be manually repaired into correct proofs through a few simple modifications.\\n\\nContributions.\\nWe make three main contributions: First, we introduce an SMT-based symbolic engine for automatically evaluating the semantics of theorem statements in Euclidean geometry. Second, we demonstrate the feasibility of autoformalizing only explicit geometric proof steps, relying on the symbolic engine for implicit diagrammatic reasoning. Third, our experiments reveal the capability and limitations of state-of-the-art LLMs on autoformalizing Euclidean geometry. Overall, our approach demonstrates Euclidean geometry as a promising target for autoformalization. It may facilitate autoformalization research to move from human inspection to automatic evaluation. Such a transition is essential for accelerating the development of machine learning methods on this task and ultimately easing the human effort required by formalization.\\n\\n2. Related Work\\n\\nNeural Theorem Proving and Autoformalization.\\nMachine learning and LLMs can prove theorems using proof assistants (Polu & Sutskever, 2020; Yang & Deng, 2019; Yang et al., 2023; First et al., 2023; Lample et al., 2022; Han et al., 2022). In theorem proving, everything is formal: The model generates a formal proof given a formal theorem. In contrast, we focus on autoformalization, which aims to translate informal math into formal theorems and proofs. Li et al. (2024) provides a comprehensive survey on deep learning for theorem proving and autoformalization.\\n\\nMachine learning for autoformalization is strained by the lack of informal-formal pairs for training. Manually annotating such a dataset would be prohibitively expensive. Researchers have explored two approaches to overcome data scarcity. First, we can generate synthetic training data either procedurally (Wang et al., 2018; Cunningham et al., 2023) or using LLMs (Chen et al., 2023; Jiang et al., 2023b). Second, we can leverage the few-shot capability of LLMs such as GPT-4 (OpenAI, 2023). We only need to annotate a few examples for in-context demonstration and a relatively small testing set (Wu et al., 2022; Agrawal et al., 2022; Jiang et al., 2023a; Azerbayev et al., 2023). LeanEuclid follows the latter approach and is intended as a benchmark for testing only.\\n\\nAutoformalized theorems are difficult to evaluate, so all existing works have resorted to human evaluation. In addition, they have used proxy metrics such as compilation rates (Jiang et al., 2023b; Azerbayev et al., 2023) and the BLEU score (Wu et al., 2022; Azerbayev et al., 2023), none of which is sufficiently accurate. In contrast, we are the first to evaluate the semantics of autoformalized statements reliably and automatically.\\n\\nFormalizing Euclidean Geometry.\\nTo our knowledge, no machine learning method has attempted to autoformalize Euclidean geometry. Tarski's (Schwabh\u00e4user et al., 2013) and Hilbert's axioms (Hilbert, 2013) are two classical axiomatic systems that put Euclidean geometry on a rigorous foundation. Beeson et al. (2019) uses a variant of Tarski's system to manually formalize Euclid's Elements (Book I) in the Coq proof assistant (Barras et al., 1997). Hernandez-Espiet (2023) is an ongoing work formalizing the book in Lean. However, they require formal proofs to explicitly handle all gaps left by diagrammatic reasoning. As a result, formal proofs in their systems are much more verbose than Euclid's proofs (examples in Appendix C), making their systems unsuitable for studying autoformalization.\\n\\nProofs in Euclidean geometry have gaps due to diagrammatic reasoning. However, for more than two millennia, they have seldom troubled Elements' readers around the world. Philosophers have posited many theories aiming at a systematic understanding of diagrammatic reasoning (Miller, 2001; Mumma, 2010). In particular, we build upon the formal system E (Avigad et al., 2009) and are the first to turn this framework into a practical system that includes an automated procedure for diagrammatic reasoning.\\n\\nGeometric Problem Solving.\\nAutomatic geometry problem solvers have been studied extensively (Nevins, 1975; Zhang et al., 1995). Wu's method (Wu, 2008) and Gr\u00f6bner bases method (Buchberger, 2005) transform geometric problems into algebraic equations. AlphaGeometry (Trinh et al., 2023) is a concurrent work that successfully solves many IMO geometry problems. Similar to us, it is a hybrid system using neural networks for difficult proof steps (e.g., constructing new geometric objects) and a symbolic engine for deducing simple facts. However, our method focuses on autoformalizing human-written theorems/proofs instead of finding new proofs. AlphaGeometry consumes problems and produces solutions in structured representations, without handling informal mathematical language. Furthermore, they represent theorems and proofs in a domain-specific language tailored for Euclidean geometry, whereas we use Lean: a general-purpose proof assistant. Lean provides a\"}"}
{"id": "bylZbZOsGA", "page_num": 4, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nhighly trusted foundation for the soundness of our system, and it opens up opportunities to interoperate with other branches of mathematics formalized in Lean's mathematical library (The mathlib Community, 2020).\\n\\nEuclidean geometry has also served as benchmarks in machine learning and NLP for multimodal understanding of geometric problems and diagrams (Lu et al., 2021; Chen et al., 2021a; Gao et al., 2023; Peng et al., 2023; Kazemi et al., 2023; Liang et al., 2023). These methods produce informal solutions given informal problem statements, whereas we formalize both problems and solutions. UniGeo (Chen et al., 2022) is a dataset consisting of 9,543 informal theorems and proofs. We formalize 125 random examples from UniGeo and include them in LeanEuclid, which shows the generality of our formalization beyond Euclid's Elements.\\n\\n3. Formalizing Euclidean Geometry in Lean\\n\\nTo construct the LeanEuclid benchmark, we implement a variant of system E (Avigad et al., 2009) in Lean and use it to formalize Euclidean geometry problems. LeanEuclid has two key features: First, it supports implicit diagrammatic reasoning, which is critical to faithfully formalizing geometric proofs. Second, it can check the logical equivalence between theorems, which is essential for automatically evaluating the autoformalized theorems.\\n\\n3.1. The Lean Proof Assistant\\n\\nProof assistants, a.k.a. interactive theorem provers, are languages and IDEs for humans to write formal proofs that can be checked by computers (Leroy et al., 2016; Hales et al., 2017). Widely used proof assistants include Coq, Isabelle, and Lean. They are similar from a machine learning perspective. Fig. 1 shows examples of theorems and proofs in Lean. Each theorem has a name and a theorem statement. A proof consists of multiple steps, and each step is called a \\\"tactic\\\". For example, \\\"use c\\\" and \\\"euclid apply circle from points b a as ACE\\\" are tactics. Given a theorem and its proof, Lean can check the proof and output an error message if it is incorrect. Lean can also check if the theorem is well-formed. The percentage of well-formed theorems autoformalized by the model is widely used as a proxy metric in prior works (Jiang et al., 2023b; Azerbayev et al., 2023). However, well-formedness does not guarantee correctness, since a predicted theorem statement can be well-formed but have a different meaning from the ground truth.\\n\\n1 Our symbolic reasoning engine (Sec. 3.3) relies on SMT solvers, whose results currently cannot be fully certified by Lean.\\n\\n3.2. The Formal System E\\n\\nE is a formal system for modeling theorems and proofs in Euclidean geometry inspired by Euclid's Elements. It defines basic geometric objects (e.g., points and lines) and relations between them (e.g., a point being on a line). It also prescribes how to formally state and prove theorems. E is a conceptual framework that can be implemented within any proof assistant. We explain our Lean implementation using proposition 1 in Fig. 1 as a running example. For a complete specification of E, please refer to Appendix A and E's paper (Avigad et al., 2009).\\n\\nGeometric Objects, Relations, and Theorems. E has six types of objects: points, lines, segments, circles, angles, and triangles. They can form various relations, e.g., \\\"onLine a AB\\\" means the point a is on the line AB. Some relations are defined as syntactic sugar of more basic relations, e.g., \\\"distinctPointsOnLine a b AB\\\" is the conjunction of \\\"onLine a AB\\\", \\\"onLine b AB\\\", and \\\"a \u2260 b\\\". A segment (a--b) is specified by its two endpoints a and b, and it has a length |(a--b)| \u2208 R. Using these concepts, it is straightforward to understand the theorem statement of proposition 1:\\n\\n\\\\[\\n\\\\text{theorem proposition_1 : } \\\\forall (a \\\\ b : \\\\text{Point}) (AB : \\\\text{Line}), \\\\text{distinctPointsOnLine a b AB} \\\\rightarrow \\\\exists \\\\ c : \\\\text{Point}, |(c--a)| = |(a--b)| \\\\wedge |(c--b)| = |(a--b)|\\n\\\\]\\n\\nLike above, most theorems in Euclidean geometry take the form of given existing objects satisfying certain properties, constructing new objects satisfying certain properties. Below is the general form of theorems in E:\\n\\n\\\\[\\n\\\\forall (\\\\rightarrow P : \\\\text{Point}) (\\\\rightarrow L : \\\\text{Line}) (\\\\rightarrow C : \\\\text{Circle}), \\\\sum_{i=1}^{m} a_i \\\\rightarrow \\\\exists (\\\\rightarrow P' : \\\\text{Point}) (\\\\rightarrow L' : \\\\text{Line}) (\\\\rightarrow C' : \\\\text{Circle}), \\\\sum_{j=1}^{n} a'_j\\n\\\\]\\n\\nThat is, given points \\\\(\\\\rightarrow P\\\\), lines \\\\(\\\\rightarrow L\\\\), and circles \\\\(\\\\rightarrow C\\\\) satisfying \\\\(\\\\sum_{i=1}^{m} a_i\\\\), one can construct points \\\\(\\\\rightarrow P'\\\\), lines \\\\(\\\\rightarrow L'\\\\), and circles \\\\(\\\\rightarrow C'\\\\) satisfying \\\\(\\\\sum_{j=1}^{n} a'_j\\\\). Each clause \\\\(a_i\\\\) is called a \\\"precondition\\\". Logically, it is a disjunction of literals with variables from \\\\(\\\\rightarrow P\\\\), \\\\(\\\\rightarrow L\\\\), and \\\\(\\\\rightarrow C\\\\). Each \\\\(a'_j\\\\) is called a \\\"postcondition\\\", which is a disjunction of literals with variables from \\\\(\\\\rightarrow P\\\\), \\\\(\\\\rightarrow L\\\\), \\\\(\\\\rightarrow C\\\\), \\\\(\\\\rightarrow P'\\\\), \\\\(\\\\rightarrow L'\\\\), and \\\\(\\\\rightarrow C'\\\\). Variable sets can be empty. For example, in proposition 1, we have \\\\(\\\\rightarrow C = \\\\rightarrow L' = \\\\rightarrow C' = \\\\emptyset\\\\).\"}"}
{"id": "bylZbZOsGA", "page_num": 5, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nConstruction rules construct new objects, i.e., at least one of $P'$, $L'$, and $C'$ must be non-empty. For example, circle from points constructs a circle $\\\\alpha$ given a point $a$ as its center and another point $b$ on it:\\n\\n$$\\\\text{axiom circle_from_points} : \\\\forall (a b : \\\\text{Point}), \\\\neg a = b \\\\rightarrow \\\\exists \\\\alpha : \\\\text{Circle}, (\\\\text{isCenter} a \\\\alpha) \\\\land (\\\\text{onCircle} b \\\\alpha)$$\\n\\nGiven two intersecting circles $\\\\alpha$ and $\\\\beta$, intersection circles constructs their intersection:\\n\\n$$\\\\text{axiom intersection_circles} : \\\\forall (\\\\alpha \\\\beta : \\\\text{Circle}), \\\\text{intersectsCircle} \\\\alpha \\\\beta \\\\rightarrow \\\\exists c : \\\\text{Point}, (\\\\text{onCircle} c \\\\alpha) \\\\land (\\\\text{onCircle} c \\\\beta)$$\\n\\nNon-construction rules deduce properties of existing objects without creating new objects. For examples:\\n\\n$$\\\\text{axiom center_inside_circle} : \\\\forall (a : \\\\text{Point}) (\\\\alpha : \\\\text{Circle}), \\\\text{isCenter} a \\\\alpha \\\\rightarrow \\\\text{insideCircle} a \\\\alpha$$\\n\\n$$\\\\text{axiom intersection_circle_circle_2} : \\\\forall (a b : \\\\text{Point}) (\\\\alpha \\\\beta : \\\\text{Circle}), (\\\\text{onCircle} a \\\\alpha) \\\\land (\\\\text{insideCircle} b \\\\alpha) \\\\land (\\\\text{insideCircle} a \\\\beta) \\\\land (\\\\text{onCircle} b \\\\beta) \\\\rightarrow \\\\text{intersectsCircle} \\\\alpha \\\\beta$$\\n\\nThe distinction between construction and non-construction rules is important for automated reasoning in Sec. 3.3.\\n\\nProofs. We implement the formal system E in Lean. Therefore, a proof can be made of arbitrary tactics as long as the entire proof can be checked by Lean. Nevertheless, we provide several customized tactics that can cover most steps used by Euclid (complete list in Appendix A). The most important tactic we provide is \\\\texttt{euclid apply}, which applies a rule (either an axiom or an existing theorem) in the forward direction. Taking intersection circles as an example, when using this rule, one should explicitly specify two circles, say, $BCD$ and $ACE$:\\n\\n$$\\\\text{intersection_circles} BCD ACE : \\\\text{intersectsCircle} BCD ACE \\\\rightarrow \\\\exists c : \\\\text{Point}, (\\\\text{onCircle} c BCD) \\\\land (\\\\text{onCircle} c ACE)$$\\n\\n\\\\texttt{euclid apply intersection circles BCD ACE as c} instructs Lean to check if the precondition \\\\texttt{intersectsCircle BCD ACE} is a known fact. If so, it introduces a new point $c$ and two new facts, \\\\texttt{onCircle c BCD} and \\\\texttt{onCircle c ACE}. If not, it triggers diagrammatic reasoning, trying to prove \\\\texttt{intersectsCircle BCD ACE} using a symbolic automated reasoning engine (Sec. 3.3). If successful, it proceeds as normal. Otherwise, the tactic fails. Fig. 2 shows three proof steps using \\\\texttt{euclid apply} with different rules. The last step triggers diagrammatic reasoning.\\n\\n3.3. Symbolic Reasoning Engine Based on SMT\\n\\nWe introduce a symbolic reasoning engine for deducing \\\"obvious\\\" facts from existing geometric objects and relations. It has two important uses in LeanEuclid: (1) diagrammatic reasoning, as shown in the previous example, and (2) checking the equivalence between theorems.\\n\\nIn Euclidean geometry, a natural way to measure obviousness is whether construction rules are used. Applying construction rules (e.g., drawing auxiliary lines) requires creativity, which is non-obvious and hard to automate. In contrast, non-construction rules are mechanic and more amenable to automated reasoning. Intuitively, they do not introduce new objects and will not explode the search space. Therefore, we design the symbolic engine to be an automated theorem prover equipped with non-construction rules in E.\\n\\nInstead of generic first-order provers (Schulz, 2013), our symbolic engine builds on top of SMT solvers. They have...\"}"}
{"id": "bylZbZOsGA", "page_num": 6, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nefficient decision procedures for handling real numbers, which is important for reasoning about geometric quantities such as lengths, angles, and areas. Given a target conclusion (e.g., \\\"intersects Circle BCD ACE\\\" in Fig. 2), our symbolic engine proves it by refutation: It generates a list of SMT formulas, including all non-construction rules in E, all existing objects/relations, and the negation of the conclusion. Then, it runs off-the-shelf SMT solvers to check if the list of formulas is satisfiable. The target conclusion is successfully proved if the solver returns UNSAT (not satisfiable).\\n\\n3.4. LeanEuclid: Overview and Dataset Statistics\\n\\nIn constructing LeanEuclid, we manually formalized 173 theorems/proofs in Lean. 48 examples are from Euclid's Elements (Book I), and 125 are adapted from UniGeo (Chen et al., 2022). Our formal proofs of Elements vindicate Euclid's use of diagrams, as they follow Euclid's texts closely and leave diagrammatic reasoning implicit. We identified several small gaps in Elements. Euclid occasionally used a stronger version of a theorem he had proved. Furthermore, when there were multiple cases, Euclid would discuss only one and omit others. Most omissions are acceptable in modern mathematics, e.g., when multiple cases are symmetric. The only omission we find questionable is in the proof of Proposition 24, where Euclid discussed only a simple case but omitted a more challenging case (details in Appendix B). UniGeo contains problems in five categories: triangle, congruent, similarity, quadrilateral, and parallel. LeanEuclid includes 25 random problems from each category. Problems from UniGeo are generally easier than those from Elements. Each problem comes with a diagram and a textual question. Unlike Elements, UniGeo's text does not include complete information about the problem, so we manually add missing diagrammatic details to the text.\\n\\n4. Autoformalizing Euclidean Geometry with Large Language Models\\n\\nNext, we describe our approach to autoformalizing (and evaluating) theorems and proofs targeting LeanEuclid.\\n\\n4.1. Autoformalizing and Evaluating Theorems\\n\\nAutoformalizing a theorem statement requires taking natural language input and generating the corresponding formal theorem in Lean. We use LLMs' in-context learning capability for autoformalization. Our prompt template contains an overview of LeanEuclid syntax, some examples of well-formed formulas, and various guidelines for the task. For few-shot learning, we also include k examples of informal-formal pairs as in-context demonstrations. The complete prompt template is in Appendix D.\\n\\nWhen using our symbolic engine for checking the equivalence between theorems, we call it $E_3$ (Euclidean Engine). We also provide a Python wrapper for $E_3$, supporting various configuration options and easy integration with different LLMs. We provide a high-level overview of $E_3$'s two primary evaluation procedures: logical equivalence and approximate equivalence.\\n\\nLogical Equivalence. The logical equivalence procedure takes a predicted formula $T_{\\\\text{pred}}$ and ground truth formula $T_{\\\\text{gt}}$ and attempts to prove $T_{\\\\text{pred}} \\\\iff T_{\\\\text{gt}}$ using SMT solvers. $E_3$ performs a separate satisfiability check for each direction, each of which can succeed or fail. Of course, $T_{\\\\text{pred}}$ may actually be unsatisfiable (meaning it contains a contradiction), in which case we will always be able to prove $T_{\\\\text{pred}} \\\\Rightarrow T_{\\\\text{gt}}$. As such, $E_3$ also performs a separate check to see whether a contradiction can be found in $T_{\\\\text{pred}}$.\\n\\nApproximate Equivalence. If logical equivalence cannot be proven, we may still want to gauge whether $T_{\\\\text{pred}}$ is a semantically \\\"close\\\" formalization of $T_{\\\\text{gt}}$. For instance, $T_{\\\\text{pred}}$ may differ from $T_{\\\\text{gt}}$ by only a single extra precondition or postcondition. To this end, $E_3$ also supports approximate equivalence checking, which is a low-level semantic comparison between the two formulas. Specifically, $E_3$ will attempt to separately prove each of the preconditions and the postconditions of each formula in a clause-by-clause fashion. However, this requires choosing a unification of the bound variables of the two formulas. Since trying each possible unification is infeasible, we instead choose the best n unifications using a string similarity heuristic. For each candidate unification, we check how many pre/postconditions can be proved from one proposition to the other.\\n\\n4.2. Autoformalizing Proofs\\n\\nTo autoformalize proofs, we provide the LLM with a natural language description of the proposition, its natural language proof, and a formalization of the proposition in LeanEuclid. Its task is to produce a formal proof consisting of a sequence of tactics. We provide a prompt template similar to the one used to autoformalize theorem statements. In addition to a brief overview of system $E$, we describe the custom LeanEuclid tactics (e.g., euclid apply), and provide a list of axioms and theorems the model can use in its proof. Beyond the core axioms of $E$, the list of helper theorems available to the model depends on the proposition being proven. For $E$, $E_3$ uses not only non-construction rules but also a handful of construction rules (details in Appendix A). $E_3$ currently only performs approximate equivalence checking when the predicted formula has the same number of bound variables as the ground truth formula.\"}"}
{"id": "bylZbZOsGA", "page_num": 7, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nexample, if we are formalizing the proof of Proposition 10 in *Elements*, then the set of available helper theorems will include all versions of Propositions 1\u20139. Once the autoformalized proof is generated, we check its correctness using Lean and attempt to fill in diagrammatic reasoning gaps using the symbolic reasoning engine. The complete prompt template is given in Appendix D.\\n\\n5. Experiments\\n\\n5.1. Autoformalizing Theorem Statements\\n\\nExperimental Setup. We evaluated the efficacy of LLMs on autoformalizing theorem statements using GPT-4 and GPT-4V. The input modality for GPT-4 was restricted to textual questions, while GPT-4V extended this by including diagrams as well. To implement few-shot learning, we randomly selected five propositions from Euclid's *Elements* and five problems from each category in the UniGeo dataset, serving as in-context learning examples. We then use E3 to automatically evaluate the results of each round. To see how well E3 correlates with human evaluation, we manually evaluate a sample of formalized theorems from *Elements* to identify any false negatives/positives.\\n\\n|                | 0-shot | 1-shot | 5-shot |\\n|----------------|--------|--------|--------|\\n| *Elements*     | 2.3%   | 4.7%   | 16.3%  |\\n| *UniGeo*       | 3.0%   | 9.0%   | 20.0%  |\\n| **Overall**     | 2.8%   | 7.7%   | 18.9%  |\\n\\nTable 1. Percentage of proved semantic equivalences from autoformalized theorem statements from *Elements* and *UniGeo*. Experiments were conducted in January 2024 using gpt-4-1106-preview and gpt-4-1106-vision-preview.\\n\\nResults. Table 1 shows the accuracies of autoformalizing theorem statements, where correctness is measured by using E3 to check logical equivalence. Results on the *Elements* and *UniGeo* parts of LeanEuclid are also shown separately. Across both parts, few-shot learning with 5 shots produces correct formalizations at a rate of 21%. We also see a small improvement when visual inputs are included. We emphasize that Table 1 was generated automatically by E3. While some autoformalized theorem statements are syntactic matches of their ground truth and, therefore, easily identified as correct, others are not. Manual evaluation of these instances is expensive and tedious, whereas E3 is able to identify these cases easily.\\n\\nFor cases where equivalence fails, E3 reports whether either $\\\\text{T}_{\\\\text{gt}} \\\\Rightarrow \\\\text{T}_{\\\\text{pred}}$ or $\\\\text{T}_{\\\\text{pred}} \\\\Rightarrow \\\\text{T}_{\\\\text{gt}}$ can be proved, allowing us to partition the failed cases into different classes. For instance, two rounds of autoformalization with GPT-4 (1-shot) yielded 67 rejected predictions, for 31 of these we could prove only $\\\\text{T}_{\\\\text{gt}} \\\\Rightarrow \\\\text{T}_{\\\\text{pred}}$, for 15 we could prove only $\\\\text{T}_{\\\\text{pred}} \\\\Rightarrow \\\\text{T}_{\\\\text{gt}}$, and for 21 we could prove neither.\\n\\nGiven that only a minority of predictions are provably correct, we can send the remainder to E3\u2019s approximate equivalence checker to glean \u201cclose\u201d formalizations. For brevity, we only showcase this evaluation on the results of GPT-4 (5-shot) on Euclid\u2019s *Elements*. Of the 36 rejected predictions, 10 possess the correct quantity and type of bound variables, and so are amenable to approximate analysis. The results of this analysis are shown in Fig. 3. For each proposition, we show the total number of clauses (preconditions and postconditions of both formulas) and the number of clauses that could be proved. We can see that, in addition to the 7 propositions that were provably equivalent, this round produced 5 propositions for which more than 90% of all proof obligations can be resolved. Some interesting examples produced during our experiments are in Appendix E.\\n\\nComparison with Manual Evaluation. To compare the accuracy of E3 to manual evaluation, we took a sample of 86 formalizations and investigated them for false negatives. The examples were taken from the results of GPT-4 and GPT-4V (both 5-shot). Among the 86 autoformalized theorem statements, 16 were proved equivalent to the ground truth, and all 16 were judged to be correct by humans. The remaining 70 could not be proved equivalent, but human inspection revealed that 3 should be equivalent to the ground truth. This gives us an estimated false negative rate of 15.8%. These instances are shown in Appendix E.\\n\\nWith respect to false positives, we did not find indications of soundness bugs in E3. However, a false positive can occur when an autoformalized theorem happens to be provably equivalent to the ground truth, but is unlikely to be identified by a human as a \u201cfaithful\u201d formalization of the given proposition. We identified only one such case from our experiments, which is also shown in Appendix E.\"}"}
{"id": "bylZbZOsGA", "page_num": 8, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nWhy is Formalizing Theorem Statements Hard?\\n\\nCompared to previous autoformalization results (Wu et al., 2022), our experiments show that the models struggle to correctly formalize most of the theorems in our dataset. We suspect this is primarily a result of using the formal system E as a specification language. E is designed primarily as a proof system, and not as a specification language; as noted by Avigad, many basic relation constructs in E (e.g., between, sameSide) are almost never mentioned explicitly in Euclid's actual writing (Avigad et al., 2009). Furthermore, the language can only refer to composite structures (angles, triangles, etc.) in terms of their atomic components (points, lines, etc.). This makes theorem statements in E relatively verbose, and this verbosity introduces more room for the model to make small mistakes.\\n\\nIn summary, while state-of-the-art models struggle to successfully autoformalize many of the theorems in our dataset, we see that E\u2080\u00b3 can successfully identify and quantify the correctness of autoformalized theorem statements; in particular, despite being incomplete by design, E\u2080\u00b3 only produces a small number of false negatives. We believe that E\u2080\u00b3 can significantly facilitate the training and validation of autoformalization models targeting Euclidean geometry. Moreover, we believe that similar tools can be developed for other domains if an appropriate formal theory can be defined.\\n\\n5.2. Autoformalizing Proofs\\n\\nTo check whether LeanEuclid is a suitable target for autoformalizing proofs, we attempted to autoformalize proofs from Elements and UniGeo using GPT-4 and GPT-4V.\\n\\nExperimental Setup.\\n\\nWe tested each model against 43 proofs from Elements and 100 proofs from UniGeo. To demonstrate concretely the capabilities and limitations of the model in writing formal LeanEuclid proofs, we attempted to formalize entire proofs from single queries, rather than using an iterative or search-based autoformalization procedure. We evaluated the formalized UniGeo proofs based on whether it is verified by Lean as-is, and experimented with 0-shot, 1-shot, and 5-shot prompts. The proofs from Elements are more complex, so we did not anticipate many proofs to be completely correct. Instead, we measured how much effort is required to repair the autoformalized proofs into proofs that are accepted by Lean.\\n\\nWe manually repaired each incorrectly autoformalized proof from Elements, attempting to make as few alterations as required. Using our ground truth proof as a reference point, we modified invalid tactics that could be repaired (e.g., by rearranging the order of its arguments), added missing tactics, and removed tactics that could not easily be repaired. Unnecessary but valid tactics were left unchanged.\\n\\n| Category   | 1-shot | 5-shot |\\n|------------|--------|--------|\\n| Triangle   | 35%    | 45%    |\\n| Similarity | 5%     | 15%    |\\n| Congruent  | 5%     | 25%    |\\n| Quadrilateral | 35%    | 25%    |\\n| Parallel   | 5%     | 15%    |\\n| Overall    | 17%    | 25%    |\\n\\nTable 2. Percentage of successfully autoformalized proofs from UniGeo. Experiments were conducted in January 2024 using gpt-4-1106-preview and gpt-4-1106-vision-preview.\\n\\nResults.\\n\\nTable 2 shows the results of autoformalizing proofs from UniGeo proofs. Models with 0-shot prompts are not included since they failed to autoformalize any proofs. In general, the performance of the models significantly depends on the type of geometry problems and the number of few-shot demonstrations. Compared to theorem statements, we see a more significant improvement in the success rate when visual inputs are provided for autoformalizing proofs.\\n\\nWhen autoformalizing proofs from Elements with 5-shot prompts, we found that GPT-4 and GPT-4V were both only able to completely formalize the same two proofs (Propositions 1 and Proposition 17). That is to say, when combined with the UniGeo results, GPT-4 formalized correct proofs at a rate of 18.8% on LeanEuclid, while GPT-4V achieved a rate of 23.1%. The remaining 41 proofs from Elements required some degree of repair to be accepted by Lean. While it is difficult to precisely measure the quality of imperfect proofs, we can gain a rough approximation by computing the Levenshtein ratio between the original and repaired proofs. Doing so reveals that, for GPT-4, the autoformalized proofs had a median similarity ratio of 61.7% compared to their repaired versions, with proofs in the 75th percentile scoring at least 75.2%. For GPT-4V, the median similarity ratio was 64.0%, and the proofs in the 75th percentile proofs scored at least 72.9%. Moreover, we found that many of the modifications required to repair the proofs are very simple, such as strengthening a theorem slightly or rearranging tactics arguments; in general, the models are good at choosing relevant theorems, even if they do not invoke them correctly.\\n\\nAdditional data and examples are in Appendix F. We believe that these results reflect well on LeanEuclid as a target language for autoformalizing Euclidean proofs. In particular, our tactic language and proof automation allow the model to focus only on explicit reasoning steps in the input text. This means the resulting proofs are much shorter than they would be if all reasoning steps were made explicit (and, as a result, they are easier to repair). Given that these results were obtained from standalone queries, we expect...\"}"}
{"id": "bylZbZOsGA", "page_num": 9, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nthat neural theorem provers or proof repair tools targeting LeanEuclid could be used to successfully formalize a significant portion of the proofs in our dataset.\\n\\n6. Conclusion\\n\\nWe have demonstrated Euclidean geometry as an attractive target for autoformalization. With our SMT-based symbolic engine, it is feasible to (1) automatically evaluate autoformalized theorem statements and (2) have the model autoformalize only explicit proof steps, leaving diagrammatic reasoning implicit. We have constructed the LeanEuclid benchmark to facilitate future research on autoformalizing Euclidean geometry.\\n\\n7. Limitations and Open Problems\\n\\nLeanEuclid's size (173 examples) is reasonable as a benchmark for testing, e.g., considering HumanEval (Chen et al., 2021b), the most widely used benchmark for code generation, which has only 164 examples. Nevertheless, more data examples are necessary for finetuning-based approaches. A promising way of collecting examples inexpensively is to automatically translate existing geometry datasets, e.g., the synthetic dataset in AlphaGeometry, into our formalism. Even though we use GPT-4 in experiments, data contamination is unlikely since our test data, LeanEuclid, was not publicly available during the experiments. GPT-4 may have seen other formalizations of Elements on the Internet, but they are fundamentally different from LeanEuclid (Sec. 2). We focus on Euclidean geometry, but findings related to LeanEuclid may be helpful to autoformalization in general. First, LeanEuclid provides a benchmark for developing domain-agnostic ideas for autoformalization, e.g., visual modality, retrieval, and learning from feedback. Second, we choose Euclidean geometry because its domain knowledge enables automated reasoning that can (1) check the equivalence between theorems and (2) fill in implicit reasoning gaps. Other domains with similar characteristics may also benefit from our methodology for constructing LeanEuclid. Our work focuses on constructing a benchmark for autoformalization rather than introducing a novel model. Nevertheless, the LeanEuclid benchmark paves the way for future modeling efforts, such as having LLMs incorporate feedback from Lean to improve autoformalization.\\n\\nAcknowledgements\\n\\nThis work is partially supported by the Natural Sciences and Engineering Research Council of Canada (NSERC) through the Discovery Grants (individual) program. Kaiyu Yang is partially supported by Caltech's Computing, Data, and Society Postdoctoral Fellowship. Xujie Si is partially supported by the Canada CIFAR AI Chairs program. We thank Jia Deng for his contributions to the conceptualization of this project when Kaiyu Yang was a Ph.D. student under his mentorship. We are also thankful to Jeremy Avigad for his invaluable guidance on the formal system E. Special thanks go to Marsha Chechik and Kuldeep Meel for their insightful feedback on the initial version of this paper.\\n\\nImpact Statement\\n\\nThis work aims to advance autoformalization by studying it in the controlled domain of Euclidean geometry. Autoformalization can be applied to formal mathematics, verification, and autonomous systems (Chen et al., 2023; Cosler et al., 2023; Pan et al., 2023). There are many potential societal consequences of these downstream applications, none of which we feel must be specifically highlighted here.\\n\\nReferences\\n\\nAgrawal, A., Gadgil, S., Goyal, N., Narayanan, A., and Tadipatri, A. Towards a mathematics formalisation assistant using large language models. arXiv preprint arXiv:2211.07524, 2022.\\n\\nAvigad, J. Notes on \u201cA formal system for Euclid\u2019s Elements\u201d. https://www.andrew.cmu.edu/user/avigad/Papers/euclid_notes.htm.\\n\\nAvigad, J., Dean, E., and Mumma, J. A formal system for Euclid\u2019s Elements. The Review of Symbolic Logic, 2009.\\n\\nAzerbayev, Z., Piotrowski, B., Schoelkopf, H., Ayers, E. W., Radev, D., and Avigad, J. ProofNet: Autoformalizing and formally proving undergraduate-level mathematics. arXiv preprint arXiv:2302.12433, 2023.\\n\\nBarras, B., Boutin, S., Cornes, C., Courant, J., Filliatre, J.-C., Gimenez, E., Herbelin, H., Huet, G., Munoz, C., Murthy, C., et al. The Coq proof assistant reference manual: Version 6.1. PhD thesis, Inria, 1997.\\n\\nBarrett, C. and Tinelli, C. Satisfiability modulo theories. 2018.\\n\\nBeeson, M., Narboux, J., and Wiedijk, F. Proof-checking Euclid. Annals of Mathematics and Artificial Intelligence, 2019.\\n\\nBuchberger, B. Applications of gr\u00a8obner bases in non-linear computational geometry. In Trends in Computer Algebra, 2005.\"}"}
{"id": "bylZbZOsGA", "page_num": 10, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nFindings of the Association for Computational Linguistics: ACL, 2021a.\\n\\nChen, J., Li, T., Qin, J., Lu, P., Lin, L., Chen, C., and Liang, X. UniGeo: Unifying geometry logical reasoning via reformulating mathematical expression. In Conference on Empirical Methods in Natural Language Processing (EMNLP), 2022.\\n\\nChen, M., Tworek, J., Jun, H., Yuan, Q., Pinto, H. P. d. O., Kaplan, J., Edwards, H., Burda, Y., Joseph, N., Brockman, G., et al. Evaluating large language models trained on code. arXiv preprint arXiv:2107.03374, 2021b.\\n\\nChen, Y., Gandhi, R., Zhang, Y., and Fan, C. NL2TL: Transforming natural languages to temporal logics using large language models. In Conference on Empirical Methods in Natural Language Processing (EMNLP), 2023.\\n\\nCosler, M., Hahn, C., Mendoza, D., Schmitt, F., and Tripel, C. nl2spec: Interactively translating unstructured natural language to temporal logics with large language models. In International Conference on Computer Aided Verification (CAV), 2023.\\n\\nCunningham, G., Bunescu, R. C., and Juedes, D. Towards autoformalization of mathematics and code correctness: Experiments with elementary proofs. arXiv preprint arXiv:2301.02195, 2023.\\n\\nde Moura, L. d. and Ullrich, S. The Lean 4 theorem prover and programming language. In International Conference on Automated Deduction (CADE), 2021.\\n\\nFirst, E., Rabe, M., Ringer, T., and Brun, Y. Baldur: Whole-proof generation and repair with large language models. In Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE), 2023.\\n\\nGao, J., Pi, R., Zhang, J., Ye, J., Zhong, W., Wang, Y., Hong, L., Han, J., Xu, H., Li, Z., et al. G-LLaVA: Solving geometric problem with multi-modal large language model. arXiv preprint arXiv:2312.11370, 2023.\\n\\nHales, T., Adams, M., Bauer, G., Dang, T. D., Harrison, J., Le Truong, H., Kaliszyk, C., Magron, V., McLaughlin, S., Nguyen, T. T., et al. A formal proof of the Kepler conjecture. In Forum of Mathematics, Pi, volume 5, 2017.\\n\\nHan, J. M., Rute, J., Wu, Y., Ayers, E., and Polu, S. Proof artifact co-training for theorem proving with language models. In International Conference on Learning Representations (ICLR), 2022.\\n\\nHeiberg, J. L. Euclid\u2019s Elements. 2007. URL https://github.com/rfitzp/Elements.\\n\\nHernandez-Espinet, A. feat: synthetic geometry. https://github.com/leanprover-community/mathlib4/pull/7300, 2023.\\n\\nHilbert, D. Grundlagen der geometrie. Springer-Verlag, 2013.\\n\\nJiang, A., Welleck, S., Zhou, J. P., Li, W., Liu, J., Jamnik, M., Lacroix, T., Wu, Y., and Lample, G. Draft, Sketch, and Prove: Guiding formal theorem provers with informal proofs. In International Conference on Learning Representations (ICLR), 2023a.\\n\\nJiang, A. Q., Li, W., and Jamnik, M. Multilingual mathematical autoformalization. arXiv preprint arXiv:2311.03755, 2023b.\\n\\nKazemi, M., Alvari, H., Anand, A., Wu, J., Chen, X., and Soricut, R. GeomVerse: A systematic evaluation of large models for geometric reasoning. arXiv preprint arXiv:2312.12241, 2023.\\n\\nLample, G., Lacroix, T., Lachaux, M.-A., Rodriguez, A., Hayat, A., Lavril, T., Ebner, G., and Martinet, X. HyperTree proof search for neural theorem proving. In Neural Information Processing Systems (NeurIPS), 2022.\\n\\nLeroy, X., Blazy, S., Kastner, D., Schommer, B., Pister, M., and Ferdinand, C. CompCert\u2014a formally verified optimizing compiler. In Embedded Real Time Software and Systems, 2016.\\n\\nLi, Z., Sun, J., Murphy, L., Su, Q., Li, Z., Zhang, X., Yang, K., and Si, X. A survey on deep learning for theorem proving. arXiv preprint arXiv:2404.09939, 2024.\\n\\nLiang, Z., Yang, T., Zhang, J., and Zhang, X. UniMath: A foundational and multimodal mathematical reasoner. In Conference on Empirical Methods in Natural Language Processing (EMNLP), 2023.\\n\\nLu, P., Gong, R., Jiang, S., Qiu, L., Huang, S., Liang, X., and Zhu, S.-c. Inter-GPS: Interpretable geometry problem solving with formal language and symbolic reasoning. In Annual Meeting of the Association for Computational Linguistics (ACL), 2021.\\n\\nMiller, N. G. A diagrammatic formal system for Euclidean geometry. 2001.\\n\\nMumma, J. Proofs, pictures, and Euclid. Synthese, 2010.\\n\\nNevins, A. J. Plane geometry theorem proving using forward chaining. Artificial Intelligence, 1975.\\n\\nOpenAI. GPT-4 technical report. arXiv preprint arXiv:2303.08774, 2023.\"}"}
{"id": "bylZbZOsGA", "page_num": 11, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nPan, J., Chou, G., and Berenson, D. Data-efficient learning of natural language to linear temporal logic translators for robot task specification. In *International Conference on Robotics and Automation (ICRA)*, 2023.\\n\\nPapineni, K., Roukos, S., Ward, T., and Zhu, W.-J. BLEU: a method for automatic evaluation of machine translation. In *Annual Meeting of the Association for Computational Linguistics (ACL)*, 2002.\\n\\nPeng, S., Fu, D., Liang, Y., Gao, L., and Tang, Z. Geo-DRL: A self-learning framework for geometry problem solving using reinforcement learning in deductive reasoning. In *Findings of the Association for Computational Linguistics: ACL*, 2023.\\n\\nPolu, S. and Sutskever, I. Generative language model- ing for automated theorem proving. *arXiv preprint arXiv:2009.03393*, 2020.\\n\\nSchulz, S. System description: E 1.8. In *International Conference on Logic for Programming, Artificial Intelligence, and Reasoning*, 2013.\\n\\nSchwabh\u00e4user, W., Szmielew, W., and Tarski, A. *Metamathematische methoden in der geometrie*. Springer-Verlag, 2013.\\n\\nSong, P., Yang, K., and Anandkumar, A. Towards large language models as copilots for theorem proving in Lean. *arXiv preprint arXiv:Arxiv-2404.12534*, 2024.\\n\\nThe mathlib Community. The Lean mathematical library. In *Certified Programs and Proofs (CPP)*, 2020.\\n\\nTrinh, T., Wu, Y., Le, Q., He, H., and Luong, T. Solving olympiad geometry without human demonstrations. *Nature*, 2023.\\n\\nWang, Q., Kaliszyk, C., and Urban, J. First experiments with neural translation of informal to formal mathematics. In *Conferences on Intelligent Computer Mathematics (CICM)*, 2018.\\n\\nWu, W.-t. On the decision problem and the mechanization of theorem-proving in elementary geometry. In *Selected Works Of Wen-Tsun Wu*. 2008.\\n\\nWu, Y., Jiang, A., Li, W., Rabe, M., Staats, C., Jamnik, M., and Szegedy, C. Autoformalization with large language models. In *Neural Information Processing Systems (NeurIPS)*, 2022.\\n\\nYang, K. and Deng, J. Learning to prove theorems via interacting with proof assistants. In *International Conference on Machine Learning (ICML)*, 2019.\\n\\nYang, K., Swope, A., Gu, A., Chalamala, R., Song, P., Yu, S., Godil, S., Prenger, R., and Anandkumar, A. Lean-Dojo: Theorem proving with retrieval-augmented language models. In *Neural Information Processing Systems (NeurIPS)*, 2023.\\n\\nZhang, J.-Z., Chou, S.-C., and Gao, X.-S. Automated production of traditional proofs for theorems in Euclidean geometry I. the Hilbert intersection point theorems. *Annals of Mathematics and Artificial Intelligence*, 1995.\"}"}
{"id": "bylZbZOsGA", "page_num": 12, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"A. The Formal System E\\n\\nWe describe our variant of the formal system E in Lean-like pseudocode, including the complete list of axioms. Our design mostly follows E\u2019s original specification (Avigad et al., 2009) with a few minor deviations.\\n\\nA.1. Geometry Objects\\n\\nE has six types of geometric objects: points, lines, circles, segments, angles, and triangles.\\n\\n- Points, lines, and circles are basic types, whereas segments, angles, and triangles are parameterized by points. For example, points \\\\(a, b, c\\\\) can form segment \\\\((a--b)\\\\), angle \\\\(\\\\angle a:b:c\\\\), and triangle \\\\(\\\\triangle a:b:c\\\\).\\n\\n- **Point**: \\\\(\\\\text{Type}\\\\)\\n- **Line**: \\\\(\\\\text{Type}\\\\)\\n- **Circle**: \\\\(\\\\text{Type}\\\\)\\n- **Segment**: \\\\(\\\\text{Point} \\\\rightarrow \\\\text{Point} \\\\rightarrow \\\\text{Type}\\\\)\\n- **Angle**: \\\\(\\\\text{Point} \\\\rightarrow \\\\text{Point} \\\\rightarrow \\\\text{Point} \\\\rightarrow \\\\text{Type}\\\\)\\n- **Triangle**: \\\\(\\\\text{Point} \\\\rightarrow \\\\text{Point} \\\\rightarrow \\\\text{Point} \\\\rightarrow \\\\text{Type}\\\\)\\n\\nA.2. Functions, Constants, and Relations\\n\\nSegments, angles, and triangles are associated with metric properties such as length, degree, and size.\\n\\n- **length**: \\\\(\\\\text{Segment} \\\\rightarrow \\\\mathbb{R}\\\\)\\n- **degree**: \\\\(\\\\text{Angle} \\\\rightarrow \\\\mathbb{R}\\\\)\\n- **size**: \\\\(\\\\text{Triangle} \\\\rightarrow \\\\mathbb{R}\\\\)\\n\\nRight angle (\\\\(\\\\text{Right}\\\\)) is a special constant, denoting 90 degrees.\\n\\n- \\\\(\\\\text{R}\\\\)\\n\\nWe have nine basic predicates denoting the geometric relations between points, lines, and circles. For example, \u201c\\\\(\\\\text{sameSide}\\\\) \\\\(a\\\\ b\\\\ L\\\\)\u201d means points \\\\(a\\\\) and \\\\(b\\\\) are on the same side of the line \\\\(L\\\\).\\n\\n- \\\\(\\\\text{onLine}\\\\) : \\\\(\\\\text{Point} \\\\rightarrow \\\\text{Line} \\\\rightarrow \\\\text{Prop}\\\\)\\n- \\\\(\\\\text{sameSide}\\\\) : \\\\(\\\\text{Point} \\\\rightarrow \\\\text{Point} \\\\rightarrow \\\\text{Line} \\\\rightarrow \\\\text{Prop}\\\\)\\n- \\\\(\\\\text{between}\\\\) : \\\\(\\\\text{Point} \\\\rightarrow \\\\text{Point} \\\\rightarrow \\\\text{Point} \\\\rightarrow \\\\text{Prop}\\\\)\\n- \\\\(\\\\text{onCircle}\\\\) : \\\\(\\\\text{Point} \\\\rightarrow \\\\text{Circle} \\\\rightarrow \\\\text{Prop}\\\\)\\n- \\\\(\\\\text{insideCircle}\\\\) : \\\\(\\\\text{Point} \\\\rightarrow \\\\text{Circle} \\\\rightarrow \\\\text{Prop}\\\\)\\n- \\\\(\\\\text{isCentre}\\\\) : \\\\(\\\\text{Point} \\\\rightarrow \\\\text{Circle} \\\\rightarrow \\\\text{Prop}\\\\)\\n- \\\\(\\\\text{intersectsLine}\\\\) : \\\\(\\\\text{Line} \\\\rightarrow \\\\text{Line} \\\\rightarrow \\\\text{Prop}\\\\)\\n- \\\\(\\\\text{Line.intersectsCircle}\\\\) : \\\\(\\\\text{Line} \\\\rightarrow \\\\text{Circle} \\\\rightarrow \\\\text{Prop}\\\\)\\n- \\\\(\\\\text{Circle.intersectsCircle}\\\\) : \\\\(\\\\text{Circle} \\\\rightarrow \\\\text{Circle} \\\\rightarrow \\\\text{Prop}\\\\)\\n\\nIn addition to the basic predicates, we have four predicates defined as syntactic sugars. For example, \u201c\\\\(\\\\text{opposingSides}\\\\) \\\\(a\\\\ b\\\\ L\\\\)\u201d is the conjunction of \u201c\\\\(\\\\neg \\\\ (\\\\text{onLine}\\\\ a\\\\ L)\\\\)\u201d, \u201c\\\\(\\\\neg \\\\ (\\\\text{onLine}\\\\ b\\\\ L)\\\\)\u201d, and \u201c\\\\(\\\\neg \\\\ (\\\\text{sameSide}\\\\ a\\\\ b\\\\ L)\\\\)\u201d.\\n\\n- \\\\(\\\\text{opposingSides}\\\\) \\\\(\\\\text{a : \\\\text{Point}}\\\\) \\\\(\\\\text{b : \\\\text{Point}}\\\\) \\\\(\\\\text{l : \\\\text{Line}}\\\\) \\\\(\\\\rightarrow \\\\text{Prop}\\\\) := \\\\(\\\\neg \\\\ (\\\\text{onLine}\\\\ a\\\\ l)\\\\) \\\\(\\\\land \\\\neg \\\\ (\\\\text{onLine}\\\\ b\\\\ l)\\\\) \\\\(\\\\land \\\\neg \\\\ (\\\\text{sameSide}\\\\ a\\\\ b\\\\ l)\\\\)\\n- \\\\(\\\\text{outsideCircle}\\\\) \\\\(\\\\text{p : \\\\text{Point}}\\\\) \\\\(\\\\text{c : \\\\text{Circle}}\\\\) \\\\(\\\\rightarrow \\\\text{Prop}\\\\) := \\\\(\\\\neg \\\\ (\\\\text{insideCircle}\\\\ p\\\\ c)\\\\) \\\\(\\\\land \\\\neg \\\\ (\\\\text{onCircle}\\\\ p\\\\ c)\\\\)\\n- \\\\(\\\\text{formTriangle}\\\\) \\\\(\\\\text{a b c : \\\\text{Point}}\\\\) \\\\(\\\\text{AB BC CA : \\\\text{Line}}\\\\) \\\\(\\\\rightarrow \\\\text{Prop}\\\\) := \\\\(\\\\text{distinctPointsOnLine}\\\\ a\\\\ b\\\\ \\\\text{AB}\\\\) \\\\(\\\\land \\\\ (\\\\text{onLine}\\\\ b\\\\ \\\\text{BC})\\\\) \\\\(\\\\land \\\\ (\\\\text{onLine}\\\\ c\\\\ \\\\text{BC})\\\\) \\\\(\\\\land \\\\ (\\\\text{onLine}\\\\ c\\\\ \\\\text{CA})\\\\) \\\\(\\\\land \\\\ (\\\\text{onLine}\\\\ a\\\\ \\\\text{CA})\\\\) \\\\(\\\\land \\\\ (\\\\text{AB} \\\\neq \\\\text{BC})\\\\) \\\\(\\\\land \\\\ (\\\\text{BC} \\\\neq \\\\text{CA})\\\\) \\\\(\\\\land \\\\ (\\\\text{CA} \\\\neq \\\\text{AB})\\\\)\\n- \\\\(\\\\text{formParallelogram}\\\\) \\\\(\\\\text{a b c d : \\\\text{Point}}\\\\) \\\\(\\\\text{AB CD AC BD : \\\\text{Line}}\\\\) \\\\(\\\\rightarrow \\\\text{Prop}\\\\) := \\\\(\\\\text{onLine}\\\\ a\\\\ \\\\text{AB}\\\\) \\\\(\\\\land \\\\ (\\\\text{onLine}\\\\ b\\\\ \\\\text{AB})\\\\) \\\\(\\\\land \\\\ (\\\\text{onLine}\\\\ c\\\\ \\\\text{CD})\\\\) \\\\(\\\\land \\\\ (\\\\text{onLine}\\\\ d\\\\ \\\\text{CD})\\\\) \\\\(\\\\land \\\\ (\\\\text{onLine}\\\\ a\\\\ \\\\text{AC})\\\\) \\\\(\\\\land \\\\ (\\\\text{onLine}\\\\ c\\\\ \\\\text{AC})\\\\) \\\\(\\\\land \\\\ (\\\\text{distinctPointsOnLine}\\\\ b\\\\ d\\\\ \\\\text{BD})\\\\) \\\\(\\\\land \\\\ (\\\\text{sameSide}\\\\ a\\\\ c\\\\ \\\\text{BD})\\\\) \\\\(\\\\land \\\\neg \\\\ (\\\\text{intersectsLine}\\\\ \\\\text{AB}\\\\ \\\\text{CD})\\\\) \\\\(\\\\land \\\\neg \\\\ (\\\\text{intersectsLine}\\\\ \\\\text{AC}\\\\ \\\\text{BD})\\\\)\\n\\n6 Triangles are called \u201careas\u201d in Avigad et al. (2009).\"}"}
{"id": "bylZbZOsGA", "page_num": 21, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"The triangle \\\\( \\\\triangle ABC \\\\) is equilateral, and has been constructed on the given finite straight-line \\\\( AB \\\\). (Which is) the very thing it was required to do.\\n\\nLeanEuclid.\\n\\nBelow is our formalization of Proposition 1. Our proof is concise and follows Euclid's proof closely. It is straightforward to map the tactics in our proofs to sentences in Euclid's proof.\\n\\n\\\\[\\n\\\\text{theorem \\\\ propositional_1 : } \\\\\\\\\\n\\\\forall (a\\\\ b : \\\\text{Point}) \\\\ (AB : \\\\text{Line}), \\\\\\\\\\n\\\\quad \\\\text{distinctPointsOnLine} a\\\\ b\\\\ AB \\\\\\\\\\n\\\\implies \\\\\\\\\\n\\\\exists c : \\\\text{Point}, \\\\quad |(c--a)| = |(a--b)| \\\\\\\\\\n\\\\quad \\\\land \\\\\\\\\\n\\\\quad |(c--b)| = |(a--b)| := \\\\\\\\\\n\\\\text{by} \\\\\\\\\\n\\\\quad \\\\text{euclid_intros} \\\\\\\\\\n\\\\quad \\\\text{euclid_apply} \\\\ \\\\text{circle_from_points} a\\\\ b \\\\ \\\\text{as} \\\\ BCD \\\\\\\\\\n\\\\quad \\\\text{euclid_apply} \\\\ \\\\text{circle_from_points} b\\\\ a \\\\ \\\\text{as} \\\\ ACE \\\\\\\\\\n\\\\quad \\\\text{euclid_apply} \\\\ \\\\text{intersection_circles} BCD \\\\ ACE \\\\ \\\\text{as} \\\\ c \\\\\\\\\\n\\\\quad \\\\text{euclid_apply} \\\\ \\\\text{point_on_circle_onlyif} a\\\\ b\\\\ c\\\\ BCD \\\\\\\\\\n\\\\quad \\\\text{euclid_apply} \\\\ \\\\text{point_on_circle_onlyif} b\\\\ a\\\\ c\\\\ ACE \\\\\\\\\\n\\\\quad \\\\text{use} \\\\ c \\\\\\\\\\n\\\\quad \\\\text{euclid_finish} \\\\\\\\\\n\\\\]\"}"}
{"id": "bylZbZOsGA", "page_num": 22, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nEuclid I.1, construction of an equilateral Triangle on the same side of a point\\n\\n```\\ntheorem iseqtri_sameside_of_ne (ab : a \u2260 b) (aL : OnLine a L) (bL : OnLine b L) (dL : \u00ac OnLine d L):\\n  \u2203 c, \u00ac OnLine c L \u2227 SameSide c d L \u2227 EqTri a b c :=\\n  by\\n  rcases iseqtri_iseqtri_DiffSide_of_ne ab with \u27e8c1, c2, M, aM, bM, c1c2M, eqtri1, eqtri2\u27e9\\n  rcases sameSide_or_of_diffSide' dL (by rwa [line_unique_of_pts ab aM bM aL bL] at c1c2M)\\n  with c1dL | c2dL\\n  refine \u27e8c1, not_onLine_of_sameSide c1dL, c1dL, eqtri1\u27e9\\n  refine \u27e8c2, not_onLine_of_sameSide c2dL, c2dL, eqtri2\u27e9\\n\\nEuclid I.1, construction of a single equilateral Triangle\\n\\ntheorem iseqtri_of_ne (ab : a \u2260 b) :\\n  \u2203 c, EqTri a b c :=\\n  by\\n  rcases iseqtri_iseqtri_DiffSide_of_ne ab with \u27e8c, -, -, -, -, -, eqtri, -\u27e9\\n  ; exact \u27e8c, eqtri\u27e9\\n```\\n\\nBeeson et al. (2019).\\n\\nBelow is Beeson et al. (2019)'s formalization in Coq. Similar to Hernandez-Espiet (2023), it formalizes diagrammatic reasoning manually. As a result, their formal proofs tend to be longer than ours, and it is harder to discern the correspondence with Euclid's proofs.\\n\\n```\\nLemma proposition_01 :\\n  forall A B, neq A B \u2192\\n  \u2203 X, equilateral A B X /\\n  Triangle A B X.\\nProof.\\n  intros.\\n  let Tf:=fresh in\\n  assert (Tf:exists J, CI J A A B) by (conclude postulate_Euclid3);destruct Tf as [J];\\n  spliter.\\n  assert (neq B A) by (conclude lemma_inequalitysymmetric).\\n  let Tf:=fresh in\\n  assert (Tf:exists K, CI K B B A) by (conclude postulate_Euclid3);destruct Tf as [K];\\n  spliter.\\n  let Tf:=fresh in\\n  assert (Tf:exists D, (BetS B A D /\\n  Cong A D A B)) by (conclude lemma_localextension);\\n  destruct Tf as [D];spliter.\\n  assert (Cong B A B A) by (conclude cn_congruencereflexive).\\n  assert (OutCirc D K) by (conclude_def OutCirc) .\\n  assert (eq B B) by (conclude cn_equalityreflexive).\\n  assert (InCirc B K) by (conclude_def InCirc ).\\n  assert (Cong A B A B) by (conclude cn_congruencereflexive).\\n  assert (OnCirc B J) by (conclude_def OnCirc ).\\n  assert (OnCirc D J) by (conclude_def OnCirc ).\\n  assert (eq A A) by (conclude cn_equalityreflexive).\\n  assert (InCirc A J) by (conclude_def InCirc ).\\n  let Tf:=fresh in\\n  assert (Tf:exists C, (OnCirc C K /\\n  OnCirc C J)) by (conclude postulate_circle_circle);\\n  destruct Tf as [C];spliter.\\n  assert (Cong A C A B) by (conclude axiom_circle_center_radius).\\n  assert (Cong A B A C) by (conclude lemma_congruencesymmetric).\\n  assert (Cong B C B A) by (conclude axiom_circle_center_radius).\\n  assert (Cong B C A B) by (forward_using lemma_congruenceflip).\\n  assert (Cong B C A C) by (conclude lemma_congruencetransitive).\\n  assert (Cong A B B C) by (conclude lemma_congruencesymmetric).\\n  assert (Cong A C C A) by (conclude cn_equalityreverse).\\n  assert (Cong B C C A) by (conclude lemma_congruencetransitive).\\n  assert (equilateral A B C) by (conclude_def equilateral ).\\n  assert (neq B C) by (conclude axiom_nocollapse).\\n  assert (neq C A) by (conclude axiom_nocollapse).\\n  assert (\u02dc BetS A C B). { intro. assert (\u02dc Cong A C A B) by (conclude lemma_partnotequalwhole). }\\n```\"}"}
{"id": "bylZbZOsGA", "page_num": 23, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nassert (Cong C A A C) by (conclude cn_equalityreverse).\\nassert (Cong C A A B) by (conclude lemma_congruencetransitive).\\nassert (Cong A C C A) by (conclude cn_equalityreverse).\\nassert (Cong A C A B) by (conclude lemma_congruencetransitive).\\ncontradict.\\n\\nassert (\u02dc BetS A B C).\\nintro.\\nassert (\u02dc Cong A B A C) by (conclude lemma_partnotequalwhole).\\nassert (Cong A B C A) by (conclude lemma_congruencetransitive).\\nassert (Cong C A A C) by (conclude cn_equalityreverse).\\nassert (Cong A B A C) by (conclude lemma_congruencetransitive).\\ncontradict.\\n\\nassert (\u02dc BetS B A C).\\nintro.\\nassert (\u02dc Cong B A B C) by (conclude lemma_partnotequalwhole).\\nassert (Cong B A A B) by (conclude cn_equalityreverse).\\nassert (Cong B A B C) by (conclude lemma_congruencetransitive).\\ncontradict.\\n\\nassert (\u02dc Col A B C).\\nintro.\\nassert (neq A C) by (conclude lemma_inequalitysymmetric).\\nassert ((eq A B \\/ eq A C \\/ eq B C \\/ BetS B A C \\/ BetS A B C \\/ BetS A C B)) by (conclude_def Col).\\ncontradict.\\n\\nassert (Triangle A B C) by (conclude_def Triangle).\\nclose.\\nUnshelve.\\nall: (exact A).\\nQed.\\n\\nD. Autoformalization Prompts\\n\\nHere, we share the prompt templates used in our experiments.\\n\\nD.1. Theorem Statement Formalization\\n\\nTo autoformalize theorem statements from Elements and UniGeo, we used the prompt shown below. We also prepend the instructions with a header describing the task (i.e., \\\"Your task is to take an English statement of a theorem from Euclidean Geometry and formalize it using Lean 4 programming language, adhering to the following structures and guidelines.\\n\\nOne additional intricacy in formalizing theorem statements from Elements is that, unlike in modern mathematics, Euclid does not always state a complete logical theorem statement before beginning a proof. He often begins with an imperative assertion (e.g., Proposition 9: \\\"To cut a given rectilinear angle in half\\\") whose proper logical interpretation is clarified at the conclusion of the proof (e.g., \\\"Thus, angle DAF is equal to angle EAF. Thus, the given rectilinear angle BAC has been cut in half by the straight-line AF\\\"). In other words, to determine the proper logical statement of the theorem, both the beginning and the end of the proof must sometimes be considered. During preliminary experiments, we attempted to autoformalize theorem statements by giving the model the entire natural language proof, but we found that the resulting theorem statements were often very poor. Instead, we manually removed the majority of the \\\"proof\\\" portion of the natural language text, leaving only the portions required to obtain a reasonable formalization of the theorem statement. This context was also included as part of the prompt header when formalizing theorems from Elements. These abbreviated versions of Elements proofs are also available as part of LeanEuclid.\\n\\n/- Basic Geometric Sorts /\\naxiom Point : Type\\n\"}"}
{"id": "bylZbZOsGA", "page_num": 24, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"axiom Line : Type\\naxiom Circle : Type\\n\\n/- Inductive Types for Geometric Entities /\\ninductive Angle | right | ofPoints (A B C : Point)\\ninductive Segment | endpoints (a b : Point)\\ninductive Triangle | ofPoints (a b c : Point)\\n\\n/- Notations and Macros for Geometric Entities /\\n\\\"|(a-- b)|\\\" means the length of the line segment between point a and point b.\\n\\\"\u2220 a:b:c\\\" means the degree of the angle formed by three points a, b, and c.\\n\\\"\\\\\\\" means the right angle.\\n\\\"\u25b3 a:b:c\\\" means the triangle formed from points a, b and c.\\n\\n\\\"Triangle.area \u25b3 a:b:c\\\" means the area of the triangle formed by points a, b and c.\\n\\n/- Relations and Axioms for Geometric Sorts /\\nnamespace Point\\ndef onLine (a : Point) (L : Line) -- point a is on line L.\\ndef sameSide (a b : Point) (L : Line) -- point a and b are on the same side of line L.\\ndef opposingSides (a b : Point) (L : Line) -- point a and b are on the opposite sides of line L.\\ndef collinear (a b c : Point) -- points a, b and c are collinear.\\nend Point\\n\\nnamespace Line\\ndef intersectsLine (L M : Line) -- two lines L and M intersect at some point.\\ndef intersectsCircle (L : Line) (C : Circle) -- line L and circle C intersect.\\nend Line\\n\\nnamespace Circle\\ndef onCircle (a: Point) (C: Circle) -- point a is on circle C.\\ndef insideCircle (a: Point) (C: Circle) -- point a is inside circle C.\\ndef outsideCircle (a: Point) (C: Circle)-- point a is outside circle C.\\ndef isCentre (a: Point) (C: Circle) -- point a is on the center circle C.\\ndef intersectsCircle (C1 C2: Circle) -- circle C1 and C2 intersect.\\nend Circle\\n\\nnamespace Triangle\\ndef congruent (T1 T2 : Triangle) -- triangle T1 and T2 are congruent.\\ndef similar (T1 T2 : Triangle) -- triangle T1 and T2 are similar.\\nend Triangle\\n\\n/- Geometric Relations /\\ndef distinctPointsOnLine (a b : Point) (L : Line) -- points a and b are distinct and on line L.\\ndef twoLinesIntersectAtPoint (AB BC : Line) (b : Point) -- line AB and BC intersect at point b.\\ndef between (a b c : Point) -- points a, b and c collinear and cyclically ordered.\\ndef formTriangle (a b c : Point) (AB BC CA : Line) -- point a, b and c form a triangle, where point a and b are on line AB, point b and c are on line BC, point a and c are on line CA.\\ndef formRectilinearAngle (a b c : Point) (AB BC : Line) -- point a, b and c form a rectilinear angle where a \u2260 b and b \u2260 c.\\ndef formParallelogram (a b c d : Point) (AB CD AC BD : Line) -- point a, b, d and c (in clockwise/counterclockwise order) form a parallelogram, where point a and b are on line AB, where point c and d are on line CD, where point a and c are on line AC, where point b and d are on line BD.\\ndef formQuadrilateral (a b c d : Point) (AB CD BC AD : Line) -- point a, b, c and d (in clockwise/counterclockwise order) form a quadrilateral, where point a and b are on line AB, where point c and d are on line CD, where point b and c are on line BC, where point a and d are on line AD.\\n\\n/- Guidelines: /\\n1. Proposition Format: Your proposition must be of the form \u2200(...) P_1 \u2227 P_2 ... \u2227 P_n \u2192 \u2203(...) Q_1 \u2227 Q_2 ... \u2227 Q_m where each P_i and Q_i is built from the above building blocks using conjunction (\u2227) disjunction (\u2228) and negation (\u00ac). Note that there may be zero existentially quantified variables.\\n2. Implication: There can be only a single implication in the formula; either side of the implication must be a conjunction of formulae.\\n3. Numeric Values Restrictions: Denote 90-degree angle by 90\u00b0, 180-degree angle by 180\u00b0, etc. Also, when referring to segments, we always mean its length (i.e. |(a--b)|).\\n4. Quantified Variables: Your quantified variables must be limited to primitive geometric types: points, lines, and circles. ALL bound variables must be mentioned at some point.\"}"}
{"id": "bylZbZOsGA", "page_num": 33, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"def formQuadrilateral (a b c d : Point) (AB CD AC BD : Line)\\n\\n--- Axioms ---\\n\\n- Construction Rules-\\n\\naxiom extend_point : \u2200 (L : Line) (b c : Point), distinctPointsOnLine b c L \u2192 \u2203 a : Point, a.onLine L \u2227 between b c a\\n\\n- Useful Lemmas from Euclid's Elements Book I-\\n\\n-- In isosceles triangles the angles at the base equal one another, and, if the equal\\nstraight lines are produced further, then the angles under the base equal one another.\\n\\ntheorem proposition_5 : \u2200 (a b c d e : Point) (AB BC AC : Line), formTriangle a b c AB BC AC \u2227 |(a--b)| = |(a--c)| \u2227 between a b d \u2227 between a c e \u2192 (\u2220a:b:c) = (\u2220a:c:b) \u2227 (\u2220c:b:d) = (\u2220b:c:e)\\n\\ntheorem proposition_5' : \u2200 (a b c : Point) (AB BC AC : Line), formTriangle a b c AB BC AC \u2227 |(a--b)| = |(a--c)| \u2192 (\u2220a:b:c) = \u2220a:c:b\\n\\n-- If a straight line stands on a straight line, then it makes either two right angles or\\nangles whose sum equals two right angles.\\n\\ntheorem proposition_13 : \u2200 (a b c d : Point) (AB CD : Line), AB \u2260 CD \u2227 distinctPointsOnLine a b AB \u2227 distinctPointsOnLine c d CD \u2227 between d b c \u2192 \u2220c:b:a + \u2220a:b:d = +\\n\\n-- If two straight lines cut one another, then they make the vertical angles equal to one\\nanother.\\n\\ntheorem proposition_15 : \u2200 (a b c d e : Point) (AB CD : Line), distinctPointsOnLine a b AB \u2227 distinctPointsOnLine c d CD \u2227 e.onLine AB \u2227 e.onLine CD \u2227 CD \u2260 AB \u2227 between d e c \u2227 between a e b \u2192 (\u2220a:e:c) = (\u2220d:e:b) \u2227 (\u2220c:e:b) = (\u2220a:e:d)\\n\\n-- If a straight line falling on two straight lines makes the alternate angles equal to\\none another, then the straight lines are parallel to one another.\\n\\ntheorem proposition_27 : \u2200 (a b c d e f : Point) (AB CD EF : Line), distinctPointsOnLine a b AB \u2227 distinctPointsOnLine c d CD \u2227 distinctPointsOnLine e f EF \u2227 between a e b \u2227 between c f d \u2227 b.sameSide d EF \u2227 \u2220a:e:f = \u2220e:f:d \u2192 \u00ac(AB.intersectsLine CD)\\n\\ntheorem proposition_27' : \u2200 (a d e f : Point) (AB CD EF : Line), distinctPointsOnLine a e AB \u2227 distinctPointsOnLine f d CD \u2227 distinctPointsOnLine e f EF \u2227 a.opposingSides d EF \u2227 \u2220a:e:f = \u2220e:f:d \u2192 \u00ac(AB.intersectsLine CD)\\n\\n-- If a straight line falling on two straight lines makes the exterior angle equal to the\\ninterior and opposite angle on the same side, or the sum of the interior angles on the\\nsame side equal to two right angles, then the straight lines are parallel to one\\nanother.\\n\\ntheorem proposition_28 : \u2200 (a b c d e f g h : Point) (AB CD EF : Line), distinctPointsOnLine a b AB \u2227 distinctPointsOnLine c d CD \u2227 distinctPointsOnLine e f EF \u2227 between a g b \u2227 between c h d \u2227 between e g h \u2227 between g h f \u2227 b.sameSide d EF \u2227 (\u2220e:g:b = \u2220g:h:d \u2228 \u2220b:g:h + \u2220g:h:d = +) \u2192 \u00ac(AB.intersectsLine CD)\\n\\n-- A straight line falling on parallel straight lines makes the alternate angles equal to\\none another, the exterior angle equal to the interior and opposite angle, and the sum\\nof the interior angles on the same side equal to two right angles.\\n\\ntheorem proposition_29 : \u2200 (a b c d e f g h : Point) (AB CD EF : Line), distinctPointsOnLine a b AB \u2227 distinctPointsOnLine c d CD \u2227 distinctPointsOnLine e f EF \u2227 between a g b \u2227 between c h d \u2227 between e g h \u2227 between g h f \u2227 b.sameSide d EF \u2227 \u00ac(AB.intersectsLine CD) \u2192 \u2220a:g:h = \u2220g:h:d \u2227 \u2220e:g:b = \u2220g:h:d \u2227 \u2220b:g:h + \u2220g:h:d = +\\n\\ntheorem proposition_29' : \u2200 (a b c d e g h : Point) (AB CD EF : Line), distinctPointsOnLine a b AB \u2227 distinctPointsOnLine c d CD \u2227 distinctPointsOnLine g h EF \u2227 between a g b \u2227 between c h d \u2227 between e g h \u2227 between g h f \u2227 b.sameSide d EF \u2227 \u00ac(AB.intersectsLine CD) \u2192 \u2220a:g:h = \u2220g:h:d \u2227 \u2220e:g:b = \u2220g:h:d \u2227 \u2220b:g:h + \u2220g:h:d = +\\n\\ntheorem proposition_29'' : \u2200 (a b d g h : Point) (AB CD GH : Line), distinctPointsOnLine a b AB \u2227 distinctPointsOnLine h d CD \u2227 distinctPointsOnLine g h GH \u2227 between a g b \u2227 b.sameSide d GH \u2227 \u00ac(AB.intersectsLine CD) \u2192 \u2220a:g:h = \u2220g:h:d \u2227 \u2220b:g:h + \u2220g:h:d = +\\n\\ntheorem proposition_29''' : \u2200 (a d g h : Point) (AB CD GH : Line), distinctPointsOnLine a g 33\"}"}
{"id": "bylZbZOsGA", "page_num": 34, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\n\\\\[ AB \\\\land \\\\text{distinctPointsOnLine } h \\\\ d \\\\ CD \\\\land \\\\text{distinctPointsOnLine } g \\\\ h \\\\ GH \\\\land a \\\\ \\\\text{opposingSides } d \\\\ GH \\\\land \\\\neg (AB \\\\ . \\\\text{intersectsLine } CD) \\\\rightarrow \\\\angle a \\\\ : g \\\\ : h = \\\\angle g \\\\ : h \\\\ : d \\\\]\\n\\n**Theorem proposition_29''''**:\\n\\n\\\\[ \\\\forall (b \\\\ d \\\\ e \\\\ g \\\\ h : \\\\text{Point}) (AB \\\\ CD \\\\ EF : \\\\text{Line}), \\\\text{distinctPointsOnLine } g \\\\ b \\\\ AB \\\\land \\\\text{distinctPointsOnLine } h \\\\ d \\\\ CD \\\\land \\\\text{distinctPointsOnLine } e \\\\ h \\\\ EF \\\\land \\\\text{between } e \\\\ g \\\\ h \\\\land b \\\\ . \\\\text{sameSide } d \\\\ EF \\\\land \\\\neg (AB \\\\ . \\\\text{intersectsLine } CD) \\\\rightarrow \\\\angle e \\\\ : g \\\\ : b = \\\\angle g \\\\ : h \\\\ : d \\\\]\\n\\n**Theorem proposition_29'''''**:\\n\\n\\\\[ \\\\forall (b \\\\ d \\\\ g \\\\ h : \\\\text{Point}) (AB \\\\ CD \\\\ EF : \\\\text{Line}), \\\\text{distinctPointsOnLine } g \\\\ b \\\\ AB \\\\land \\\\text{distinctPointsOnLine } h \\\\ d \\\\ CD \\\\land \\\\text{distinctPointsOnLine } g \\\\ h \\\\ EF \\\\land b \\\\ . \\\\text{sameSide } d \\\\ EF \\\\land \\\\neg (AB \\\\ . \\\\text{intersectsLine } CD) \\\\rightarrow \\\\angle b \\\\ : g \\\\ : h + \\\\angle g \\\\ : h \\\\ : d = \\\\]\\n\\n-- In any triangle, if one of the sides is produced, then the exterior angle equals the sum of the two interior and opposite angles, and the sum of the three interior angles of the triangle equals two right angles.\\n\\n**Theorem proposition_32**:\\n\\n\\\\[ \\\\forall (a \\\\ b \\\\ c \\\\ d : \\\\text{Point}) (AB \\\\ BC \\\\ AC : \\\\text{Line}), \\\\text{formTriangle } a \\\\ b \\\\ c \\\\ AB \\\\ BC \\\\ AC \\\\land \\\\text{between } b \\\\ c \\\\ d \\\\rightarrow \\\\angle a \\\\ : c \\\\ : d = \\\\angle c \\\\ : a \\\\ : b + \\\\angle a \\\\ : b \\\\ : c \\\\land \\\\angle a \\\\ : b \\\\ : c + \\\\angle b \\\\ : c \\\\ : a + \\\\angle c \\\\ : a \\\\ : b = \\\\]\\n\\n-- In parallelogrammic areas the opposite sides and angles equal one another, and the diameter bisects the areas.\\n\\n**Theorem proposition_34**:\\n\\n\\\\[ \\\\forall (a \\\\ b \\\\ c \\\\ d : \\\\text{Point}) (AB \\\\ CD \\\\ AC \\\\ BD \\\\ BC : \\\\text{Line}), \\\\text{formParallelogram } a \\\\ b \\\\ c \\\\ d \\\\ AB \\\\ CD \\\\ AC \\\\ BD \\\\ BC \\\\land \\\\text{distinctPointsOnLine } b \\\\ c \\\\ BC \\\\rightarrow |(a--b)| = |(c--d)| \\\\land |(a--c)| = |(b--d)| \\\\land \\\\angle a \\\\ : b \\\\ : d = \\\\angle a \\\\ : c \\\\ : d \\\\land \\\\angle b \\\\ : a \\\\ : c = \\\\angle c \\\\ : d \\\\ : b \\\\land \\\\text{Triangle}.area \\\\triangle a \\\\ : b \\\\ : c = \\\\text{Triangle}.area \\\\triangle d \\\\ : c \\\\ : b \\\\land \\\\]\\n\\n**Theorem proposition_34'**:\\n\\n\\\\[ \\\\forall (a \\\\ b \\\\ c \\\\ d : \\\\text{Point}) (AB \\\\ CD \\\\ AC \\\\ BD : \\\\text{Line}), \\\\text{formParallelogram } a \\\\ b \\\\ c \\\\ d \\\\ AB \\\\ CD \\\\ AC \\\\ BD \\\\rightarrow |(a--b)| = |(c--d)| \\\\land |(a--c)| = |(b--d)| \\\\land \\\\angle a \\\\ : b \\\\ : d = \\\\angle a \\\\ : c \\\\ : d \\\\land \\\\angle b \\\\ : a \\\\ : c = \\\\angle c \\\\ : d \\\\ : b \\\\land \\\\]\\n\\n--- Proof DSL ---\\n\\nYour response must be a tactic proof in the LeanEuclid proof DSL. This DSL is built from the following tactics:\\n\\n1. **euclid_intros**\\n   \\n   It introduces universally quantified variables and premises of the current goal into the proof context. No names required.\\n\\n2. **euclid_apply <rule> <args>**\\n   \\n   If <rule> has the form \\\\( \\\\forall (\\\\text{args} : \\\\text{Types}) \\\\ldots P \\\\rightarrow Q \\\\), it instantiates <rule> with <args>, and attempts to prove premise P from the local proof context using the above axioms. If successful, proposition Q is added to the proof context.\\n\\n   **usage examples:**\\n   \\n   euclid_apply proposition_13 A B C D AB CD -- This proves that \\\\( \\\\angle C : B : A + \\\\angle A : B : D = \\\\)\\n\\n   If <rule> has the form \\\\( \\\\forall (\\\\text{args} : \\\\text{Types}) \\\\ldots P \\\\rightarrow \\\\exists x . \\\\ Q(x) \\\\), this tactic instantiates <rule> with <args>, and attempts to prove premise P from the local proof context using the above axioms. If successful, object x and premise Q(x) are added to the proof context.\\n\\n   **usage examples:**\\n   \\n   euclid_apply extend_point L a b as c -- This creates a point c on line L such that b is between a and c.\\n\\n3. **euclid_assert <P>**\\n   \\n   It attempts to prove proposition <P> from the current proof context and the above axioms.\\n\\n4. **euclid_finish**\\n   \\n   It attempts to resolve the proof goal using the current proof context and the above axioms.\\n\\n5. **use <X>**\\n   \\n   This tactic proves an existentially quantified proposition by providing the witness <X> for the quantifier.\\n\\n6. **have <name> : <claim> := by <proof>**\\n   \\n   This tactic proves a lemma <claim>. The <name> is optional, and you need to use euclid_finish at the end of <proof>. If <claim> is already in premise, you can use directly use.\"}"}
{"id": "bylZbZOsGA", "page_num": 35, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"As mentioned in the paper, some of the successful predictions proven correct by $E_3$ were actually syntactic matches with their ground truth formalizations; these cases are not interesting, since existing syntactic evaluation techniques can identify these as correct. What is interesting are cases where the prediction is not a syntactic match with its ground truth. Even a small deviation (e.g., writing $\\\\angle ABC$ rather than $\\\\angle BAC$) may or may not affect the semantics of the result, depending on the context. It is these cases for which $E_3$ offers an improvement over syntactic or manual evaluation methods. We highlight some such cases here.\\n\\n**Proposition 8, GPT-4V , 5-shot.**\\n\\nConsider Proposition 8 of *Elements*, whose abridged version used for autoformalization of theorem statements reads as follows:\\n\\nIf two triangles have two sides equal to two sides, respectively, and also have the base equal to the base, then they will also have equal the angles encompassed by the equal straight-lines. Let $ABC$ and $DEF$ be two triangles having the two sides $AB$ and $AC$ equal to the two sides $DE$ and $DF$, respectively. (That is) $AB$ to $DE$, and $AC$ to $DF$. Let them also have the base $BC$ equal to the base $EF$. I say that the angle $BAC$ is also equal to the angle $EDF$. ... So the angle $BAC$ will also coincide with angle $EDF$, and will be equal to it [C.N. 4]. Thus, if two triangles have two sides equal to two sides, respectively, and have the base equal to the base, then they will also have equal the angles encompassed by the equal straight-lines.\\n\\nThe formalization generated by GPT-4 from this text is as follows, alongside our ground truth formalization:\\n\\n**Prediction:**\\n\\n$\\\\forall (a\\\\ b\\\\ c\\\\ d\\\\ e\\\\ f:\\\\ Point)\\\\ (AB\\\\ AC\\\\ BC\\\\ DE\\\\ DF\\\\ EF:\\\\ Line),$\\n\\n$\\\\text{formTriangle}\\\\ a\\\\ b\\\\ c\\\\ AB\\\\ AC\\\\ BC \\\\land \\\\text{formTriangle}\\\\ d\\\\ e\\\\ f\\\\ DE\\\\ DF\\\\ EF \\\\land |(a--b)| = |(d--e)| \\\\land |(a--c)| = |(d--f)| \\\\land |(b--c)| = |(e--f)| \\\\rightarrow (\\\\angle a:b:c = \\\\angle d:e:f)$\\n\\n**Ground:**\\n\\n$\\\\forall (a\\\\ b\\\\ c\\\\ d\\\\ e\\\\ f:\\\\ Point)\\\\ (AB\\\\ BC\\\\ AC\\\\ DE\\\\ EF\\\\ DF:\\\\ Line),$\\n\\n$\\\\text{formTriangle}\\\\ a\\\\ b\\\\ c\\\\ AB\\\\ BC\\\\ AC \\\\land \\\\text{formTriangle}\\\\ d\\\\ e\\\\ f\\\\ DE\\\\ EF\\\\ DF \\\\land |(a--b)| = |(d--e)| \\\\land |(a--c)| = |(d--f)| \\\\land |(b--c)| = |(e--f)| \\\\rightarrow (\\\\angle b:a:c) = (\\\\angle e:d:f)$\\n\\nSyntactically, there are four differences between the two propositions: in each of the `formTriangle` clauses, we have swapped two sets of lines $BC \\\\rightarrow AC$ and $EF \\\\rightarrow DF$, and in the postcondition, we have also swapped points $b \\\\rightarrow a$ and $e \\\\rightarrow d$. This is a good example of a set of simple perturbations whose validity may not be immediately obvious to a human grader. However, $E_3$ is easily able to prove that these propositions are indeed equivalent.\\n\\n**Proposition 10, GPT-4, 1-shot.**\\n\\nConsider Proposition 10 of *Elements*:\\n\\n\\\"To cut a given finite straight-line in half. Let $AB$ be the given finite straight-line. So it is required to cut the finite straight-line $AB$ in half... Thus, the base $AD$ is equal to the base $BD$ [Prop. 1.4]. Thus, the given finite straight-line $AB$ has been cut in half at (point) $D$.\\\"\\n\\nWhen formalizing this statement, one has to specify that point $D$ lies halfway between $A$ and $B$. Our ground truth formalization formalizes this by asserting that $D$ lies between $A$ and $B$, and the length $|AD|$ is equal to the length $|BD|$.\\\\[35]\"}"}
{"id": "bylZbZOsGA", "page_num": 36, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\n\\\\[\\n\\\\forall (a \\\\ b : \\\\text{Point}) \\\\ (AB : \\\\text{Line}), \\\\ \\\\text{distinctPointsOnLine} \\\\ a \\\\ b \\\\ AB \\\\ \\\\rightarrow \\\\ \\\\exists d : \\\\text{Point}, \\\\ \\\\text{between} \\\\ a \\\\ d \\\\ b \\\\ \\\\land \\\\ |(a--d)| = |(d--b)|\\n\\\\]\\n\\nHowever, there is another way to specify that \\\\( D \\\\) lies exactly halfway between \\\\( A \\\\) and \\\\( B \\\\), as suggested by GPT-4 \u2013 namely, by specifying that, in addition to \\\\(|AD| = |BD|\\\\), we have \\\\(|AD| + |BD| = |AB|\\\\):\\n\\n\\\\[\\n\\\\forall (a \\\\ b : \\\\text{Point}) \\\\ (AB : \\\\text{Line}), \\\\ \\\\text{distinctPointsOnLine} \\\\ a \\\\ b \\\\ AB \\\\ \\\\rightarrow \\\\ \\\\exists d : \\\\text{Point}, \\\\ |(a--d)| = |(b--d)| \\\\ \\\\land \\\\ |(d--b)| + |(a--d)| = |(a--b)|\\n\\\\]\\n\\n\\\\( E^3 \\\\) is able to fill the gap between the two formulations.\\n\\nProposition 20, GPT-4, 1-shot.\\n\\nConsider Proposition 20 of \\\\( \\\\text{Elements} \\\\):\\n\\nIn any triangle, \\\\((the \\\\ sum \\\\ of)\\\\) two sides taken together in any \\\\((possible \\\\ way)\\\\) is greater than the remaining \\\\((side)\\\\). For let \\\\( ABC \\\\) be a triangle. I say that in triangle \\\\( ABC \\\\) \\\\((the \\\\ sum \\\\ of)\\\\) two sides taken together in any \\\\((possible \\\\ way)\\\\) is greater than \\\\((the \\\\ remaining)\\\\) \\\\((side)\\\\)... (So), \\\\((the \\\\ sum \\\\ of)\\\\) \\\\( BA \\\\) and \\\\( AC \\\\) \\\\((is \\\\ greater)\\\\) than \\\\( BC \\\\), \\\\((the \\\\ sum \\\\ of)\\\\) \\\\( AB \\\\) and \\\\( BC \\\\) than \\\\( AC \\\\), and \\\\((the \\\\ sum \\\\ of)\\\\) \\\\( BC \\\\) and \\\\( CA \\\\) than \\\\( AB \\\\). Thus, \\\\((the \\\\ sum \\\\ of)\\\\) \\\\( BA \\\\) and \\\\( AC \\\\) is greater than \\\\( BC \\\\). Similarly, we can show that \\\\((the \\\\ sum \\\\ of)\\\\) \\\\( AB \\\\) and \\\\( BC \\\\) is also greater than \\\\( CA \\\\), and \\\\((the \\\\ sum \\\\ of)\\\\) \\\\( BC \\\\) and \\\\( CA \\\\) than \\\\( AB \\\\). Thus, in any triangle, \\\\((the \\\\ sum \\\\ of)\\\\) two sides taken together in any \\\\((possible \\\\ way)\\\\) is greater than the remaining \\\\((side)\\\\)\\n\\nIn the text, Euclid explicitly mentions each combination of distinct line segments explicitly. However, when formalizing the theorem statement, it is not necessary to do so. All combinations are covered by the following concise formulation:\\n\\n\\\\[\\n\\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) \\\\ (AB \\\\ BC \\\\ AC : \\\\text{Line}), \\\\ \\\\text{formTriangle} \\\\ a \\\\ b \\\\ c \\\\ AB \\\\ BC \\\\ AC \\\\ \\\\rightarrow \\\\ |(b--a)| + |(a--c)| > |(b--c)|\\n\\\\]\\n\\nSince this simplification is not obvious to the model, it will instead attempt to enumerate each for the combinations mentioned:\\n\\n\\\\[\\n\\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) \\\\ (AB \\\\ BC \\\\ CA : \\\\text{Line}), \\\\ \\\\text{formTriangle} \\\\ a \\\\ b \\\\ c \\\\ AB \\\\ BC \\\\ CA \\\\ \\\\rightarrow \\\\ (|(a--b)| + |(b--c)| > |(a--c)|) \\\\ \\\\land \\\\ (|(a--b)| + |(a--c)| > |(b--c)|) \\\\ \\\\land \\\\ (|(b--c)| + |(a--c)| > |(a--b)|)\\n\\\\]\\n\\nUsing only a syntactic similarity metric, one might judge the prediction poorly since it nearly doubles the character length of the ground truth formalization. However, \\\\( E^3 \\\\) correctly identifies them as semantically equivalent.\\n\\nE.2. False Negatives\\n\\nAs mentioned in the paper, \\\\( E^3 \\\\) is occasionally unable to verify reasonable predictions. Based on our sample size, we estimate the false negative rate to be approximately 15%. Here, we share the false negatives we found while manually evaluating the results from GPT-4 and GPT-4V (\\\\( k = 5 \\\\)) in Experiment #1.\\n\\nProposition 1, Both Models, 5-shot.\\n\\nTwo of our false negatives were the same formalization of Proposition 1, whose text reads:\\n\\n\u201cTo construct an equilateral triangle on a given finite straight-line. Let \\\\( AB \\\\) be the given finite straight-line... Thus, the three \\\\((straight-lines)\\\\) \\\\( CA \\\\), \\\\( AB \\\\), and \\\\( BC \\\\) are equal to one another. Thus, the triangle \\\\( ABC \\\\) is equilateral, and has been constructed on the given finite straight-line \\\\( AB \\\\)\u201d.\\n\\n36\"}"}
{"id": "bylZbZOsGA", "page_num": 17, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\npoint_on_circle_onlyif : \\n\u2200 (a b c : Point) (\u03b1 : Circle), (isCentre c \u03b1) \u2227 (onCircle b \u03b1) \u2227 (onCircle c \u03b1) \u2192 |(a--c)| = |(a--b)|\\n\\npoint_in_circle_if : \\n\u2200 (a b c : Point) (\u03b1 : Circle), (isCentre c \u03b1) \u2227 (onCircle b \u03b1) \u2227 (|(a--c)| < |(a--b)|) \u2192 insideCircle c \u03b1\\n\\npoint_in_circle_onlyif : \\n\u2200 (a b c : Point) (\u03b1 : Circle), (isCentre c \u03b1) \u2227 (onCircle b \u03b1) \u2227 (insideCircle c \u03b1) \u2192 |(a--c)| < |(a--b)|\\n\\ndegenerated_angle_if : \\n\u2200 (a b c : Point) (L : Line), (a \u2260 b) \u2227 (a \u2260 c) \u2227 (onLine a L) \u2227 (onLine b L) \u2227 (onLine c L) \u2227 \u00ac (between b a c) \u2192 \u2220b:a:c = 0\\n\\ndegenerated_angle_onlyif : \\n\u2200 (a b c : Point) (L : Line), (a \u2260 b) \u2227 (a \u2260 c) \u2227 (onLine a L) \u2227 (onLine b L) \u2227 (\u2220b:a:c = 0) \u2192 (onLine c L) \u2227 \u00ac (between b a c)\\n\\nsum_angles_if : \\n\u2200 (a b c d : Point) (L M : Line), (onLine a L) \u2227 (onLine a M) \u2227 (onLine b L) \u2227 (onLine c M) \u2227 (a \u2260 b) \u2227 (a \u2260 c) \u2227 \u00ac (onLine d L) \u2227 \u00ac (onLine d M) \u2227 (L \u2260 M) \u2227 (\u2220b:a:c) = (\u2220b:a:d) + (\u2220d:a:c) \u2192 (sameSide b d M) \u2227 (sameSide c d L)\\n\\nsum_angles_onlyif : \\n\u2200 (a b c d : Point) (L M : Line), (onLine a L) \u2227 (onLine a M) \u2227 (onLine b L) \u2227 (onLine c M) \u2227 (a \u2260 b) \u2227 (a \u2260 c) \u2227 \u00ac (onLine d L) \u2227 \u00ac (onLine d M) \u2227 (L \u2260 M) \u2227 (sameSide b d M) \u2227 (sameSide c d L) \u2192 (\u2220b:a:c) = (\u2220b:a:d) + (\u2220d:a:c)\\n\\nperpendicular_if : \\n\u2200 (a b c d : Point) (L : Line), (onLine a L) \u2227 (onLine b L) \u2227 (between a c b) \u2227 \u00ac (onLine d L) \u2227 (\u2220a:c:d = \u2220d:c:b) \u2192 \u2220a:c:d\\n\\nperpendicular_onlyif : \\n\u2200 (a b c d : Point) (L : Line), (onLine a L) \u2227 (onLine b L) \u2227 (between a c b) \u2227 \u00ac (onLine d L) \u2227 (\u2220a:c:d = 0) \u2192 \u2220a:c:d = \u2220d:c:b\\n\\nflat_angle_if : \\n\u2200 (a b c : Point), a \u2260 b \u2227 b \u2260 c \u2227 (\u2220a:b:c = 0 + 0) \u2192 between a b c\\n\\nflat_angle_onlyif : \\n\u2200 (a b c : Point), between a b c \u2192 (\u2220a:b:c = 0 + 0)\\n\\nequal_angles : \\n\u2200 (a b b' c c' : Point) (L M : Line), (onLine a L) \u2227 (onLine b L) \u2227 (onLine b' L) \u2227 (onLine a M) \u2227 (onLine c M) \u2227 (onLine c' M) \u2227 (b \u2260 a) \u2227 (b' \u2260 a) \u2227 (c \u2260 a) \u2227 (c' \u2260 a) \u2227 \u00ac (between b a b') \u2227 \u00ac (between c a c') \u2192 (\u2220b:a:c = \u2220b':a:c')\\n\\nlines_intersect : \\n\u2200 (a b c d : Point) (L M N : Line), (onLine a L) \u2227 (onLine b L) \u2227 (onLine b M) \u2227 (onLine c M) \u2227 (onLine c N) \u2227 (onLine d N) \u2227 (b \u2260 c) \u2227 (sameSide a d M) \u2227 (\u2220a:b:c) + (\u2220b:c:d) < 0 + 0 \u2192 \u2203 e : Point, (onLine e L) \u2227 (onLine e N) \u2227 (sameSide e a M)\\n\\ndegenerated_area_if : \\n\u2200 (a b c : Point) (L : Line), distinctPointsOnLine a b L \u2227 (Triangle.area \u25b3 a:b:c) = 0 \u2192 onLine c L\\n\\ndegenerated_area_onlyif : \\n\u2200 (a b c : Point) (L : Line), distinctPointsOnLine a b L \u2227 (onLine c L) \u2192 (Triangle.area \u25b3 a:b:c) = 0\\n\\nsum_areas_if : \\n\u2200 (a b c d : Point) (L : Line), (onLine a L) \u2227 (onLine b L) \u2227 (onLine c L) \u2227 (a \u2260 b) \u2227 (a \u2260 c) \u2227 (b \u2260 c) \u2227 \u00ac (onLine d L) \u2227 (between a c b) \u2192 (Triangle.area \u25b3 a:c:d + Triangle.area \u25b3 d:c:b = Triangle.area \u25b3 a:d:b)\\n\\nsum_areas_onlyif : \\n\u2200 (a b c d : Point) (L : Line), (onLine a L) \u2227 (onLine b L) \u2227 (onLine c L) \u2227 (a \u2260 b) \u2227 (a \u2260 c) \u2227 (b \u2260 c) \u2227 \u00ac (onLine d L) \u2227 (Triangle.area \u25b3 a:c:d + Triangle.area \u25b3 d:c:b = Triangle.area \u25b3 a:d:b) \u2192 (between a c b)\\n\\nparallelogram_area : \\n\u2200 (a b c d : Point) (AB CD AC BD : Line), (formParallelogram a b c d AB CD AC BD) \u2192 (Triangle.area \u25b3 a:c:d + Triangle.area \u25b3 a:d:b = Triangle.area \u25b3 b:a:c + Triangle.area \u25b3 b:c:d)\\n\\nsum_parallelograms_area : \\n\u2200 (a b c d e f : Point) (AB CD AC BD : Line), (formParallelogram a b c d AB CD AC BD) \u2227 (between a e b) \u2227 (between c f d) \u2192 (Triangle.area \u25b3 a:c:f + Triangle.area \u25b3 a:f:e + Triangle.area \u25b3 e:f:d + Triangle.area \u25b3 e:d:b = Triangle.area \u25b3 a:c:d + Triangle.area \u25b3 a:d:b)\"}"}
{"id": "bylZbZOsGA", "page_num": 18, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nrectangle_area : \\\\(\\\\forall (a \\\\ b \\\\ c \\\\ d : \\\\text{Point}) \\\\ (AB \\\\ CD \\\\ AC \\\\ BD : \\\\text{Line}), \\\\ \\\\text{formParallelogram} \\\\ a \\\\ b \\\\ c \\\\ d \\\\ AB \\\\ CD \\\\ AC \\\\ BD \\\\rightarrow (\\\\text{Triangle.area} \\\\ \\\\triangle a : c : d + \\\\text{Triangle.area} \\\\ \\\\triangle a : b : d = |(a--b)| \\\\times |(a--c)|) \\\\land (\\\\text{Triangle.area} \\\\ \\\\triangle b : a : c + \\\\text{Triangle.area} \\\\ \\\\triangle b : d : c = |(a--b)| \\\\times |(a--c)|)\\\\)\\n\\nSuperposition Rule.\\n\\nFinally, we have a superposition rule to handle Euclid's method of superposition for proving Proposition 4 and Proposition 8 in the first book of *Elements*. The rule follows the idea in Avigad.\\n\\nsuperposition : \\\\(\\\\forall (a \\\\ b \\\\ c \\\\ d \\\\ g \\\\ h : \\\\text{Point}) \\\\ (AB \\\\ BC \\\\ AC \\\\ L : \\\\text{Line}), \\\\ \\\\text{formTriangle} \\\\ a \\\\ b \\\\ c \\\\ AB \\\\ BC \\\\ AC \\\\land \\\\text{distinctPointsOnLine} \\\\ d \\\\ g \\\\ L \\\\land \\\\neg \\\\text{onLine} \\\\ h \\\\ L \\\\rightarrow \\\\exists (b' \\\\ c' : \\\\text{Point}) \\\\ (BC' \\\\ AC' : \\\\text{Line}), \\\\ \\\\text{angle equality conditions}\\\\land |(a--b)| = |(d--b')| \\\\land |(b--c)| = |(b'--c')| \\\\land |(c--a)| = |(c'--d)| \\\\land \\\\text{onLine} \\\\ b' \\\\ L \\\\land \\\\neg \\\\text{between} \\\\ b' \\\\ d \\\\ g \\\\land \\\\text{sameSide} \\\\ c' \\\\ h \\\\ L \\\\land \\\\text{distinctPointsOnLine} \\\\ b' \\\\ c' \\\\ BC' \\\\land \\\\text{distinctPointsOnLine} \\\\ d \\\\ c' \\\\ AC'\\\\)\\n\\nAxioms Used by the Symbolic Engine.\\n\\nOur symbolic reasoning engine (Sec. 3.3) is based on SMT solvers. Therefore, it always has access to all built-in theories in SMT, e.g., the theory of real numbers. When used for diagrammatic reasoning, it can also use all diagrammatic rules, metric rules, and transfer rules. When used for equivalence checking, it additionally has access to nine simple construction rules: arbitrary point, distinct points, line nonempty, exists point between points on line, distinct point same side, exists point opposite, exists point on circle, line from points, and intersection lines.\\n\\nB. An Example of Logical Gaps in Euclid's Proofs Found by Formalization\\n\\nBelow is Euclid's proof of Proposition 24 from Heiberg (2007):\\n\\nIf two triangles have two sides equal to two sides, respectively, but (one) has the angle encompassed by the equal straight-lines greater than the (corresponding) angle (in the other), then (the former triangle) will also have a base greater than the base (of the latter).\\n\\nLet \\\\(\\\\triangle ABC\\\\) and \\\\(\\\\triangle DEF\\\\) be two triangles having the two sides \\\\(AB\\\\) and \\\\(AC\\\\) equal to the two sides \\\\(DE\\\\) and \\\\(DF\\\\), respectively. (That is), \\\\(AB\\\\) (equal) to \\\\(DE\\\\), and \\\\(AC\\\\) to \\\\(DF\\\\). Let them also have the angle at \\\\(A\\\\) greater than the angle at \\\\(D\\\\). I say that the base \\\\(BC\\\\) is also greater than the base \\\\(EF\\\\). For since angle \\\\(BAC\\\\) is greater than angle \\\\(EDF\\\\), let (angle) \\\\(EDG\\\\), equal to angle \\\\(BAC\\\\), have been constructed at the point \\\\(D\\\\) on the straight-line \\\\(DE\\\\) \\\\([Prop. 1.23]\\\\). And let \\\\(DG\\\\) be made equal to either of \\\\(AC\\\\) or \\\\(DF\\\\) \\\\([Prop. 1.3]\\\\), and let \\\\(EG\\\\) and \\\\(FG\\\\) have been joined. Therefore, since \\\\(AB\\\\) is equal to \\\\(DE\\\\) and \\\\(AC\\\\) to \\\\(DG\\\\), the two (straight-lines) \\\\(BA\\\\), \\\\(AC\\\\) are equal to the two (straight-lines) \\\\(ED\\\\), \\\\(DG\\\\), respectively. Also the angle \\\\(BAC\\\\) is equal to the angle \\\\(EDG\\\\). Thus, the base \\\\(BC\\\\) is equal to the base \\\\(EG\\\\) \\\\([Prop. 1.4]\\\\). Again, since \\\\(DF\\\\) is equal to \\\\(DG\\\\), angle \\\\(DGF\\\\) is also equal to angle \\\\(DF G\\\\).\"}"}
{"id": "bylZbZOsGA", "page_num": 19, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Thus, \\\\( \\\\Delta \\\\) is greater than \\\\( \\\\Delta \\\\). Thus, \\\\( \\\\Delta \\\\) is much greater than \\\\( \\\\Delta \\\\). And since triangle \\\\( \\\\Delta \\\\) has angle \\\\( \\\\angle \\\\) greater than \\\\( \\\\angle \\\\), and the greater angle is subtended by the greater side [Prop. 1.19], side \\\\( \\\\Delta \\\\) is thus also greater than \\\\( \\\\Delta \\\\). But \\\\( \\\\Delta \\\\) is equal to \\\\( \\\\Delta \\\\). Thus, \\\\( \\\\Delta \\\\) is also greater than \\\\( \\\\Delta \\\\).\\n\\nThus, if two triangles have two sides equal to two sides, respectively, but (one) has the angle encompassed by the equal straight-lines greater than the (corresponding) angle (in the other), then (the former triangle) will also have a base greater than the base (of the latter). (Which is) the very thing it was required to show.\\n\\nEuclid did not cover the case where \\\\( \\\\Delta \\\\) and \\\\( \\\\Delta \\\\) are on different sides of \\\\( \\\\Delta \\\\) (Fig. A). For this case, we come up with the proof below, which is significantly more complicated than Euclid's proof. Therefore, we argue that Euclid's proof of Proposition 24 has a logical gap.\\n\\nSimilar to what Euclid did, let's construct \\\\( \\\\Delta \\\\) s.t., \\\\( \\\\angle \\\\) = \\\\( \\\\angle \\\\), \\\\( \\\\Delta \\\\) = \\\\( \\\\Delta \\\\), and \\\\( \\\\Delta \\\\) = \\\\( \\\\Delta \\\\) (Fig. A). By Proposition 5, we have \\\\( \\\\angle \\\\) = \\\\( \\\\angle \\\\); let's denote it by \\\\( \\\\alpha \\\\). To prove \\\\( \\\\Delta \\\\) > \\\\( \\\\Delta \\\\), we only need to prove \\\\( \\\\Delta \\\\) > \\\\( \\\\Delta \\\\). By Proposition 19, this is further reduced to \\\\( \\\\angle \\\\) > \\\\( \\\\angle \\\\). Let \\\\( x = \\\\angle \\\\) and \\\\( y = \\\\angle \\\\). We want to prove \\\\( x > y \\\\). Note that \\\\( \\\\angle \\\\) = \\\\( \\\\angle \\\\) + \\\\( \\\\angle \\\\) = \\\\( \\\\alpha \\\\) + \\\\( y \\\\). \\\\( \\\\angle \\\\) = \\\\( 2\\\\pi \\\\) - \\\\( \\\\angle \\\\) - \\\\( \\\\angle \\\\) = \\\\( 2\\\\pi \\\\) - \\\\( \\\\alpha \\\\) - \\\\( x \\\\). Furthermore, Proposition 17 states that the sum of any two angles in a triangle must be smaller than \\\\( \\\\pi \\\\). Therefore, any angle in a triangle must also be smaller than \\\\( \\\\pi \\\\), i.e., \\\\( \\\\alpha \\\\) + \\\\( y \\\\) < \\\\( \\\\pi \\\\).\\\\( 2\\\\pi \\\\) - \\\\( \\\\alpha \\\\) - \\\\( x \\\\) < \\\\( \\\\pi \\\\). Simplifying these two inequalities leads to \\\\( x > y \\\\). QED.\\n\\nFigure A. The case in Proposition 24 missed by Euclid.\\n\\nBelow is our formal proof of Proposition 24, which explicitly handles the case in Fig. A following the informal proof above.\\n\\n```\\ntheorem proposition_24 :\\n  \\\\( \\\\forall (a b c d e f : \\\\) Point\\\\) \\\\( \\\\land (\\\\) AB BC AC DE EF DF : Line\\\\),\\n  formTriangle a b c AB BC AC \\\\( \\\\land \\\\)\\n  formTriangle d e f DE EF DF \\\\( \\\\land \\\\)\\n  \\\\( |(a--b)| = |(d--e)| \\\\) \\\\( \\\\land \\\\)\\n  \\\\( |(a--c)| = |(d--f)| \\\\) \\\\( \\\\land \\\\)\\n  \\\\( \\\\angle b:a:c > \\\\angle e:d:f \\\\) \\\\( \\\\rightarrow \\\\)\\n  \\\\( |(b--c)| > |(e--f)| \\\\) :=\\n  by euclid_intros\\n  euclid_apply (proposition_23' d e a b c f DE AB AC) as g'\\n  euclid_apply (line_from_points d g') as DG\\n  euclid_apply (extend_point_longer DG d g' (a--c)) as g''\\n  euclid_apply (proposition_3 d g'' a c DG AC) as g\\n  euclid_apply (line_from_points e g) as EG\\n  euclid_apply (line_from_points f g) as FG\\n  euclid_apply (proposition_4 a b c d e g AB BC AC DE EG DG)\\n  euclid_apply (proposition_5' d g f DG FG DF)\\n  by_cases (d.sameSide g EF)\\n  . euclid_assert (\\\\( \\\\angle d:f:g > \\\\angle e:g:f \\\\))\\n  . euclid_assert (\\\\( \\\\angle e:f:g > \\\\angle e:g:f \\\\))\\n  euclid_apply (proposition_19 e f g EF FG EG)\\n  euclid_finish\\n```\"}"}
{"id": "bylZbZOsGA", "page_num": 20, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\nby cases g.onLine EF\\neuclid_finish\\neuclid_apply (extend_point FG g f) as h\\neuclid_assert \u00ac (g.onLine DF)\\neuclid_assert \u00ac (e.onLine DF)\\neuclid_assert (g.opposingSides e DF)\\neuclid_assert h.sameSide e DF\\neuclid_apply (proposition_13 d f g h DF FG)\\neuclid_apply (proposition_13 e f g h EF FG)\\neuclid_apply (proposition_17 d g e DG EG DE)\\neuclid_apply (proposition_17 d f e DF EF DE)\\neuclid_assert (\\\\angle d:g:e < \\\\angle d:f:e = \\\\angle e:f:g + \\\\angle g:f:d + \\\\angle d:f:e = 0 + 0 + 0 + 0)\\neuclid_assert (\\\\angle e:f:g > \\\\angle e:g:f)\\neuclid_apply (proposition_19 e f g EF FG EG)\\neuclid_finish\\n\\nC. Comparison to Existing Formalization of Elements\\nIn this section, we compare our formalizations of Elements with existing formalizations, with the goal of demonstrating how our proof automation enables formal proofs that are closer in nature to the original natural language proofs. However, it is important to note that we are making a tradeoff between proof automation and end-to-end certification of proofs. As mentioned in Sec. 2, the results of SMT solvers are not certified or reconstructed as Lean proofs; instead, we introduce an unsound axiom that allows us to admit successful SMT queries to prove any proposition. In practical terms, this means that our proofs are certified up to (i) the soundness of the proof assistant kernel, (ii) any errors in our translation from Lean proof contexts to SMT-LIB queries, and (iii) the soundness of the SMT solvers themselves. By contrast, the other formalizations discussed here only require trusting the proof assistant kernel.\\n\\nWe use Proposition 1 as an example to compare LeanEuclid with existing formalizations of Euclid's Elements (Hernandez-Espiet, 2023; Beeson et al., 2019). Below is Euclid's proof of Proposition 1 from Heiberg (2007):\\n\\nTo construct an equilateral triangle on a given finite straight-line.\\nLet AB be the given finite straight-line.\\nSo it is required to construct an equilateral triangle on the straight-line AB.\\nLet the circle BCD with center A and radius AB have been drawn [Post.3], and again let the circle ACE with center B and radius BA have been drawn [Post.3]. And let the straight-lines CA and CB have been joined from the point C, where the circles cut one another, to the points A and B (respectively) [Post.1].\\nAnd since the point A is the center of the circle CDB, AC is equal to AB [Def.5]. Again, since the point B is the center of the circle CAE, BC is equal to BA [Def.5]. But CA was also shown (to be) equal to AB. Thus, CA and CB are each equal to AB. But things equal to the same thing are also equal to one another [C.N.1]. Thus, CA is also equal to CB. Thus, the three (straight-lines) CA, AB, and BC are equal to one another.\"}"}
{"id": "bylZbZOsGA", "page_num": 41, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"F.3. Partially Correct Autoformalized Proofs from Elements\\n\\nHere, we showcase some attempts at autoformalizing proofs from Elements which, despite being incorrect, require only minor modifications to be repaired. These exemplars demonstrate that, in many cases, the steps required to repair the proof do not require creative insight. Moreover, we believe this process is quite amenable to automation.\\n\\nProposition 3, GPT-4.\\n\\nNatural language proof:\\n\\n\\\"For two given unequal straight-lines, to cut off from the greater a straight-line equal to the lesser. Let $AB$ and $C$ be the two given unequal straight-lines, of which let the greater be $AB$. So it is required to cut off a straight-line equal to the lesser $C$ from the greater $AB$. Let the line $AD$, equal to the straight-line $C$, have been placed at point $A$ [Prop. 1.2]. And let the circle $DEF$ have been drawn with center $A$ and radius $AD$ [Post. 3]. And since point $A$ is the center of circle $DEF$, $AE$ is equal to $AD$ [Def. 1.15]. But, $C$ is also equal to $AD$. Thus, $AE$ and $C$ are each equal to $AD$. So $AE$ is also equal to $C$ [C.N. 1]. Thus, for two given unequal straight-lines, $AB$ and $C$, the (straight-line) $AE$, equal to the lesser $C$, has been cut off from the greater $AB$. (Which is) the very thing it was required to do.\\\"\\n\\nAutoformalized Proof:\\n\\n```\\ndef prop3_prediction : \\n  \u2200 (a b c0 c1 : Point) (AB C : Line),\\n  distinctPointsOnLine a b AB \u2227 distinctPointsOnLine c0 c0 C \u2227 a \u2260 c0 \u2227 |(a--b)| > |(c0--c1)| \u2192 \\n  \u2203 e, between a e b \u2227 |(a--e)| = |(c0--c1)| :=\\n  by euclid_intros euclid_apply (proposition_2 a c0 c1 C) as d\\n  euclid_apply (circle_from_points a d) as DEF\\n  euclid_apply (intersection_circle_line DEF AB) as (e, f)\\n  euclid_apply (point_on_circle_onlyif a d e DEF)\\n  euclid_apply between_if a e b\\n  use e\\n  euclid_finish\\n```\\n\\nTo prove the precondition for `between_if`, we need the fact between $a e b$, which is not provable from the preceding tactics. To repair this proof, we can use a stronger version of `intersection_circle_line` on Line 9.\\n\\nRepaired Proof:\\n\\n```\\ndef prop3_repaired : \\n  \u2200 (a b c0 c1 : Point) (AB C : Line),\\n  distinctPointsOnLine a b AB \u2227 distinctPointsOnLine c0 c0 C \u2227 a \u2260 c0 \u2227 |(a--b)| > |(c0--c1)| \u2192 \\n  \u2203 e, between a e b \u2227 |(a--e)| = |(c0--c1)| :=\\n  by euclid_intros euclid_apply (proposition_2 a c0 c1 C) as d\\n  euclid_apply (circle_from_points a d) as DEF\\n  euclid_apply (intersection_circle_line DEF AB) as (e, f)\\n  euclid_apply (point_on_circle_onlyif a d e DEF)\\n  euclid_apply between_if a e b\\n  use e\\n  euclid_finish\\n```\"}"}
{"id": "bylZbZOsGA", "page_num": 42, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"distinctPointsOnLine a b AB \u2227 distinctPointsOnLine c0 c0 C \u2227 a \u2260 c0 \u2227 |(a--b)| > |(c0--c1)| \u2192 \u2203 e, between a e b \u2227 |(a--e)| = |(c0--c1)| := by euclid_intros\\n\\neuclid_apply (proposition_2 a c0 c1 C) as d\\neuclid_apply (circle_from_points a d) as DEF\\n\\neuclid_apply (intersection_circle_line_between_points DEF AB a b) as e\\n\\neuclid_apply (point_on_circle_onlyif a d e DEF)\\neuclid_apply between_if a e b\\n\\nuse e\\n\\neuclid_finish\\n\\nProposition 5, GPT-4.\\n\\nNatural language proof:\\n\\n\\\"For isosceles triangles, the angles at the base are equal to one another, and if the equal sides are produced then the angles under the base will be equal to one another. Let \\\\( \\\\triangle ABC \\\\) be an isosceles triangle having the side \\\\( AB \\\\) equal to the side \\\\( AC \\\\), and let the straight-lines \\\\( BD \\\\) and \\\\( CE \\\\) have been produced in a straight-line with \\\\( AB \\\\) and \\\\( AC \\\\) (respectively) [Post. 2]. I say that \\\\( \\\\angle ABC \\\\) is equal to \\\\( \\\\angle ACB \\\\), and (angle) \\\\( \\\\angle CBD \\\\) to \\\\( \\\\angle BCE \\\\). For let the point \\\\( F \\\\) have been taken at random on \\\\( BD \\\\), and \\\\( AG \\\\) have been cut off from the greater \\\\( AE \\\\), equal to the lesser \\\\( AF \\\\) [Prop. 1.3]. Also, let the straight-lines \\\\( FC \\\\) and \\\\( GB \\\\) have been joined [Post. 1]. In fact, since \\\\( AF \\\\) is equal to \\\\( AG \\\\), and \\\\( AB \\\\) to \\\\( AC \\\\), the two (straight-lines) \\\\( FA \\\\), \\\\( AC \\\\) are equal to the two (straight-lines) \\\\( GA \\\\), \\\\( AB \\\\), respectively. They also encompass a common angle, \\\\( F AG \\\\). Thus, the base \\\\( FC \\\\) is equal to \\\\( GB \\\\), and the triangle \\\\( AF C \\\\) will be equal to the triangle \\\\( AGB \\\\), and the remaining angles subtended by the equal sides will be equal to the corresponding remaining angles [Prop. 1.4]. (That is) \\\\( \\\\angle ACF \\\\) to \\\\( \\\\angle ABG \\\\), and \\\\( \\\\angle AF C \\\\) to \\\\( \\\\angle AGB \\\\). And since the whole of \\\\( AF \\\\) is equal to the whole of \\\\( AG \\\\), within which \\\\( AB \\\\) is equal to \\\\( AC \\\\), the remainder \\\\( BF \\\\) is thus equal to the remainder \\\\( CG \\\\) [C.N. 3]. But \\\\( FC \\\\) was also shown (to be) equal to \\\\( GB \\\\). So the two (straight-lines) \\\\( BF \\\\), \\\\( FC \\\\) are equal to the two (straight-lines) \\\\( CG \\\\), \\\\( GB \\\\), respectively, and the angle \\\\( BF C \\\\) (is) equal to the angle \\\\( CGB \\\\), and the base \\\\( BC \\\\) is common to them. Thus, the triangle \\\\( BF C \\\\) will be equal to the triangle \\\\( CGB \\\\), and the remaining angles subtended by the equal sides will be equal to the corresponding remaining angles [Prop. 1.4]. Thus, \\\\( \\\\angle F BC \\\\) is equal to \\\\( \\\\angle GCB \\\\), and \\\\( \\\\angle BCF \\\\) to \\\\( \\\\angle CBG \\\\). Therefore, since the whole angle \\\\( ABG \\\\) was shown (to be) equal to the whole angle \\\\( ACF \\\\), within which \\\\( CBG \\\\) is equal to \\\\( BCF \\\\), the remainder \\\\( ABC \\\\) is thus equal to the remainder \\\\( ACB \\\\) [C.N. 3]. And they are at the base of triangle \\\\( ABC \\\\). And \\\\( F BC \\\\) was also shown (to be) equal to \\\\( GCB \\\\). And they are under the base. Thus, for isosceles triangles, the angles at the base are equal to one another, and if the equal sides are produced then the angles under the base will be equal to one another. (Which is) the very thing it was required to show.\\\"\\n\\nAutoformalized Proof:\\n\\ndef prop5_prediction :\\n\u2200 (a b c d e : Point) (AB BC AC : Line), formTriangle a b c AB BC AC \u2227 |(a--b)| = |(a--c)| \u2227 between a b d \u2227 between a c e \u2192 \u2220 a:b:c = \u2220 a:c:b \u2227 \u2220 c:b:d = \u2220 b:c:e := by euclid_intros\\neuclid_apply (exists_point_between_points_on_line AB b d) as f\\n\\neuclid_apply (proposition_3 e a a f AC AB) as g\\n\\neuclid_apply (line_from_points f c) as FC\\n\\neuclid_apply (line_from_points g b) as GB\\n\\neuclid_apply proposition_4 f a c g a b FC AC GB AB AC AB\\n\\neuclid_apply (between_if f b a)\\neuclid_apply (between_if g c a)\\neuclid_apply (proposition_4 b f c c g b AB FC BC GB BC AB)\\n\\nuse f, g, FC, GB\\n\\neuclid_finish\\n\\nIn order to prove the preconditions for proposition 3, we need to know |ba| < |ce|, which can be obtained via a stronger version of exists point between points on line on Line 2. We also need to rearrange some of the arguments on in the invocations of proposition 3 and proposition 4. Finally, we can remove the invocation of tactic use entirely, since it is inapplicable in this proof context.\\n\\nRepaired Proof:\"}"}
{"id": "bylZbZOsGA", "page_num": 43, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"def prop7_repaired :\\n\u2200 (a b c d : Point) (AB AC CB AD DB CD : Line),\\nsuccessivePointsOnLine a b AB \u2227 successivePointsOnLine a c AC \u2227 successivePointsOnLine c b CB \u2227 successivePointsOnLine a d AD \u2227 successivePointsOnLine d b DB \u2227 Point.sameSide c d AB \u2227 successivePointsOnLine c d CD \u2227 Point.sameSide a b CD \u2227 Point.sameSide d b AC \u2227 |(a--c)| = |(a--d)| \u2227 |(c--b)| = |(d--b)| \u2192 False :=\\nby euclid_intros\\neuclid_apply (line_from_points c d) as CD\\neuclid_apply proposition_5 c a d AC AD CD\\neuclid_apply proposition_5 c b d CB DB CD\\nby_cases (\u2220 c:a:d) > (\u2220 d:c:b)\\n   . euclid_apply proposition_5' c a d b AC AD CD AB\\n   euclid_finish\\nby_cases (\u2220 c:b:d) > (\u2220 d:c:b)\\n   . euclid_apply proposition_5' c b d a CB DB CD AB\\n   euclid_finish\\n   . euclid_finish\\n\\nThe rule proposition 5 takes five points and three lines as argument, whereas the variant proposition 5' takes three of each. It is easiest to fix the fourth and fifth tactics by instead invoking the latter theorem (and tweaking the arguments). The euclid apply within the case analysis also need repairing, since they are using too many arguments. These tactics are actually redundant, since euclid finish can complete the proof. Nevertheless, simply ommitting the last point and line from each tactic is sufficient to make the proof go through.\\n\\nRepaired Proof:\\ndef prop7_repaired :\\n\u2200 (a b c d : Point) (AB AC CB AD DB CD : Line),\\nsuccessivePointsOnLine a b AB \u2227 successivePointsOnLine a c AC \u2227 successivePointsOnLine c b CB \u2227 successivePointsOnLine a d AD \u2227 successivePointsOnLine d b DB \u2227 Point.sameSide c d AB \u2227 successivePointsOnLine c d CD \u2227 Point.sameSide a b CD \u2227 Point.sameSide d b AC \u2227 |(a--c)| = |(a--d)| \u2227 |(c--b)| = |(d--b)| \u2192 False :=\\n43\"}"}
{"id": "bylZbZOsGA", "page_num": 44, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Proposition 18, GPT-4V.\\n\\nNatural language proof:\\n\\\"In any triangle, the greater side subtends the greater angle. For let $ABC$ be a triangle having side $AC$ greater than $AB$. I say that angle $ABC$ is also greater than $BCA$. For since $AC$ is greater than $AB$, let $AD$ be made equal to $AB$ [Prop. 1.3], and let $BD$ have been joined. And since angle $ADB$ is external to triangle $BCD$, it is greater than the internal and opposite (angle) $DCB$ [Prop. 1.16]. But $ADB$ (is) equal to $ABD$, since side $AB$ is also equal to side $AD$ [Prop. 1.5]. Thus, $ABD$ is also greater than $ACB$. Thus, $ABC$ is much greater than $ACB$. Thus, in any triangle, the greater side subtends the greater angle. (Which is) the very thing it was required to show.\\\"\\n\\nAutoformalized Proof:\\n```haskell\\ndef prop18_prediction :\\n  \u2200 (a b c : Point) (AB BC AC : Line), formTriangle a b c AB BC AC \u2227 (|(a --c)| > |(a--b)|) \u2192 (\u2220a:b:c > \u2220b:c:a):= by euclid_intros\\n  euclid_apply proposition_3 a c a b AC AB as d\\n  euclid_apply line_from_points b d as BD\\n  euclid_apply proposition_16 a b d c AB BD AC\\n  euclid_apply proposition_5 a b d AB BD as H1\\n  euclid_apply proposition_6 a b d AB BD AC\\n  euclid_finish\\n```\\n\\nThe second tactic does not provide the right number of arguments to proposition 3, but it does for proposition 3'. The preconditions of the invocation of proposition 16 are not provable from the preceding steps, but we can permute points and $a, b, c$ to recover a valid tactic. The invocation of proposition 5 has the same problem as proposition 3, and is replaced with proposition 5'. Also, the keyword \\\"as\\\" can only be used for constructive theorems, which proposition 5 is not. We can simply drop \\\"as H1\\\" and the proof goes through.\\n\\nRepaired Proof:\\n```haskell\\ndef prop18_repaired :\\n  \u2200 (a b c : Point) (AB BC AC : Line), formTriangle a b c AB BC AC \u2227 (|(a --c)| > |(a--b)|) \u2192 (\u2220a:b:c) > \u2220b:c:a):= euclid_intros\\n  euclid_apply proposition_3' a c a b AC AB as d\\n  euclid_apply line_from_points b d as BD\\n  euclid_apply proposition_16 b c d a BC AC BD\\n  euclid_apply proposition_5' a b d AB BD AC\\n  euclid_apply proposition_6 a b d AB BD AC\\n  euclid_finish\\n```\\n\\nProposition 34, GPT-4V.\\n\\nNatural language proof:\\n\\\"In parallelogrammic figures the opposite sides and angles are equal to one another, and a diagonal cuts them in half. Let $ACDB$ be a parallelogrammic figure, and $BC$ its diagonal. I say that for parallelogram $ACDB$, the opposite sides and angles are equal to one another, and the diagonal $BC$ cuts it in half. For since $AB$ is parallel to $CD$, and the straight-line $BC$ has fallen across them, the alternate angles $ABC$ and $BCD$ are equal to one another [Prop. 1.29]. Again, since $AC$ is parallel to $BD$, and $BC$ has fallen across them, the alternate angles $ACB$ and $CBD$ are equal to one another [Prop. 1.29].\\\"\\n\\n44\"}"}
{"id": "bylZbZOsGA", "page_num": 37, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nOur ground truth formalization is as follows:\\n\\n\\\\[\\n\\\\forall (a \\\\ b : \\\\text{Point}) \\\\ (AB : \\\\text{Line}), \\\\ \\\\text{distinctPointsOnLine} \\\\ a \\\\ b \\\\ AB \\\\rightarrow \\\\exists c : \\\\text{Point}, \\\\ |(c--a)| = |(a--b)| \\\\land |(c--b)| = |(a--b)|\\n\\\\]\\n\\nThe prediction which E3 is unable to prove equivalent is\\n\\n\\\\[\\n\\\\forall (a \\\\ b : \\\\text{Point}) \\\\ (AB : \\\\text{Line}), \\\\ \\\\text{distinctPointsOnLine} \\\\ a \\\\ b \\\\ AB \\\\rightarrow \\\\exists (c : \\\\text{Point}) \\\\ (AC \\\\ BC : \\\\text{Line}), \\\\ \\\\text{formTriangle} \\\\ a \\\\ b \\\\ c \\\\ AB \\\\ BC \\\\ AC \\\\land |(a--b)| = |(b--c)| \\\\land |(a--c)| = |(a--b)|\\n\\\\]\\n\\nDuring equivalence checking, E3 is unable to apply the construction rules required to form lines AC and BC.\\n\\nProposition 11, Text-based, 5-shot.\\n\\nAnother false negative came from Proposition 11, which reads:\\n\\n\u201cTo draw a straight-line at right-angles to a given straight-line from a given point on it. Let AB be the given straight-line, and C the given point on it. So it is required to draw a straight-line from the point C at right-angles to the straight-line AB.\\n\\nThus, the straight-line CF has been drawn at right-angles to the given straight-line AB from the given point C on it.\u201d\\n\\nOur ground truth formalization is as follows:\\n\\n\\\\[\\n\\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) \\\\ (AB : \\\\text{Line}), \\\\ \\\\text{distinctPointsOnLine} \\\\ a \\\\ b \\\\ AB \\\\land \\\\text{between} \\\\ a \\\\ c \\\\ b \\\\rightarrow \\\\exists f : \\\\text{Point}, \\\\ \\\\neg \\\\text{f.onLine} \\\\ AB \\\\land \\\\angle a:c:f = \\\\angle b:c:f\\n\\\\]\\n\\nThis formalization reflects the diagram in the source material, in which the point C around which the right angle is constructed indeed lies between A and B. However, the only real requirement in the formalization is to ensure that there is a right angle against line AB.\\n\\nThe prediction which is rejected by E3 is as follows:\\n\\n\\\\[\\n\\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) \\\\ (AB : \\\\text{Line}), \\\\ \\\\text{distinctPointsOnLine} \\\\ a \\\\ b \\\\ AB \\\\land c\\\\text{.onLine} \\\\ AB \\\\rightarrow \\\\exists (f : \\\\text{Point}), \\\\ \\\\angle a:c:f = \\\\angle b:c:f\\n\\\\]\\n\\nWhich captures the essence of the theorem. Both theorems are actually true, and are each reasonable formalizations of the given statement, but E3 is unable to prove their equivalence. In addition to revealing the limitations of the tool, this also reflects the difficulty in building a dataset which can anticipate all possible ways of formalizing a natural language theorem.\\n\\nE.3. False Positive\\n\\nAs mentioned in the paper, we did not encounter indications of soundness bugs in our experiment results. However, we did encounter one instance of a proposition which was proven correct by E3, despite being an \u201cincorrect\u201d formalization of the given proposition. The instance is from the UniGeo/Congruent dataset, which amounts to proving that, with respect to the diagram in Fig. B, if |T U| = |V W| and T U is parallel to V W, then the triangles formed by points T UV and T V W are congruent.\\n\\nOur ground truth formalization is as follows:\\n\\n\\\\[\\n\\\\forall (T \\\\ U \\\\ V \\\\ W : \\\\text{Point}) \\\\ (TU \\\\ UV \\\\ TV \\\\ VW \\\\ TW : \\\\text{Line}), \\\\ \\\\text{formTriangle} \\\\ T \\\\ U \\\\ V \\\\ TU \\\\ UV \\\\ TV \\\\land \\\\text{formTriangle} \\\\ T \\\\ V \\\\ W \\\\ TV \\\\ VW \\\\ TW \\\\land \\\\text{U.opposingSides} \\\\ W \\\\ TV \\\\land |(T--U)| = |(V--W)| \\\\land \\\\neg \\\\text{TU.intersectsLine} \\\\ VW \\\\rightarrow \\\\triangle T:U:V).\\\\text{congruent} (\\\\triangle V:W:T)\\n\\\\]\\n\\nOne of the predictions generated by GPT-4v is given as follows:\\n\\n\\\\[\\n1\\\\ prediction : \\\\ 37\\n\\\\]\"}"}
{"id": "bylZbZOsGA", "page_num": 38, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nFigure B. Diagrammatic input for UniGeo proof/Congruent Thm02\\n\\n\u2200 (U V W T : Point) (UV VT TW WT : Line),\\nformQuadrilateral U V W T UV VT TW WT \u2227 |(T--U)| = |(V--W)| \u2227 \u00ac (UV.intersectsLine WT) \u2192 (\u2206 T:U:V).congruent (\u2206 V:W:T)\\n\\nIn this case, the formalization does not quite line up with the text of the proposition; the statement assumes a quadrilateral rather than two triangles, and the premises refer to UV and WT being parallel rather than TU and VW, despite still assuming TU = VW. Of course, the statement is still true, and in fact E3 is able to prove they are equivalent; however, this is not quite a \\\"faithful\\\" formalization of the text.\\n\\nE.4. Unsatisfiable Statements\\n\\nE3 did not identify any unsatisfiable predictions during our final rounds of experiments, but we did encounter a few such cases during preliminary experiments and testing; we include them here for the interested reader, as well as to emphasize the importance of rigorous semantic validation.\\n\\nProposition 11, GPT-4, 5-shot.\\nConsider the following:\\nprediction: \u2200 (a b c : Point) (AB : Line), c.onLine AB \u2192 \u2203 (CF : Line), c.onLine CF \u2227 \u00ac (AB.intersectsLine CF) \u2227 \u2220a:c:b =\\nE3 correctly identifies this proposition as unsatisfiable, since, if c is on CF and c is on AB, then obviously these lines must intersect.\\n\\nProposition 46, GPT-4, 5-shot.\\nConsider the following:\\nprediction: \u2200 (a b : Point) (AB : Line), distinctPointsOnLine a b AB \u2192 \u2203 (c d : Point) (AC BD : Line), formQuadrilateral a d c b AB BD AC BD \u2227 |(a-- b)| = |(b-- c)| \u2227 |(c-- d)| = |(d-- a)| \u2227 \u2220a:b:c = \u2220b:c:d = \u2220c:d:a = \u2220d:a:b =\\nE3 correctly identifies this proposition as unsatisfiable. The cause is that, in the application of formQuadrilateral, the line BD is given as an argument twice. However, formQuadrilateral requires that all its inputs are distinct objects.\\n\\nProposition 48, GPT-4, 5-shot.\\nConsider the following prediction, which is stating the converse direction of the Pythagorean theorem:\\nprediction: \u2200 (a b c : Point) (AB AC BC : Line), formTriangle a b c AB AC BC \u2227 |(b--c)| * |(b--c)| = |(a--b)| * |(a--b)| + |(a--c)| * |(a--c)| \u2192 \u2220a:b:c =\\nObviously, if |BC|^2 = |AB|^2 + |AC|^2, then BC must be the hypotenuse of the triangle, so the right angle cannot be around point B. E3 is able to identify this impossibility.\"}"}
{"id": "bylZbZOsGA", "page_num": 39, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"E.5. The Approximate Logical Equivalence Procedure\\n\\nAs shown in Fig. 3, the approximate equivalence checker attempts to quantify how \\\"semantically close\\\" one theorem statement is to another. The intention is to allow us to distinguish \\\"close\\\" formalizations from \\\"junk\\\" ones. We provide a more detailed description of how this procedure works.\\n\\nWe assume we are given a ground truth formula \\\\( T_{gt} \\\\) and a prediction \\\\( T_{pred} \\\\) such that the two formulas agree on the quantity and types of their bound variables. The goal is to find a unification \\\\( \\\\rho \\\\) between bound variables in \\\\( T_{pred} \\\\) and \\\\( T_{gt} \\\\) with which we can prove the equivalence of the preconditions and postconditions of the two formulae. Obviously, the number of potential unifications is factorial in the number of variables, so we fix some upper bound \\\\( n \\\\) on the number of unifications we consider, and rank candidates using a string similarity heuristic.\\n\\nHaving fixed a unification \\\\( \\\\rho \\\\) of variables in \\\\( T_{pred} \\\\) with variables in \\\\( T_{gt} \\\\), let \\\\( T'_{pred} \\\\) be the result of renaming the variables in \\\\( T_{pred} \\\\) with variables in \\\\( T_{gt} \\\\) according to \\\\( \\\\rho \\\\). Assuming \\\\( T'_{pred} \\\\) and \\\\( T_{gt} \\\\) are both well-formed statements in E, we can extract the sets \\\\( \\\\{ p_i \\\\} \\\\) and \\\\( \\\\{ q_i \\\\} \\\\) containing the pre/post-conditions of \\\\( T_{gt} \\\\), respectively, and likewise the set \\\\( \\\\{ r_i \\\\} \\\\) and \\\\( \\\\{ s_i \\\\} \\\\) containing the pre/postconditions of \\\\( T'_{pred} \\\\). We then perform a four-step process:\\n\\n1. Assuming \\\\( V_i p_i \\\\), try to prove each \\\\( r_j \\\\).\\n2. Assuming \\\\( V_i r_i \\\\), try to prove each \\\\( p_j \\\\).\\n3. Assuming \\\\( V_i q_i \\\\), try to prove each \\\\( s_j \\\\).\\n4. Assuming \\\\( V_i s_i \\\\), try to prove each \\\\( q_j \\\\).\\n\\nIf steps (1) and (2) are both successful (meaning that the preconditions of the formulae were proven equivalent), then the preconditions are included as additional assumptions for steps (3) and (4). For each step, \\\\( E_3 \\\\) records how many obligations were able to be proved. The results are then aggregated for each of the \\\\( n \\\\) unifications of bound variables, which can then be evaluated by any number of metrics. For instance, Fig. 3 compares the formalization instances using the ratio of clauses solved across steps (1)\u2013(4).\\n\\nF. Proof Autoformalization\\n\\nF.1. Quantitative Results\\n\\nAs mentioned in the paper, only two proofs from Elements were able to be formalized correctly out-of-the-box. For the remaining 43 proofs, we wished to quantify how \\\"good\\\" the proofs are by computing the degree of modification introduced during the repair process, as measured by the Levenshtein ratio. The results of this process for the (incomplete) proofs autoformalized by GPT-4 and GPT-4V are shown in Fig. C and Fig. D, respectively. Obviously, this is not a perfect metric \u2013 for instance, a tactic invoking proposition 6 may only differ in a single character with one invoking proposition 7.\\n\\nHowever, we find that these kinds of major conceptual errors, where the model chooses an entirely irrelevant theorem or rule, are quite rare. The majority of modifications necessary to repair proofs (as shown by the exemplars below) are simply rearranging arguments to tactics or modifying one variant of a theorem for another (e.g., proposition 9 versus the variant proposition 9').\\n\\nF.2. Correctly Formalized Proofs from Elements\\n\\nThe same two proofs \u2013 Proposition 1 and Proposition 17 \u2013 were correctly formalized out-of-the-box by GPT-4 and GPT-4V. Both of these are relatively simple proofs. Nevertheless, they serve as good exemplars of how LeanEuclid's proof language supports simple, elegant and faithful formalizations of the natural language proof.\\n\\nProposition 1, GPT-4V.\\n\\nNatural language proof:\\n\\n\\\"To construct an equilateral triangle on a given finite straight-line. Let \\\\( AB \\\\) be the given finite straight-line. So it is required to construct an equilateral triangle on the straight-line \\\\( AB \\\\). Let the circle \\\\( BCD \\\\) with center \\\\( A \\\\) and radius \\\\( AB \\\\) have been drawn [Post. 3], and again let the circle \\\\( ACE \\\\) with center \\\\( B \\\\) and radius \\\\( BA \\\\) have been drawn [Post. 3]. And let the straight-lines \\\\( CA \\\\) and \\\\( CB \\\\) have been joined from the point \\\\( C \\\\), where the circles cut one another, to the points \\\\( A \\\\) and \\\\( B \\\\) (respectively) [Post. 1]. And since the point \\\\( A \\\\) is the center of the circle \\\\( CDB \\\\), \\\\( AC \\\\) is equal to \\\\( AB \\\\)[Def. 1.15]. Again, since the point \\\\( B \\\\) is the center of the circle \\\\( CAE \\\\), \\\\( BC \\\\) is equal to \\\\( BA \\\\)[Def. 1.15]. But \\\\( CA \\\\) was also shown (to be) equal to \\\\( AB \\\\).\\n\\nThus, \\\\( CA \\\\) and \\\\( CB \\\\) are each equal to \\\\( AB \\\\). But things equal to the same thing are also equal to one another [C.N. 1]. Thus, \\\\( CA \\\\) is also equal to \\\\( CB \\\\). Thus, the three (straight-lines) \\\\( CA \\\\), \\\\( AB \\\\), and \\\\( BC \\\\) are equal to one another. Thus, the triangle \\\\( ABC \\\\) is equilateral, and has been constructed on the given finite straight-line \\\\( AB \\\\). (Which is) the very thing it was required to do.\\\"\\n\\nAutoformalized proof:\"}"}
{"id": "bylZbZOsGA", "page_num": 40, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Proposition 17, GPT-4V.\\n\\nNatural language proof: \\\"For any triangle, (the sum of) two angles taken together in any (possible way) is less than two right-angles. Let $ABC$ be a triangle. I say that (the sum of) two angles of triangle $ABC$ taken together in any (possible way) is less than two right-angles. For let $BC$ have been produced to $D$. And since the angle $ACD$ is external to triangle $ABC$, it is greater than the internal and opposite angle $ABC$ [Prop. 1.16]. Let $ACB$ have been added to both. Thus, the (sum of the angles) $ACD$ and $ACB$ is greater than the (sum of the angles) $ABC$ and $BCA$. But, (the sum of) $ACD$ and $ACB$ is equal to two right-angles [Prop. 1.13]. Thus, (the sum of) $ABC$ and $BCA$ is less than two right-angles. Similarly, we can show that (the sum of) $BAC$ and $ACB$ is also less than two right-angles, and further (that the sum of) $CAB$ and $ABC$ (is less than two right-angles). Thus, for any triangle, (the sum of) two angles taken together in any (possible way) is less than two right-angles. (Which is) the very thing it was required to show.\\\"\\n\\nAutoformalized proof:\\n\\n```lean\\ntheorem prop_17_prediction :\\n  \u2200 (a b c : Point) (AB BC AC : Line), formTriangle a b c AB BC AC \u2192 (\u2220a:b:c) + (\u2220b:c:a) < 2\u03c0 :=\\nby euclid_intros\\n  euclid_apply extend_point BC b c as d\\n  euclid_apply proposition_16 a b c d AB BC AC\\n  euclid_apply proposition_13 a c b d AC BC\\n  euclid_finish\\n```\\n\"}"}
{"id": "bylZbZOsGA", "page_num": 25, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\n5. Intermediate Variables: You should never define an intermediate variable inside the proposition. For example, \u201clet X := (something);\u201d is NOT allowed.\\n\\n6. Axioms: You should only use the provided axioms. For example, Line L is parallel to line M can be expressed as \u00ac(L.intersectsLine M). Do not use Line.Parallel L M.\\n\\n7. Response Format: Present your formalized Lean expression within triple angle brackets (<<< Lean expression here >>>). Do not add any annotations/explanations, or markdown syntax.\\n\\nD.2. Proof Formalization (Elements)\\n\\nTo formalize proofs from Elements, we included (1) all inference rules that were used in our manual formalization of Elements and (2) all variations of all theorem statements that precede the target theorem. We also provided 5 hardcoded examples (Propositions 2, 6, 12, 32, 42) which were chosen to showcase a variety of proof formats and tactic invocations.\\n\\nThe token {PRECEDING THMS} is substituted at formalization time by the list of visible theorems allowed for the target proposition. For instance, when formalizing a proof of Proposition n in Elements, the model is allowed to use proofs of Propositions 1 through n \u2212 1, and all their variations.\\n\\n/- Basic Geometric Sorts /\\n\\n axiom Point : Type\\n axiom Line : Type\\n axiom Circle : Type\\n\\n/- Notations and Macros for Geometric Entities /\\n\\n\\\"|(a--b)|\\\" means the length of the line segment between point a and point b.\\n\\n\\\"\u2220a:b:c\\\" means the degree of the angle formed by points a, b, and c.\\n\\n\\\"|\\\" means the right angle.\\n\\n\\\"\u25b3a:b:c\\\" means the triangle formed from points a, b and c.\\n\\n\\\"Triangle.area \u25b3a:b:c\\\" means the area of the triangle formed by points a, b and c.\\n\\n/- Relations and Axioms for Geometric Sorts /\\n\\nnamespace Point\\n    def onLine (a : Point) (L : Line) -- point a is on line L.\\n    def sameSide (a b : Point) (L : Line) -- point a and b are on the same side of line L.\\n    def opposingSides (a b : Point) (L : Line) -- point a and b are on the opposite sides of line L.\\n    def collinear : (a b c : Point) -- points a, b and c are collinear.\\nend Point\\n\\nnamespace Line\\n    def intersectsLine (L M : Line) -- two lines L and M intersect at some point.\\n    def intersectsCircle (L : Line) (C : Circle) -- line L and circle C intersect.\\nend Line\\n\\nnamespace Circle\\n    def onCircle (a: Point) (C: Circle) -- point a is on circle C.\\n    def insideCircle (a: Point) (C: Circle) -- point a is inside circle C.\\n    def outsideCircle (a: Point) (C: Circle)-- point a is outside circle C.\\n    def isCentre (a: Point) (C: Circle) -- point a is on the center circle C.\\n    def intersectsCircle (C1 C2: Circle) -- circle C1 and C2 intersect.\\nend Circle\\n\\n-- Abbreviations --\\n\\nabbrev distinctPointsOnLine (p q : Point) (L : Line) :=\\n    P.onLine L \u2227 Q.onLine L \u2227 P \u2260 Q\\n\\nabbrev Point.opposingSides (a b : Point) (l : Line) :=\\n    \u00aca.onLine l \u2227 \u00acb.onLine l \u2227 \u00acsameSide a b l\\n\\nabbrev Point.outsideCircle (p c : Point) :=\\n    \u00acp.insideCircle c \u2227 \u00acp.onCircle c\\n\\nabbrev formTriangle (a b c : Point) (AB BC CA : Line) : Prop :=\\n    distinctPointsOnLine a b AB \u2227 b.onLine BC \u2227 c.onLine BC \u2227 c.onLine CA \u2227 a.onLine CA\"}"}
{"id": "bylZbZOsGA", "page_num": 26, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\n\\\\[ AB \\\\neq BC \\\\land BC \\\\neq CA \\\\land CA \\\\neq AB \\\\]\\n\\nabbrev formRectilinearAngle (a b c : Point) (AB BC : Line) :=\\ndistinctPointsOnLine a b AB \\\\land distinctPointsOnLine b c BC\\n\\nabbrev formParallelogram (a b c d : Point) (AB CD AC BD : Line) :=\\na.onLine AB \\\\land b.onLine AB \\\\land c.onLine CD \\\\land d.onLine CD \\\\land a.onLine AC \\\\land c.onLine AC \\\\land distinctPointsOnLine b d BD \\\\land a.sameSide c BD \\\\land \\\\neg (AB.intersectsLine CD) \\\\land \\\\neg (AC.intersectsLine BD)\\n\\nYour proofs can make use of the following construction rules and inference rules:\\n\\n**Construction Rules:**\\n\\n- **Points**\\n  - axiom distinct_points : \\\\( \\\\forall p : \\\\text{Point}, \\\\exists q : \\\\text{Point}, p \\\\neq q \\\\)\\n  - axiom line_nonempty : \\\\( \\\\forall l : \\\\text{Line}, \\\\exists p : \\\\text{Point}, p.\\\\text{onLine} l \\\\)\\n  - axiom exists_distincts_points_on_line : \\\\( \\\\forall l : \\\\text{Line}, \\\\forall p : \\\\text{Point}, \\\\exists p' : \\\\text{Point}, p \\\\neq p' \\\\land p'.\\\\text{onLine} l \\\\)\\n  - axiom exists_point_between_points_on_line : \\\\( \\\\forall (L : \\\\text{Line}) (b c : \\\\text{Point}), \\\\text{distinctPointsOnLine} b c L \\\\rightarrow \\\\exists a : \\\\text{Point}, (a.\\\\text{onLine} L) \\\\land (\\\\text{between} b a c) \\\\)\\n  - axiom point_between_points_shorter_than : \\\\( \\\\forall (L : \\\\text{Line}) (b c : \\\\text{Point}) (s : \\\\text{Segment}), \\\\text{distinctPointsOnLine} b c L \\\\land |s| > 0 \\\\rightarrow \\\\exists a : \\\\text{Point}, (a.\\\\text{onLine} L) \\\\land (\\\\text{between} b a c) \\\\land (|b--a| < s) \\\\)\\n  - axiom extend_point : \\\\( \\\\forall (L : \\\\text{Line}) (b c : \\\\text{Point}), \\\\text{distinctPointsOnLine} b c L \\\\rightarrow \\\\exists a : \\\\text{Point}, (a.\\\\text{onLine} L) \\\\land (\\\\text{between} b c a) \\\\)\\n  - axiom extend_point_not_on_line : \\\\( \\\\forall (L M : \\\\text{Line}) (b c : \\\\text{Point}), \\\\text{distinctPointsOnLine} b c L \\\\land L \\\\neq M \\\\rightarrow \\\\exists a : \\\\text{Point}, (a.\\\\text{onLine} L) \\\\land (\\\\text{between} b c a) \\\\land \\\\neg (a.\\\\text{onLine} M) \\\\)\\n  - axiom extend_point_longer : \\\\( \\\\forall (L : \\\\text{Line}) (b c : \\\\text{Point}) (s : \\\\text{Segment}), \\\\text{distinctPointsOnLine} b c L \\\\rightarrow \\\\exists a : \\\\text{Point}, (a.\\\\text{onLine} L) \\\\land (\\\\text{between} b c a) \\\\land (|c--a| > s) \\\\)\\n  - axiom point_on_line_same_side : \\\\( \\\\forall (L M : \\\\text{Line}) (b : \\\\text{Point}), \\\\neg (b.\\\\text{onLine} L) \\\\land L.\\\\text{intersectsLine} M \\\\rightarrow \\\\exists a : \\\\text{Point}, a.\\\\text{onLine} M \\\\land a.\\\\text{sameSide} b L \\\\)\\n  - axiom exists_point_opposite : \\\\( \\\\forall (L : \\\\text{Line}) (b : \\\\text{Point}), \\\\neg (b.\\\\text{onLine} L) \\\\rightarrow \\\\exists a : \\\\text{Point}, a.\\\\text{opposingSides} b L \\\\)\\n\\n- **Lines and Circles**\\n  - axiom line_from_points : \\\\( \\\\forall (a b : \\\\text{Point}), a \\\\neq b \\\\rightarrow \\\\exists L : \\\\text{Line}, (a.\\\\text{onLine} L) \\\\land (b.\\\\text{onLine} L) \\\\)\\n  - axiom circle_from_points : \\\\( \\\\forall (a b : \\\\text{Point}), a \\\\neq b \\\\rightarrow \\\\exists \\\\alpha : \\\\text{Circle}, (a.\\\\text{isCentre} \\\\alpha) \\\\land (b.\\\\text{onCircle} \\\\alpha) \\\\)\\n\\n- **Intersections**\\n  - axiom intersection_lines : \\\\( \\\\forall (L M : \\\\text{Line}), L.\\\\text{intersectsLine} M \\\\rightarrow \\\\exists a : \\\\text{Point}, (a.\\\\text{onLine} L) \\\\land (a.\\\\text{onLine} M) \\\\)\\n  - axiom intersection_circle_line : \\\\( \\\\forall (\\\\alpha : \\\\text{Circle}) (L : \\\\text{Line}), L.\\\\text{intersectsCircle} \\\\alpha \\\\rightarrow \\\\exists a : \\\\text{Point}, (a.\\\\text{onCircle} \\\\alpha) \\\\land (a.\\\\text{onLine} L) \\\\)\\n  - axiom intersections_circle_line : \\\\( \\\\forall (\\\\alpha : \\\\text{Circle}) (L : \\\\text{Line}), L.\\\\text{intersectsCircle} \\\\alpha \\\\rightarrow \\\\exists (a b : \\\\text{Point}), (a.\\\\text{onCircle} \\\\alpha) \\\\land (a.\\\\text{onLine} L) \\\\land (b.\\\\text{onCircle} \\\\alpha) \\\\land (b.\\\\text{onLine} L) \\\\land a \\\\neq b \\\\)\\n  - axiom intersection_circle_line_between_points : \\\\( \\\\forall (\\\\alpha : \\\\text{Circle}) (L : \\\\text{Line}) (b c : \\\\text{Point}), (b.\\\\text{insideCircle} \\\\alpha) \\\\land (b.\\\\text{onLine} L) \\\\land (c.\\\\text{outsideCircle} \\\\alpha) \\\\land (c.\\\\text{onLine} L) \\\\rightarrow \\\\exists a : \\\\text{Point}, (a.\\\\text{onCircle} \\\\alpha) \\\\land (a.\\\\text{onLine} L) \\\\land (\\\\text{between} b a c) \\\\)\\n  - axiom intersection_circle_line_extending_points : \\\\( \\\\forall (\\\\alpha : \\\\text{Circle}) (L : \\\\text{Line}) (b c : \\\\text{Point}), (b.\\\\text{insideCircle} \\\\alpha) \\\\land \\\\text{distinctPointsOnLine} b c L \\\\rightarrow \\\\exists a : \\\\text{Point}, (a.\\\\text{onCircle} \\\\alpha) \\\\land (a.\\\\text{onLine} L) \\\\land (\\\\text{between} a b c) \\\\)\\n  - axiom intersection_circles : \\\\( \\\\forall (\\\\alpha \\\\beta : \\\\text{Circle}), \\\\alpha.\\\\text{intersectsCircle} \\\\beta \\\\rightarrow \\\\exists a : \\\\text{Point}, (a.\\\\text{onCircle} \\\\alpha) \\\\land (a.\\\\text{onCircle} \\\\beta) \\\\)\\n  - axiom intersection_same_side : \\\\( \\\\forall (\\\\alpha \\\\beta : \\\\text{Circle}) (b c d : \\\\text{Point}) (L : \\\\text{Line}), (\\\\alpha.\\\\text{intersectsCircle} \\\\beta) \\\\land (c.\\\\text{isCentre} \\\\alpha) \\\\land (d.\\\\text{isCentre} \\\\beta) \\\\land (c.\\\\text{onLine} L) \\\\land (d.\\\\text{onLine} L) \\\\land \\\\neg (b.\\\\text{onLine} L) \\\\rightarrow \\\\exists a : \\\\text{Point}, (a.\\\\text{onCircle} \\\\alpha) \\\\land (a.\\\\text{onCircle} \\\\beta) \\\\land (a.\\\\text{sameSide} b L) \\\\)\\n  - axiom intersection_opposite_side : \\\\( \\\\forall (\\\\alpha \\\\beta : \\\\text{Circle}) (b c d : \\\\text{Point}) (L : \\\\text{Line}), (\\\\alpha.\\\\text{intersectsCircle} \\\\beta) \\\\land (c.\\\\text{isCentre} \\\\alpha) \\\\land (d.\\\\text{isCentre} \\\\beta) \\\\land (c.\\\\text{onLine} L) \\\\land (d.\\\\text{onLine} L) \\\\land \\\\neg (b.\\\\text{onLine} L) \\\\rightarrow \\\\exists a : \\\\text{Point}, (a.\\\\text{onCircle} \\\\alpha) \\\\land (a.\\\\text{onCircle} \\\\beta) \\\\land a.\\\\text{opposingSides} b L \\\\)\\n\\n--- Inference Rules ---\\n\\n- axiom two_points_determine_line : \\\\( \\\\forall (a b : \\\\text{Point}) (L M : \\\\text{Line}), \\\\text{distinctPointsOnLine} a b L \\\\land a.\\\\text{onLine} M \\\\land b.\\\\text{onLine} M \\\\rightarrow L = M \\\\)\\n- axiom superposition : \\\\( \\\\forall (a b c d g h : \\\\text{Point}) (AB BC AC L : \\\\text{Line}), \\\\text{formTriangle} a b c AB BC AC \\\\land \\\\text{distinctPointsOnLine} d g L \\\\land \\\\neg (h.\\\\text{onLine} L) \\\\rightarrow \\\\exists (b' c' : \\\\text{Point}) (BC' AC' : \\\\text{Line}), (\\\\angle b:a:c) = (\\\\angle b':d:c') \\\\land (\\\\angle a:c:b) = (\\\\angle d:c':b') \\\\land (\\\\angle c:b:a) = (\\\\angle c':b':d) \\\\land |a--b| = |d--b'| \\\\land |b--c| = |b'--c'| \\\\land |c--a| = |c'--d| \\\\land b'.\\\\text{onLine} L \\\\land \\\\neg (\\\\text{between} b' d g) \\\\land c'.\\\\text{sameSide} h L \\\\land \\\\text{distinctPointsOnLine} b' c' BC' \\\\land 26 \\\\)\"}"}
{"id": "bylZbZOsGA", "page_num": 27, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\ndistinctPointsOnLine d c' AC'\\n\\naxiom between_if :\\n\u2200 (a b c : Point),between a b c \u2192 |(a--b)| + |(b--c)| = |(a--c)|\\n\\naxiom equal_circles :\\n\u2200 (a b c : Point) (\u03b1 \u03b2 : Circle), (a.isCentre \u03b1) \u2227 (a.isCentre \u03b2) \u2227 (b.onCircle \u03b1) \u2227 (c.onCircle \u03b2) \u2227 |(a--b)| = |(a--c)| \u2192 \u03b1 = \u03b2\\n\\naxiom point_on_circle_if :\\n\u2200 (a b c : Point) (\u03b1 : Circle), (a.isCentre \u03b1) \u2227 (b.onCircle \u03b1) \u2227 |(a--c)| = |(a--b)| \u2192 c.onCircle \u03b1\\n\\naxiom point_on_circle_onlyif :\\n\u2200 (a b c : Point) (\u03b1 : Circle), (a.isCentre \u03b1) \u2227 (b.onCircle \u03b1) \u2227 (c.onCircle \u03b1) \u2192 |(a--c)| = |(a--b)|\\n\\naxiom point_in_circle_if :\\n\u2200 (a b c : Point) (\u03b1 : Circle), (a.isCentre \u03b1) \u2227 (b.onCircle \u03b1) \u2227 (a--c) < (a--b) \u2192 c.insideCircle \u03b1\\n\\naxiom sum_angles_if :\\n\u2200 (a b c d : Point) (L M : Line), (a.onLine L) \u2227 (a.onLine M) \u2227 (b.onLine L) \u2227 (c.onLine M) \u2227 (a \u2260 b) \u2227 (a \u2260 c) \u2227 \u00ac (d.onLine L) \u2227 \u00ac (d.onLine M) \u2227 (L \u2260 M) \u2227 (\u2220 b:a:c) = (\u2220 b:a:d) + (\u2220 d:a:c) \u2192 (b.sameSide d M) \u2227 (c.sameSide d L)\\n\\naxiom sum_angles_onlyif :\\n\u2200 (a b c d : Point) (L M : Line), (a.onLine L) \u2227 (a.onLine M) \u2227 (b.onLine L) \u2227 (c.onLine M) \u2227 (a \u2260 b) \u2227 (a \u2260 c) \u2227 (d.onLine L) \u2227 \u00ac (d.onLine M) \u2227 (L \u2260 M) \u2227 (b.sameSide d M) \u2227 (c.sameSide d L) \u2192 (\u2220 b:a:c) = (\u2220 b:a:d) + (\u2220 d:a:c)\\n\\naxiom perpendicular_if :\\n\u2200 (a b c d : Point) (L : Line), (a.onLine L) \u2227 (b.onLine L) \u2227 (between a c b) \u2227 \u00ac (d.onLine L) \u2227 (\u2220 a:c:d = \u2220 d:c:b) \u2192 (\u2220 a:c:d)\\n\\naxiom sum_areas_if :\\n\u2200 (a b c d : Point) (L : Line), (a.onLine L) \u2227 (b.onLine L) \u2227 (c.onLine L) \u2227 (a \u2260 b) \u2227 (a \u2260 c) \u2227 (b \u2260 c) \u2227 \u00ac (d.onLine L) \u2227 (between a c b) \u2192 (Triangle.area \u25b3 a:c:d) + (Triangle.area \u25b3 d:c:b) = (Triangle.area \u25b3 a:d:b)\\n\\naxiom rectangle : (a b c d : Point) (AB CD AC BD : Line), formParallelogram a b c d AB CD AC BD \u2227 (\u2220 a:c:d = 0) \u2192 (Triangle.area \u25b3 a:c:d + Triangle.area \u25b3 a:b:d = |(a--b)| * |(a--c)|) \u2227 (Triangle.area \u25b3 b:a:c + Triangle.area \u25b3 b:d:c) = |(a--b)| * |(a--c)|\\n\\n--- Proof DSL ---\\n\\nYour response must be a tactic proof in the LeanEuclid proof DSL. This DSL is built from the following tactics (arguments shown in angle-brackets <>):\\n\\n* TACTIC: euclid_intros *\\nIntroduces universally quantified variables and premises of the current goal into the proof context. No names required.\\n\\n* TACTIC: euclid_apply <rule> <args> *\\nwhere <rule> is either a construction rule, inference rule, or other theorem. Given a rule <rule> with type of the form \u2200 (args : Types) ... P -> Q, this tactic instantiates <rule> with <args>, and attempts to prove premise P from the local proof context using an SMT solver. If successful, proposition Q is added to the proof context.\\n\\nusage examples:\\neuclid_apply between_if a b c\\neculid_apply same_side_rfl x y L\\n\\n* TACTIC: euclid_apply <rule> <args> as X *\\nGiven a rule <rule> with type of the form \u2200 (args : Types) ... P -> \u2203 x . Q(x), this tactic instantiates <rule> with <args>, and attempts to prove premise P from the local proof context using an SMT solver. If successful, object x and premise Q(x) are added to the proof context.\\n\\nusage examples:\\neuclid_apply point_same_side a L as b\\neuclid_apply line_from_points p1 p2 as M\\n\\nNOTE: You can only use 'euclid_apply <rule> <args> as <X>' if the rule produces an existential. You should not name any propositions introduced using 'euclid_apply', e.g., 'euclid_apply <rule> <args> as H1'.\\n\\nNOTE: It is very important that *all* non-propositional (i.e., universally quantified) arguments are provided to the rule when invoking 'euclid_apply'.\\n\\n* euclid_finish *\\nAttempts to resolve the proof goal using the current proof context using an SMT solver.\\n\\n* euclid_assert <P> *\\nAttempts to prove proposition <P> from the current proof context using an SMT solver. Equivalent to \\\"have : <P> := by euclid_finish\\\"\"}"}
{"id": "bylZbZOsGA", "page_num": 28, "content": "```lean\neuclid_intros\neuclid_apply (line_from_points a b) as AB\neuclidApply (proposition_1 a b AB) as d\neuclid_apply (line_from_points d a ) as AE\neuclid_apply (line_from_points d b ) as BF\neuclid_apply (circle_from_points b c) as CGH\neuclid_apply (intersection_circle_line_extending_points CGH BF b d) as g\neuclid_apply (circle_from_points d g) as GKL\neuclid_apply (intersection_circle_line_extending_points GKL AE a d) as l\neuclid_apply (point_on_circle_onlyif b c g CGH)\neuclid_apply (point_on_circle_onlyif d l g GKL)\neuclid_apply (between_if l a d )\neuclid_apply (between_if g b d )\nuse l\n```"}
{"id": "bylZbZOsGA", "page_num": 13, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"A.3. Axioms\\n\\nAxioms in E fall into five categories: construction rules, diagrammatic rules, metric rules, transfer rules, and superposition rules (the last four categories are collectively referred to as \\\"non-construction rules\\\" in this paper). Avigad et al. (2009) has proved E's axioms to be sound and complete through a bi-directional translation between E and Tarski's axioms (Schwabh\u00e4user et al., 2013). E's axioms may have redundancy, as Avigad et al. (2009) did not attempt to minimize the number of axioms.\\n\\nConstruction Rules.\\n\\nWe have 32 construction rules. Among them, two rules are not from E's paper but convenient for formalizing some proofs:\\n\\n- Point between points\\n- Point on line same side\\n\\nOne rule is stronger than its original version:\\n\\n- Point on line shorter than\\n\\nArbitrary point:\\n\\n\\\\[ \\\\exists a : \\\\text{Point}, \\\\text{true} \\\\]\\n\\nDistinct points:\\n\\n\\\\[ \\\\forall a : \\\\text{Point}, \\\\exists b : \\\\text{Point}, a \\\\neq b \\\\]\\n\\nLine nonempty:\\n\\n\\\\[ \\\\forall l : \\\\text{Line}, \\\\exists p : \\\\text{Point}, \\\\text{onLine } p l \\\\]\\n\\nExists distinct points on line:\\n\\n\\\\[ \\\\forall l : \\\\text{Line}, \\\\forall a : \\\\text{Point}, \\\\exists b : \\\\text{Point}, a \\\\neq b \\\\land \\\\text{onLine } b l \\\\]\\n\\nExists point between points on line:\\n\\n\\\\[ \\\\forall (L : \\\\text{Line}) (b \\\\ c : \\\\text{Point}), \\\\text{distinctPointsOnLine } b c L \\\\rightarrow \\\\exists a : \\\\text{Point}, (\\\\text{onLine } a L) \\\\land (\\\\text{between } b a c) \\\\]\\n\\nExists point between points not on line:\\n\\n\\\\[ \\\\forall (L \\\\ M : \\\\text{Line}) (b \\\\ c : \\\\text{Point}), (\\\\text{distinctPointsOnLine } b c L) \\\\land L \\\\neq M \\\\rightarrow \\\\exists a : \\\\text{Point}, (\\\\text{onLine } a L) \\\\land (\\\\text{between } b a c) \\\\land \\\\neg (\\\\text{onLine } a M) \\\\]\\n\\nPoint between points shorter than:\\n\\n\\\\[ \\\\forall (L : \\\\text{Line}) (b \\\\ c : \\\\text{Point}) (s : \\\\text{Segment}), \\\\text{distinctPointsOnLine } b c L \\\\land (|s| > 0) \\\\rightarrow \\\\exists a : \\\\text{Point}, (\\\\text{onLine } a L) \\\\land (\\\\text{between } b a c) \\\\land (|b--a| < |s|) \\\\]\\n\\nExtend point:\\n\\n\\\\[ \\\\forall (L : \\\\text{Line}) (b \\\\ c : \\\\text{Point}), \\\\text{distinctPointsOnLine } b c L \\\\rightarrow \\\\exists a : \\\\text{Point}, (\\\\text{onLine } a L) \\\\land (\\\\text{between } b c a) \\\\]\\n\\nExtend point not on line:\\n\\n\\\\[ \\\\forall (L \\\\ M : \\\\text{Line}) (b \\\\ c : \\\\text{Point}), (\\\\text{distinctPointsOnLine } b c L) \\\\land L \\\\neq M \\\\rightarrow \\\\exists a : \\\\text{Point}, (\\\\text{onLine } a L) \\\\land (\\\\text{between } b c a) \\\\land \\\\neg (\\\\text{onLine } a M) \\\\]\\n\\nExtend point longer:\\n\\n\\\\[ \\\\forall (L : \\\\text{Line}) (b \\\\ c : \\\\text{Point}) (s : \\\\text{Segment}), \\\\text{distinctPointsOnLine } b c L \\\\rightarrow \\\\exists a : \\\\text{Point}, (\\\\text{onLine } a L) \\\\land (\\\\text{between } b c a) \\\\land (|c--a| > |s|) \\\\]\\n\\nPoint same side:\\n\\n\\\\[ \\\\forall (L : \\\\text{Line}) (b : \\\\text{Point}), \\\\neg (\\\\text{onLine } b L) \\\\rightarrow \\\\exists a : \\\\text{Point}, (\\\\text{sameSide } a b L) \\\\]\\n\\nDistinct point same side:\\n\\n\\\\[ \\\\forall (L : \\\\text{Line}) (b \\\\ c : \\\\text{Point}), \\\\neg (\\\\text{onLine } b L) \\\\rightarrow \\\\exists a : \\\\text{Point}, a \\\\neq c \\\\land (\\\\text{sameSide } a b L) \\\\]\\n\\nPoint on line same side:\\n\\n\\\\[ \\\\forall (L \\\\ M : \\\\text{Line}) (b : \\\\text{Point}), \\\\neg (\\\\text{onLine } b L) \\\\land (\\\\text{intersectsLine } L M) \\\\rightarrow \\\\exists a : \\\\text{Point}, (\\\\text{onLine } a M) \\\\land (\\\\text{sameSide } a b L) \\\\]\\n\\nExists point opposite:\\n\\n\\\\[ \\\\forall (L : \\\\text{Line}) (b : \\\\text{Point}), \\\\neg (\\\\text{onLine } b L) \\\\rightarrow \\\\exists a : \\\\text{Point}, (\\\\text{opposingSides } a b L) \\\\]\\n\\nExists distinct point opposite side:\\n\\n\\\\[ \\\\forall (L : \\\\text{Line}) (b \\\\ c : \\\\text{Point}), \\\\neg (\\\\text{onLine } b L) \\\\rightarrow \\\\exists a : \\\\text{Point}, a \\\\neq c \\\\land (\\\\text{opposingSides } a b L) \\\\]\\n\\nExists point on circle:\\n\\n\\\\[ \\\\forall (\\\\alpha : \\\\text{Circle}), \\\\exists a : \\\\text{Point}, \\\\text{onCircle } a \\\\alpha \\\\]\\n\\nExists distinct point on circle:\\n\\n\\\\[ \\\\forall (\\\\alpha : \\\\text{Circle}) (b : \\\\text{Point}), \\\\exists a : \\\\text{Point}, a \\\\neq b \\\\land (\\\\text{onCircle } a \\\\alpha) \\\\]\\n\\nExists point inside circle:\\n\\n\\\\[ \\\\forall (\\\\alpha : \\\\text{Circle}), \\\\exists a : \\\\text{Point}, \\\\text{insideCircle } a \\\\alpha \\\\]\\n\\nExists distinct point inside circle:\\n\\n\\\\[ \\\\forall (\\\\alpha : \\\\text{Circle}) (b : \\\\text{Point}), \\\\exists a : \\\\text{Point}, a \\\\neq b \\\\land (\\\\text{insideCircle } a \\\\alpha) \\\\]\"}"}
{"id": "bylZbZOsGA", "page_num": 14, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\nexists_point_outside_circle : \u2200 (\u03b1 : Circle), \u2203 a : Point, outsideCircle a \u03b1\\n\\nexists_distinct_point_outside_circle : \u2200 (\u03b1 : Circle) (b : Point), \u2203 a : Point, a \u2260 b \u2227 (outsideCircle a \u03b1)\\n\\nline_from_points : \u2200 (a b : Point), a \u2260 b \u2192 \u2203 L : Line, (onLine a L) \u2227 (onLine b L)\\n\\ncircle_from_points : \u2200 (a b : Point), a \u2260 b \u2192 \u2203 \u03b1 : Circle, (isCentre c \u03b1) \u2227 (onCircle b \u03b1)\\n\\nintersection_lines : \u2200 (L M : Line), intersectsLine L M \u2192 \u2203 a : Point, (onLine a L) \u2227 (onLine a M)\\n\\nintersection_circle_line : \u2200 (\u03b1 : Circle) (L : Line), intersectsCircle L \u03b1 \u2192 \u2203 a : Point, (onCircle a \u03b1) \u2227 (onLine a L)\\n\\nintersection_circle_line_between_points : \u2200 (\u03b1 : Circle) (L : Line) (b c : Point), (insideCircle b \u03b1) \u2227 (onLine b L) \u2227 (outsideCircle c \u03b1) \u2227 (onLine c L) \u2192 \u2203 a : Point, (onCircle a \u03b1) \u2227 (onLine a L) \u2227 (between b a c)\\n\\nintersection_circle_line_extending_points : \u2200 (\u03b1 : Circle) (L : Line) (b c : Point), (insideCircle b \u03b1) \u2227 (distinctPointsOnLine b c L) \u2192 \u2203 a : Point, (onCircle a \u03b1) \u2227 (onLine a L) \u2227 (between a b c)\\n\\nintersection_circles : \u2200 (\u03b1 \u03b2 : Circle), intersectsCircle \u03b1 \u03b2 \u2192 \u2203 a : Point, (onCircle a \u03b1) \u2227 (onCircle a \u03b2)\\n\\nintersections_circles : \u2200 (\u03b1 \u03b2 : Circle), intersectsCircle \u03b1 \u03b2 \u2192 \u2203 (a b : Point), (onCircle a \u03b1) \u2227 (onCircle a \u03b2) \u2227 (onCircle b \u03b1) \u2227 (onCircle b \u03b2) \u2227 a \u2260 b\\n\\nintersection_same_side : \u2200 (\u03b1 \u03b2 : Circle) (b c d : Point) (L : Line), (intersectsCircle \u03b1 \u03b2) \u2227 (isCentre c \u03b1) \u2227 (isCentre d \u03b2) \u2227 (onLine c L) \u2227 (onLine d L) \u2227 \u00ac (onLine b L) \u2192 \u2203 a : Point, (onCircle a \u03b1) \u2227 (onCircle a \u03b2) \u2227 (sameSide a b L)\\n\\nintersection_opposite_side : \u2200 (\u03b1 \u03b2 : Circle) (b c d : Point) (L : Line), (intersectsCircle \u03b1 \u03b2) \u2227 (isCentre c \u03b1) \u2227 (isCentre d \u03b2) \u2227 (onLine c L) \u2227 (onLine d L) \u2227 \u00ac (onLine b L) \u2192 \u2203 a : Point, (onCircle a \u03b1) \u2227 (onCircle a \u03b2) \u2227 (opposingSides a b L)\\n\\nDiagrammatic Rules.\\n\\nWe have 36 diagrammatic rules for deducing diagrammatic facts, i.e., relations among objects. They include four rules not in E's paper: intersection lines common point, parallel line unique, and intersection symm, and parallelogram same side.\\n\\ntwo_points_determine_line : \u2200 (a b : Point) (L M : Line), distinctPointsOnLine a b L \u2227 (onLine a M) \u2227 (onLine b M) \u2192 L = M\\n\\ncentre_unique : \u2200 (a b : Point) (\u03b1 : Circle), (isCentre c \u03b1) \u2227 (isCentre b \u03b1) \u2192 a = b\\n\\ncenter_inside_circle : \u2200 (a : Point) (\u03b1 : Circle), isCentre c \u03b1 \u2192 insideCircle a \u03b1\\n\\ninside_not_on_circle : \u2200 (a : Point) (\u03b1 : Circle), insideCircle a \u03b1 \u2192 \u00ac (onCircle a \u03b1)\\n\\nbetween_symm : \u2200 (a b c : Point), between a b c \u2192 (between c b a) \u2227 (a \u2260 b) \u2227 (a \u2260 c) \u2227 (not between b a c)\\n\\nbetween_same_line_out : \u2200 (a b c : Point) (L : Line), (between a b c) \u2227 (onLine a L) \u2227 (onLine b L) \u2192 onLine c L\\n\\nbetween_same_line_in : \u2200 (a b c : Point) (L : Line), (between a b c) \u2227 (onLine a L) \u2227 (onLine c L) \u2192 onLine b L\"}"}
{"id": "bylZbZOsGA", "page_num": 15, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"\\\\[\\n\\\\begin{align*}\\n\\\\text{between\\\\_trans\\\\_in} & : \\\\forall (a \\\\ b \\\\ c \\\\ d : \\\\text{Point}), (\\\\text{between} \\\\ a \\\\ b \\\\ c) \\\\land (\\\\text{between} \\\\ a \\\\ d \\\\ b) \\\\rightarrow \\\\text{between} \\\\ a \\\\ d \\\\ c \\\\\\\\\\n\\\\text{between\\\\_trans\\\\_out} & : \\\\forall (a \\\\ b \\\\ c \\\\ d : \\\\text{Point}), (\\\\text{between} \\\\ a \\\\ b \\\\ c) \\\\land (\\\\text{between} \\\\ b \\\\ c \\\\ d) \\\\rightarrow \\\\text{between} \\\\ a \\\\ b \\\\ d \\\\\\\\\\n\\\\text{between\\\\_points} & : \\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) (L : \\\\text{Line}), (a \\\\neq b) \\\\land (b \\\\neq c) \\\\land (c \\\\neq a) \\\\land (\\\\text{onLine} \\\\ a \\\\ L) \\\\land (\\\\text{onLine} \\\\ b \\\\ L) \\\\land (\\\\text{onLine} \\\\ c \\\\ L) \\\\rightarrow (\\\\text{between} \\\\ a \\\\ b \\\\ c) \\\\lor (\\\\text{between} \\\\ b \\\\ a \\\\ c) \\\\lor (\\\\text{between} \\\\ a \\\\ c \\\\ b) \\\\\\\\\\n\\\\text{between\\\\_not\\\\_trans} & : \\\\forall (a \\\\ b \\\\ c \\\\ d : \\\\text{Point}), (\\\\text{between} \\\\ a \\\\ b \\\\ c) \\\\land (\\\\text{between} \\\\ a \\\\ b \\\\ d) \\\\rightarrow \\\\neg (\\\\text{between} \\\\ c \\\\ b \\\\ d) \\\\\\\\\\n\\\\text{same\\\\_side\\\\_rfl} & : \\\\forall (a : \\\\text{Point}) (L : \\\\text{Line}), \\\\neg (\\\\text{onLine} \\\\ a \\\\ L) \\\\rightarrow \\\\text{same\\\\_side} \\\\ a \\\\ a \\\\ L \\\\\\\\\\n\\\\text{same\\\\_side\\\\_symm} & : \\\\forall (a \\\\ b : \\\\text{Point}) (L : \\\\text{Line}), \\\\text{same\\\\_side} \\\\ a \\\\ b \\\\ L \\\\rightarrow \\\\text{same\\\\_side} \\\\ b \\\\ a \\\\ L \\\\\\\\\\n\\\\text{same\\\\_side\\\\_not\\\\_on\\\\_line} & : \\\\forall (a \\\\ b : \\\\text{Point}) (L : \\\\text{Line}), \\\\text{same\\\\_side} \\\\ a \\\\ b \\\\ L \\\\rightarrow \\\\neg (\\\\text{onLine} \\\\ a \\\\ L) \\\\\\\\\\n\\\\text{same\\\\_side\\\\_trans} & : \\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) (L : \\\\text{Line}), (\\\\text{same\\\\_side} \\\\ a \\\\ b \\\\ L) \\\\land (\\\\text{same\\\\_side} \\\\ a \\\\ c \\\\ L) \\\\rightarrow \\\\text{same\\\\_side} \\\\ b \\\\ c \\\\ L \\\\\\\\\\n\\\\text{same\\\\_side\\\\_pigeon\\\\_hole} & : \\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) (L : \\\\text{Line}), \\\\neg (\\\\text{onLine} \\\\ a \\\\ L) \\\\land \\\\neg (\\\\text{onLine} \\\\ b \\\\ L) \\\\land \\\\neg (\\\\text{onLine} \\\\ c \\\\ L) \\\\rightarrow (\\\\text{same\\\\_side} \\\\ a \\\\ b \\\\ L) \\\\lor (\\\\text{same\\\\_side} \\\\ a \\\\ c \\\\ L) \\\\lor (\\\\text{same\\\\_side} \\\\ b \\\\ c \\\\ L) \\\\\\\\\\n\\\\text{pasch\\\\_1} & : \\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) (L : \\\\text{Line}), (\\\\text{between} \\\\ a \\\\ b \\\\ c) \\\\land (\\\\text{same\\\\_side} \\\\ a \\\\ c \\\\ L) \\\\rightarrow \\\\text{same\\\\_side} \\\\ a \\\\ b \\\\ L \\\\\\\\\\n\\\\text{pasch\\\\_2} & : \\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) (L : \\\\text{Line}), (\\\\text{between} \\\\ a \\\\ b \\\\ c) \\\\land (\\\\text{onLine} \\\\ a \\\\ L) \\\\land \\\\neg (\\\\text{onLine} \\\\ b \\\\ L) \\\\rightarrow \\\\text{same\\\\_side} \\\\ b \\\\ c \\\\ L \\\\\\\\\\n\\\\text{pasch\\\\_3} & : \\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) (L : \\\\text{Line}), (\\\\text{between} \\\\ a \\\\ b \\\\ c) \\\\land (\\\\text{onLine} \\\\ b \\\\ L) \\\\rightarrow \\\\neg (\\\\text{same\\\\_side} \\\\ a \\\\ c \\\\ L) \\\\\\\\\\n\\\\text{pasch\\\\_4} & : \\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) (L \\\\ M : \\\\text{Line}), (L \\\\neq M) \\\\land (\\\\text{onLine} \\\\ b \\\\ L) \\\\land (\\\\text{onLine} \\\\ b \\\\ M) \\\\land (\\\\text{distinctPointsOnLine} \\\\ a \\\\ c \\\\ M) \\\\land (a \\\\neq b) \\\\land (c \\\\neq b) \\\\land \\\\neg (\\\\text{same\\\\_side} \\\\ a \\\\ c \\\\ L) \\\\rightarrow \\\\text{between} \\\\ a \\\\ b \\\\ c \\\\\\\\\\n\\\\text{triple\\\\_incidence\\\\_1} & : \\\\forall (L \\\\ M \\\\ N : \\\\text{Line}) (a \\\\ b \\\\ c \\\\ d : \\\\text{Point}), (\\\\text{onLine} \\\\ a \\\\ L) \\\\land (\\\\text{onLine} \\\\ a \\\\ M) \\\\land (\\\\text{onLine} \\\\ a \\\\ N) \\\\land (\\\\text{onLine} \\\\ b \\\\ L) \\\\land (\\\\text{onLine} \\\\ c \\\\ M) \\\\land (\\\\text{onLine} \\\\ d \\\\ N) \\\\land (\\\\text{same\\\\_side} \\\\ c \\\\ d \\\\ L) \\\\land (\\\\text{same\\\\_side} \\\\ b \\\\ c \\\\ N) \\\\rightarrow \\\\neg (\\\\text{same\\\\_side} \\\\ b \\\\ d \\\\ M) \\\\\\\\\\n\\\\text{triple\\\\_incidence\\\\_2} & : \\\\forall (L \\\\ M \\\\ N : \\\\text{Line}) (a \\\\ b \\\\ c \\\\ d : \\\\text{Point}), (\\\\text{onLine} \\\\ a \\\\ L) \\\\land (\\\\text{onLine} \\\\ a \\\\ M) \\\\land (\\\\text{onLine} \\\\ a \\\\ N) \\\\land (\\\\text{onLine} \\\\ b \\\\ L) \\\\land (\\\\text{onLine} \\\\ c \\\\ M) \\\\land (\\\\text{onLine} \\\\ d \\\\ N) \\\\land (\\\\text{same\\\\_side} \\\\ c \\\\ d \\\\ L) \\\\land \\\\neg (\\\\text{same\\\\_side} \\\\ b \\\\ d \\\\ M) \\\\land \\\\neg (\\\\text{onLine} \\\\ d \\\\ M) \\\\land (b \\\\neq a) \\\\rightarrow \\\\text{same\\\\_side} \\\\ b \\\\ c \\\\ N \\\\\\\\\\n\\\\text{triple\\\\_incidence\\\\_3} & : \\\\forall (L \\\\ M \\\\ N : \\\\text{Line}) (a \\\\ b \\\\ c \\\\ d \\\\ e : \\\\text{Point}), (\\\\text{onLine} \\\\ a \\\\ L) \\\\land (\\\\text{onLine} \\\\ a \\\\ M) \\\\land (\\\\text{onLine} \\\\ a \\\\ N) \\\\land (\\\\text{onLine} \\\\ b \\\\ L) \\\\land (\\\\text{onLine} \\\\ c \\\\ M) \\\\land (\\\\text{onLine} \\\\ d \\\\ N) \\\\land (\\\\text{same\\\\_side} \\\\ c \\\\ d \\\\ L) \\\\land (\\\\text{same\\\\_side} \\\\ b \\\\ c \\\\ N) \\\\land (\\\\text{same\\\\_side} \\\\ d \\\\ e \\\\ M) \\\\land (\\\\text{same\\\\_side} \\\\ c \\\\ e \\\\ N) \\\\rightarrow \\\\text{same\\\\_side} \\\\ c \\\\ e \\\\ L \\\\\\\\\\n\\\\text{circle\\\\_line\\\\_intersections} & : \\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) (L : \\\\text{Line}) (\\\\alpha : \\\\text{Circle}), (\\\\text{onLine} \\\\ a \\\\ L) \\\\land (\\\\text{onLine} \\\\ b \\\\ L) \\\\land (\\\\text{onLine} \\\\ c \\\\ L) \\\\land (\\\\text{insideCircle} \\\\ a \\\\ \\\\alpha) \\\\land (\\\\text{onCircle} \\\\ b \\\\ \\\\alpha) \\\\land (\\\\text{onCircle} \\\\ c \\\\ \\\\alpha) \\\\land (b \\\\neq c) \\\\rightarrow \\\\text{between} \\\\ b \\\\ a \\\\ c \\\\\\\\\\n\\\\text{circle\\\\_points\\\\_between} & : \\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) (\\\\alpha : \\\\text{Circle}), \\\\neg (\\\\text{outsideCircle} \\\\ a \\\\ \\\\alpha) \\\\land \\\\neg (\\\\text{outsideCircle} \\\\ b \\\\ \\\\alpha) \\\\land (\\\\text{between} \\\\ a \\\\ c \\\\ b) \\\\rightarrow \\\\text{insideCircle} \\\\ c \\\\ \\\\alpha \\\\\\\\\\n\\\\text{circle\\\\_points\\\\_extend} & : \\\\forall (a \\\\ b \\\\ c : \\\\text{Point}) (\\\\alpha : \\\\text{Circle}), \\\\neg (\\\\text{outsideCircle} \\\\ a \\\\ \\\\alpha) \\\\land \\\\neg (\\\\text{insideCircle} \\\\ c \\\\ \\\\alpha) \\\\land (\\\\text{between} \\\\ a \\\\ c \\\\ b) \\\\rightarrow (\\\\text{outsideCircle} \\\\ b \\\\ \\\\alpha) \\\\\\\\\\n\\\\text{circles\\\\_intersections\\\\_diff\\\\_side} & : \\\\forall (a \\\\ b \\\\ c \\\\ d : \\\\text{Point}) (\\\\alpha \\\\ \\\\beta : \\\\text{Circle}) (L : \\\\text{Line}), (\\\\alpha \\\\neq \\\\beta) \\\\land (\\\\text{onCircle} \\\\ c \\\\ \\\\alpha) \\\\land (\\\\text{onCircle} \\\\ c \\\\ \\\\beta) \\\\land (\\\\text{onCircle} \\\\ d \\\\ \\\\alpha) \\\\land (\\\\text{onCircle} \\\\ d \\\\ \\\\beta) \\\\land (c \\\\neq d) \\\\land (\\\\text{isCentre} \\\\ c \\\\ \\\\alpha) \\\\land (\\\\text{isCentre} \\\\ b \\\\ \\\\beta) \\\\land (\\\\text{onLine} \\\\ a \\\\ L) \\\\land (\\\\text{onLine} \\\\ b \\\\ L) \\\\rightarrow \\\\neg (\\\\text{same\\\\_side} \\\\ c \\\\ d \\\\ L) \\\\\\\\\\n\\\\text{intersection\\\\_lines\\\\_opposing} & : \\\\forall (a \\\\ b : \\\\text{Point}) (L \\\\ M : \\\\text{Line}), (\\\\text{opposingSides} \\\\ a \\\\ b \\\\ L) \\\\land (\\\\text{onLine} \\\\ a \\\\ M) \\\\land (\\\\text{onLine} \\\\ b \\\\ M) \\\\rightarrow \\\\text{intersectsLine} \\\\ L \\\\ M \\\\\\\\\\n\\\\text{intersection\\\\_lines\\\\_common\\\\_point} & : \\\\forall (a : \\\\text{Point}) (L \\\\ M : \\\\text{Line}), (\\\\text{onLine} \\\\ a \\\\ L) \\\\land (\\\\text{onLine} \\\\ a \\\\ M) \\\\land (\\\\text{isOppositePoint} \\\\ a \\\\ L \\\\ M) \\\\rightarrow \\\\text{intersectsLine} \\\\ L \\\\ M \\\\\\\\\\n\\\\end{align*}\\n\\\\]\"}"}
{"id": "bylZbZOsGA", "page_num": 16, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Autoformalizing Euclidean Geometry\\n\\n\\\\[ L \\\\neq M \\\\rightarrow \\\\text{intersectsLine } L \\\\text{ } M \\\\]\\n\\nparallel_line_unique :\\\\[\\n\\\\forall (a : \\\\text{Point}) \\\\quad (L \\\\text{ } M \\\\text{ } N : \\\\text{Line}) \\\\quad \\\\neg \\\\text{onLine} \\\\text{ } a \\\\text{ } L \\\\quad \\\\land \\\\quad \\\\neg \\\\text{onLine} \\\\text{ } a \\\\text{ } M \\\\quad \\\\land \\\\quad \\\\text{onLine} \\\\text{ } a \\\\text{ } N \\\\quad \\\\land \\\\neg \\\\text{intersectsLine} \\\\text{ } L \\\\text{ } M \\\\quad \\\\land \\\\neg \\\\text{intersectsLine} \\\\text{ } L \\\\text{ } N \\\\quad \\\\rightarrow \\\\quad M = N\\n\\\\]\\n\\nintersection_symm :\\\\[\\n\\\\forall (L \\\\text{ } M : \\\\text{Line}) \\\\quad \\\\text{intersectsLine} \\\\text{ } L \\\\text{ } M \\\\quad \\\\rightarrow \\\\quad \\\\text{intersectsLine} \\\\text{ } M \\\\text{ } L\\n\\\\]\\n\\nintersection_circle_line_1:\\\\[\\n\\\\forall (a \\\\text{ } b : \\\\text{Point}) \\\\quad (\\\\alpha : \\\\text{Circle}) \\\\quad (L : \\\\text{Line}) \\\\quad \\\\neg \\\\text{outsideCircle} \\\\text{ } a \\\\text{ } \\\\alpha \\\\quad \\\\land \\\\quad \\\\neg \\\\text{outsideCircle} \\\\text{ } b \\\\text{ } \\\\alpha \\\\quad \\\\land \\\\quad \\\\text{opposingSides} \\\\text{ } a \\\\text{ } b \\\\text{ } L \\\\quad \\n\\\\rightarrow \\\\quad \\\\text{intersectsCircle} \\\\text{ } L \\\\text{ } \\\\alpha\\n\\\\]\\n\\nintersection_circle_line_2:\\\\[\\n\\\\forall (a : \\\\text{Point}) \\\\quad (\\\\alpha : \\\\text{Circle}) \\\\quad (L : \\\\text{Line}) \\\\quad \\\\neg \\\\text{outsideCircle} \\\\text{ } a \\\\text{ } \\\\alpha \\\\quad \\\\land \\\\quad \\\\text{onLine} \\\\text{ } a \\\\text{ } L \\\\quad \\\\rightarrow \\\\quad \\\\text{intersectsCircle} \\\\text{ } L \\\\text{ } \\\\alpha\\n\\\\]\\n\\nintersection_circle_circle_1:\\\\[\\n\\\\forall (a \\\\text{ } b : \\\\text{Point}) \\\\quad (\\\\alpha \\\\text{ } \\\\beta : \\\\text{Circle}) \\\\quad \\\\neg \\\\text{outsideCircle} \\\\text{ } a \\\\text{ } \\\\alpha \\\\quad \\\\land \\\\quad \\\\neg \\\\text{outsideCircle} \\\\text{ } b \\\\text{ } \\\\beta \\\\quad \\\\land \\\\quad \\\\text{insideCircle} \\\\text{ } a \\\\text{ } \\\\beta \\\\quad \\\\land \\\\quad \\\\text{outsideCircle} \\\\text{ } b \\\\text{ } \\\\beta \\\\quad \\\\rightarrow \\\\quad \\\\text{intersectsCircle} \\\\text{ } \\\\alpha \\\\text{ } \\\\beta\\n\\\\]\\n\\nintersection_circle_circle_2:\\\\[\\n\\\\forall (a \\\\text{ } b : \\\\text{Point}) \\\\quad (\\\\alpha \\\\text{ } \\\\beta : \\\\text{Circle}) \\\\quad \\\\neg \\\\text{outsideCircle} \\\\text{ } a \\\\text{ } \\\\alpha \\\\quad \\\\land \\\\quad \\\\text{onCircle} \\\\text{ } a \\\\text{ } \\\\alpha \\\\quad \\\\land \\\\quad \\\\text{insideCircle} \\\\text{ } b \\\\text{ } \\\\alpha \\\\quad \\\\land \\\\quad \\\\text{onCircle} \\\\text{ } b \\\\text{ } \\\\beta \\\\quad \\\\rightarrow \\\\quad \\\\text{intersectsCircle} \\\\text{ } \\\\alpha \\\\text{ } \\\\beta\\n\\\\]\\n\\nparallelogram_same_side :\\\\[\\n\\\\forall (a \\\\text{ } b \\\\text{ } c \\\\text{ } d : \\\\text{Point}) \\\\quad (\\\\text{AB} \\\\text{ } \\\\text{CD} \\\\text{ } \\\\text{AC} \\\\text{ } \\\\text{BD} : \\\\text{Line}) \\\\quad \\\\text{formParallelogram} \\\\text{ } a \\\\text{ } b \\\\text{ } c \\\\text{ } d \\\\text{ } \\\\text{AB} \\\\text{ } \\\\text{CD} \\\\text{ } \\\\text{AC} \\\\text{ } \\\\text{BD} \\\\quad \\\\rightarrow \\\\quad \\\\text{sameSide} \\\\text{ } b \\\\text{ } d \\\\text{ } \\\\text{AC} \\\\quad \\\\land \\\\quad \\\\text{sameSide} \\\\text{ } c \\\\text{ } d \\\\text{ } \\\\text{AB} \\\\quad \\\\land \\\\quad \\\\text{sameSide} \\\\text{ } a \\\\text{ } b \\\\text{ } \\\\text{CD}\\n\\\\]\\n\\nMetric Rules.\\n\\nWe have 11 metric rules. Unlike diagrammatic rules, metric rules deduce metric facts, e.g., about lengths, angles, and areas. In addition, since we use SMT solvers as the symbolic reasoning engine, their built-in theories on real numbers are also included implicitly as metric rules.\\n\\nzero_segment_if :\\\\[\\n\\\\forall (a \\\\text{ } b : \\\\text{Point}) \\\\quad |(a--b)| = 0 \\\\quad \\\\rightarrow \\\\quad a = b\\n\\\\]\\n\\nzero_segment_onlyif :\\\\[\\n\\\\forall (a \\\\text{ } b : \\\\text{Point}) \\\\quad a = b \\\\quad \\\\rightarrow \\\\quad |(a--b)| = 0\\n\\\\]\\n\\nsegment_gte_zero :\\\\[\\n\\\\forall (s : \\\\text{Segment}) \\\\quad 0 \\\\leq s.\\\\text{length}\\n\\\\]\\n\\nsegment_symmetric :\\\\[\\n\\\\forall (a \\\\text{ } b : \\\\text{Point}) \\\\quad |(a--b)| = |(b--a)|\\n\\\\]\\n\\nangle_symm :\\\\[\\n\\\\forall (a \\\\text{ } b \\\\text{ } c : \\\\text{Point}) \\\\quad (a \\\\neq b) \\\\quad \\\\land \\\\quad (b \\\\neq c) \\\\quad \\\\rightarrow \\\\quad (\\\\angle a:b:c = \\\\angle c:b:a)\\n\\\\]\\n\\nangle_range :\\\\[\\n\\\\forall (ang : \\\\text{Angle}) \\\\quad (0 : \\\\mathbb{R}) \\\\leq ang \\\\quad \\\\land \\\\quad ang \\\\leq \\\\pi\\n\\\\]\\n\\ndegenerated_area :\\\\[\\n\\\\forall (a \\\\text{ } b : \\\\text{Point}) \\\\quad \\\\text{Triangle}.\\\\text{area} \\\\triangle a:a:b = 0\\n\\\\]\\n\\narea_gte_zero :\\\\[\\n\\\\forall (ar : \\\\text{Triangle}) \\\\quad 0 \\\\leq \\\\text{Triangle}.\\\\text{area} \\\\ ar\\n\\\\]\\n\\narea_symm_1 :\\\\[\\n\\\\forall (a \\\\text{ } b \\\\text{ } c : \\\\text{Point}) \\\\quad \\\\text{Triangle}.\\\\text{area} (\\\\triangle a:b:c) = \\\\text{Triangle}.\\\\text{area}(\\\\triangle c:a:b)\\n\\\\]\\n\\narea_symm_2 :\\\\[\\n\\\\forall (a \\\\text{ } b \\\\text{ } c : \\\\text{Point}) \\\\quad \\\\text{Triangle}.\\\\text{area} (\\\\triangle a:b:c) = \\\\text{Triangle}.\\\\text{area}(\\\\triangle a:c:b)\\n\\\\]\\n\\narea_congruence :\\\\[\\n\\\\forall (a \\\\text{ } b \\\\text{ } c \\\\text{ } a' \\\\text{ } b' \\\\text{ } c' : \\\\text{Point}) \\\\quad (a--b) = (a'--b') \\\\quad \\\\land \\\\quad (b--c) = (b'--c') \\\\quad \\\\land \\\\quad (c--a) = (c'--a') \\\\quad \\\\land \\\\quad (\\\\angle a:b:c) = (\\\\angle a':b':c') \\\\quad \\\\land \\\\quad (\\\\angle b:c:a) = (\\\\angle b':c':a') \\\\quad \\\\land \\\\quad (\\\\angle c:a:b) = (\\\\angle c':a':b') \\\\quad \\\\rightarrow \\\\quad \\\\text{Triangle}.\\\\text{area} (\\\\triangle a:b:c) = \\\\text{Triangle}.\\\\text{area}(\\\\triangle a':b':c')\\n\\\\]\\n\\nTransfer Rules.\\n\\nWe have 23 transfer rules acting as the bridge between diagrammatic facts and metric facts. They include 5 rules not in E's paper: flat angle if, flat angle onlyif, parallelogram area, sum parallelograms area, and rectangle area.\"}"}

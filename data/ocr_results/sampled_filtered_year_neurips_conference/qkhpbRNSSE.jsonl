{"id": "qkhpbRNSSE", "page_num": 1, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Abstract\\n\\nWe introduce ProofNet, a benchmark for autoformalization and formal proving of undergraduate-level mathematics. The ProofNet benchmarks consists of 371 examples, each consisting of a formal theorem statement in Lean 3, a natural language theorem statement, and a natural language proof. The problems are primarily drawn from popular undergraduate pure mathematics textbooks and cover topics such as real and complex analysis, linear algebra, abstract algebra, and topology. We intend for ProofNet to be a challenging benchmark that will drive progress in autoformalization and automatic theorem proving. We report baseline results on statement autoformalization via in-context learning. Moreover we demonstrate improvements over our baselines by applying prompt retrieval and distilled backtranslation.\\n\\n1 Introduction\\n\\nThe creation of an automatic mathematician, that is, a system capable of autonomously posing conjectures and proving theorems, is a longstanding challenge in mathematics and artificial intelligence [Gelernter, 1959]. In recent years, neural generative language modeling has emerged as a promising approach to automating aspects of mathematics [Rabe and Szegedy, 2021].\\n\\nOne approach to applying language models to mathematics has been to treat mathematical reasoning in natural language as a sequence learning task [Welleck et al., 2021a, 2022, Lewkowycz et al., 2022]. A key advantage of mathematical reasoning in natural language is the abundance of natural language mathematics data on the internet [Lewkowycz et al., 2022].\\n\\nAn alternative approach is to use language models to guide formal proof-search in an interactive theorem prover (ITP) [Whalen, 2016, Yang and Deng, 2019, Wang and Deng, 2020, Polu et al., 2022, Jiang et al., 2022a, Lample et al., 2022, First et al., 2023]. A salient advantage of this method is that...\"}"}
{"id": "qkhpbRNSSE", "page_num": 2, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Lean\\nmathlib\\n\\nFormal theorem statement:\\ntheorem exists_subgroup_card_pow_prime\\n[fintype G] (p : \u2115) {n : \u2115} [fact p.prime] (hdvd: p ^ n | card G) :\\n\u2203 K : subgroup G, fintype.card K = p ^ n\\n\\nProofNet\\ndataset (ours)\\n\\nFormal theorem statement:\\ntheorem exercise_4_5_14 {G : Type _} [group G] [fintype G] (hG : card G = 312) :\\n\u2203 (p : \u2115) (P : sylow p G), P.normal\\n\\nNatural language theorem statement:\\nProve that a group of order 312 has a normal Sylow p-subgroup for some prime p dividing its order.\\n\\nNatural language proof:\\nProof.\\nLet n_13 be the number of Sylow 13-subgroups of G. Then by Sylow's Theorem, n_13 \u2261 1(mod 13) and n_13 divides 2^3 \u00b7 3 = 24. This implies n_13 = 1, so that there is only one Sylow 13-subgroup, which is consequently normal. The last assertion follows from the fact conjugation preserves the order of a subgroup. So if there is only one subgroup H of order 13, then for any g \u2208 G, we have gHg\u207b\u00b9 = |H| = 13, so gHg\u207b\u00b9 = H, i.e. H is normal.\\n\\nFigure 1:\\nA sample theorem statement from mathlib, show on the left, and a sample theorem statement from ProofNet, shown on the right. mathlib emphasizes including the most abstract and general formulations of mathematical results, whereas ProofNet predominantly tests the ability of models to apply those results to concrete problems.\\n\\nthe ITP acts as a verifier for the language model's reasoning, enabling the natural implementation of 24 bootstrapping techniques such as expert iteration [Silver et al., 2017, Polu et al., 2022, Lample et al., 2022].\\n\\nAutoformalization, the task of automatically formalizing mathematics, seeks to build a bridge between informal and formal mathematical reasoning [Wang et al., 2018, Szegedy, 2020, Wu et al., 2022a, Jiang et al., 2023], with the potential of extracting a training signal from vast corpora of natural language mathematics data while still grounding a system's reasoning in verified formal logic. However, the small amount and low diversity of parallel data between informal and formal mathematics means that autoformalization suffers from a lack of standard benchmarks to guide progress in the field.\\n\\nTo remedy this gap, we propose ProofNet, a benchmark consisting of parallel natural language and formal mathematics that can be used to evaluate autoformalization and theorem proving. The ProofNet benchmark consists of 371 parallel formal theorem statements, natural language theorem statements, and natural language proofs sourced from the exercises of popular undergraduate-level pure mathematics textbooks. Formal statements are expressed in the Lean 3 theorem prover [de Moura et al., 2015, mathlib Community, 2020].\\n\\nLanguage-model-based theorem provers and autoformalization systems have typically been evaluated on benchmarks consisting of competition and olympiad-style problems [Zheng et al., 2022, Wu et al., 2022a]. While such problems require complex reasoning, their solutions only depend on a relatively small set of elementary facts about integers, real numbers, counting, and geometry. In contrast, modern research mathematics requires the mastery of a massive body of theory made up of thousands of definitions, lemmas, and theorems. The Lean 3 formalization of perfectoid spaces, an important definition in research-level arithmetic geometry, depends on over 3000 distinct theorems.\\n\\nFull dataset are available at https://huggingface.co/datasets/hoskinson-center/proofnet. Code to replicate experiments available at https://github.com/zhangir-azerbayev/ProofNet.\"}"}
{"id": "qkhpbRNSSE", "page_num": 3, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 2:\\n\\nLeft: We focus our evaluation on three language models. The first is the Code-davinci-002 endpoint of the OpenAI API [Chen et al., 2021], which is pre-trained on a (proprietary) code dataset. The second is the PROOF GPT suite, which are pre-trained on the proof-pile dataset. Finally, we also finetune a PROOF GPT model using the distilled backtranslation methodology (see subsection 4.1.3).\\n\\nRight: Each example in the ProofNet benchmark consists of a natural language (NL) statement, a formal statement, and an NL proof. In this work, we focus our evaluation on statement autoformalization and informalization. The tasks of proof autoformalization and formal theorem proving are also supported by ProofNet and definitions [Buzzard et al., 2020]. How to effectively reason over such a large repository of knowledge is an important unsolved problem in applying language models to mathematics [Irving et al., 2016, Wu et al., 2022b, Tworkowski et al., 2022].\\n\\nProofNet falls short of requiring mastery of all of modern mathematics, but poses the still ambitious goal of reasoning over the core of an undergraduate mathematics, including basic analysis, algebra, number theory, and topology. We hope that this benchmark will spur the development of language models that are able to reason effectively over large knowledge bases.\\n\\nIn order to obtain stronger baselines on ProofNet, we train and open-source the PROOF GPT language models at scales of 1.3 billion and 6.7 billion parameters. These models are trained on the proof-pile, an 8.3 billion token dataset of mathematical text. To our knowledge, these are the only open-source language models fine-tuned for general mathematics.\\n\\nWe establish baselines for ProofNet theorem autoformalization using in-context learning [Brown et al., 2020]. Moreover, we introduce two novel theorem autoformalization methods that outperform our few-shot baselines.\\n\\nPrompt retrieval uses nearest-neighbor search against an embedding database to create a prompt consisting of the mathlib declarations most relevant to a particular natural language theorem. Distilled backtranslation is a method inspired by work in unsupervised machine translation [Lample et al., 2017, Han et al., 2021a] that finetunes a language model for autoformalization at a large scale without the need for parallel data.\"}"}
{"id": "qkhpbRNSSE", "page_num": 4, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 1:\\n\\nComposition of the proof-pile.\\n\\nNot all textbook exercises lend themselves naturally to formalization. In particular, we only consider problems meeting the following criteria:\\n\\n- **Self-containment.** Problems should only depend on the results commonly taught in an undergraduate curriculum. In particular, this rules out problems that are split into multiple sequentially dependent parts, or those using nonstandard notations.\\n\\n- **Naturality of formalization.** Not all kinds of mathematical problems can be naturally formalized, such as word problems, and such problems are excluded. We do not include exercises that require computing an unknown quantity. We do not include problems that depend on parts of Lean's mathlib that are relatively less mature, such as Euclidean geometry or combinatorics.\\n\\n- **Low risk of train-test overlap.** Because language models are often pre-trained on large corpora mined from the internet that include mathlib, we refrain from including statements that are in mathlib or are likely to be added to mathlib in the future. In practice, this means we avoid the abstract \\\"theory-building\\\" style of theorems that constitute mathlib, and instead choose problems that involve applying general results to specific cases. For more insight into the stylistic differences between mathlib and ProofNet problems, see Figure 1.\\n\\nBeyond the above criteria, problems were selected for broad coverage of the undergraduate curriculum and to range in difficulty from straightforward applications of the definitions to those requiring tremendous creativity. Problems statements are transcribed into LaTeX and formalized by human annotators proficient in Lean. Natural language proofs are adapted from online solutions manuals, or in a few cases, written by the annotators.\\n\\nSupported Tasks\\n\\nAs ProofNet includes parallel natural language statements, natural language proofs, and formal statements, the dataset supports the evaluation of the following distinct tasks:\\n\\n- **Formal theorem proving.** Given a formal statement of a theorem, produce a formal proof.\\n\\n- **Informal theorem proving.** Given an informal statement, produce an informal proof. This facilitates direct comparison between formal and informal theorem proving approaches.\\n\\n- **Autoformalization and informalization of statements.** Given an informal (formal) statement, produce a corresponding formal (informal) statement.\\n\\n- **Autoformalization of proofs.** Given an informal theorem statement, its informal proof, and its formal statement, produce a formal proof.\\n\\nIn order to obtain stronger baselines on the ProofNet benchmark, we introduce the PROOFGPT language models and a text dataset named the proof-pile that these models are trained on. Many approaches to quantitative reasoning with language models depend on pre-training or fine-tuning a\"}"}
{"id": "qkhpbRNSSE", "page_num": 5, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 2: Comparison of model perplexities on the test set of the arXiv subset of the proof-pile and the entire proof-pile. Documents were joined using two newline characters and perplexity was calculated with a stride equal to the model's context length, which is 2048 for all models shown.\\n\\nMotivated by these results, we train and open-source the PROOF GPT models at sizes of 1.3 billion and 6.7 billion parameters. The PROOF GPT models are decoder-only causal language models initialized with Pythia weights [Biderman et al., 2023] and then fine-tuned on the proof-pile, a corpus of unstructured mathematical text gathered from internet sources whose composition is detailed in Table 1. The proof-pile contains roughly 8.3 billion GPT-NeoX [Andonian et al., 2021] tokens. Fine-tuning was performed using the GPT-NeoX library [Andonian et al., 2021]. For training hyperparameters, see Appendix A. In Table 2, we show that the PROOF GPT models outperform Pythia base models at standard mathematical reasoning tasks. We regard the PROOF GPT model suite as inferior to the Minerva models [Lewkowycz et al., 2022] due to the fact that the PROOF GPT models are fine-tuned on an order of magnitude less mathematical text and span a smaller parameter range. However, we hope that the research community will benefit from PROOF GPT\u2019s open-source weights and dataset.\\n\\n4 Methodology and Experiments\\n\\nIn this work, we evaluate the capabilities of pre-trained language models on autoformalizing and informalizing theorem statements. Due to the engineering challenges of implementing neural theorem proving systems in Lean, we leave an investigation of formal theorem proving and proof autoformalization to future work.\\n\\n4.1 Autoformalization methods\\n\\nWe employ in-context learning with large language models as a strong baseline for the autoformalization of theorem statements [Wu et al., 2022a]. Moreover, we introduce two novel methods for boosting autoformalization performance above the few-shot baseline: prompt retrieval and distilled backtranslation.\"}"}
{"id": "qkhpbRNSSE", "page_num": 6, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"For our in-context baselines, we perform inference using the OpenAI API\u2019s Code-davinci-002 and the PROOF GPT 1.3B and 6.7B models. Prompts are listed in Appendix D.\\n\\nBecause there may be multiple ways to formalize the same statement in Lean and no general way to automatically verify whether two statements that are not definitionally equal have the same mathematical content, autoformalizations should be evaluated for correctness by a human expert. For similar reasons, informalizations should also be judged by human experts. In this work, model outputs are scored by the authors. Our open-source repository contains raw model outputs so that the author\u2019s judgements of correctness can be independently verified.\\n\\n4.1.2 Prompt retrieval\\n\\nA blessing and a curse of current language models is that few-shot learning performance is highly sensitive to the exact prompt that is used [Kojima et al., 2022]. In particular, it is plausible that greater few-shot learning performance can be achieved by retrieving the few-shot examples that are most relevant to a particular question.\\n\\nFollowing Liu et al. [2021], we implement a prompt retrieval procedure for statement autoformalization based on nearest neighbors search. Suppose we have a knowledge-base $K$ of formal statements. First, we generate an autoformalization $\\\\hat{y}$ of a statement $x$ using our standard in-context procedure. Then we produce dense vector representations of $\\\\hat{y}$ and the formal statements in $K$. We retrieve the $k$-nearest-neighbors of $\\\\hat{y}$ in $K$, and include them in the few-shot prompt. For the precise format of the prompt, see Appendix D.\\n\\nWe opt to retrieve against $\\\\hat{y}$ instead of against $x$ because this method was significantly more performant in our preliminary experiments.\\n\\nIn our experiments, we create a knowledge-base $K$ by taking our $y$s to be 90,530 statements from Lean mathlib and use $k = 4$. We use the OpenAI API\u2019s embedding-ada-002 endpoint Neelakantan et al. [2022] to generate text embeddings.\\n\\n4.1.3 Distilled backtranslation\\n\\nDue to the amount of domain expert time required to collect parallel corpora of natural language and formal mathematics, scaling up parallel datasets to the point where they are useful for supervised finetuning is impractical. In the face of this limitation, to finetune models on autoformalization we draw on prior work leveraging generative models for unsupervised translation between natural languages. In particular, we use distilled backtranslation, a methodology inspired by Han et al. [2021a].\\n\\nDistilled backtranslation proceeds as follows. Suppose we have a large language model $P_{\\\\text{LLM}}(\\\\cdot)$ pre-trained on monolingual data in both the source and target language, a monolingual corpus $\\\\{Y_i\\\\}$ in the target language. We wish to fine-tune a \u201cstudent\u201d model $P_{\\\\theta}(Y|X)$ to translate a sequence $X$ in the source language to a corresponding sequence $Y$ in the target language. First, we manually construct a few-shot prompt $C$ consisting of $X|Y$ pairs. Then, we sample synthetic backtranslations $X_i \\\\sim P_{\\\\text{LLM}}(X|C, Y_i)$. Finally, we fine-tune $P_{\\\\theta}(\\\\cdot)$ on the synthetic pairs to predict $P(Y|X)$.\\n\\nIn our experiments, we fine-tune PROOF GPT-1.3B using distilled backtranslation with informal mathematics as the source language and Lean 3 theorems as the target language. We use the theorems in Lean\u2019s mathlib as the target language\u2019s monolingual corpus. We use Code-davinci-002 as our teacher LM and proofGPT-1.3B as our student model. Fine-tuning hyperparameters are described in Appendix E.\"}"}
{"id": "qkhpbRNSSE", "page_num": 7, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 3:\\n\\nResults of few-shot learning with LLMs on formalization and informalization of ProofNet statements; all cells are percentages. In addition to reporting autoformalization accuracy, we also report typecheck rate, which is the proportion of a model's samples that are well-formed statements in Lean's dependent type theory. If a model simply copies a formal statement from its prompt, we do not consider that a positive sample when calculating typecheck rate. For the informalization task, we also report compile rate, i.e., what proportion of the model's samples produce LaTeX that compiles.\\n\\nThe most common reason why informal generations fail to compile is that they contain Unicode characters frequently used in Lean's mathlib but not accepted by the pdflatex compiler. To calculate BLEU scores, we split on whitespace and use BLEU-4 with smoothing. Note that formalization BLEU scores being higher than informalization BLEU scores is likely because natural language contains more lexically distinct but semantically equivalent statements.\\n\\n5 Results and Discussion\\n\\nIn Table 3, we present our experimental results for autoformalization and informalization of ProofNet theorem statements. Although conceptually simple and easy to implement, our Code-davinci-002 in-context learning baseline achieves highly nontrivial performance, correctly formalizing 12.9% of theorems. The PROOF GPT models do not formalize any statements correctly, likely owing to their smaller parameter count. However, they demonstrate some signal on the typecheck rate and BLEU metrics. Note that even generating statements that typecheck in Lean 3's strict type system is a nontrivial feat.\\n\\nInformalization accuracy is much higher than formalization accuracy for all models, supporting the intuitive claim that informalization is an easier task than formalization. This result also suggests that large pre-trained language models have a strong grasp of the semantics of formal mathematics, and primarily struggle with generating lexically correct and type-correct Lean code.\\n\\nWe further observe that among Code-davinci-002's generations that typecheck, roughly half are correct formalizations. This is consistent with our hypothesis that Code-davinci-002 has a strong grasp of the semantics of mathematics, since the model displays high accuracy conditional on having generated valid Lean.\\n\\n5.2 Prompt Retrieval and Distilled Backtranslation\\n\\nIn Table 3, we additionally include autoformalization scores for the prompt retrieval and distilled backtranslation models. Applying prompt retrieval to the Code-davinci-002 model significantly boosts performance, increasing accuracy by 2.7 points and, notably, increasing typecheck rate by 21.5 points.\\n\\nDistilled backtranslation improves the autoformalization performance of the PROOF GPT 1.3B model not merely above the in-context performance of PROOF GPT 1.3B, but also above the in-context learning performance of PROOF GPT 6.7B.\"}"}
{"id": "qkhpbRNSSE", "page_num": 8, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Automatic metrics\\n\\nTypecheck rate correlates strongly with formalization accuracy, and we recommend that typecheck rate be used as a predictor of autoformalization performance when evaluating accuracy is too costly. The BLEU metric correlates well with performance on many NLP tasks [Papineni et al., 2002], but correlates poorly with performance code tasks [Chen et al., 2021]. Our findings illustrate that just as with code, BLEU is a poor guide to formalization performance, as prompt retrieval increases Code-davinci-002 formalization accuracy but decreases BLEU by over 10 points.\\n\\n5.3 Qualitative Analysis\\n\\nWe ground our remaining analysis in four case studies: two that demonstrate successful formalizations produced by Code-davinci-002, and two that are representative of our methods' most common failure cases.\\n\\nCase study 1.\\n\\nThe following is a Lean formalization of exercise 4.21a in Walter Rudin's Principles of Mathematical Analysis produced by Code-davinci-002:\\n\\n\\\\[ \\\\text{NL: Suppose } K \\\\text{ and } F \\\\text{ are disjoint sets in a metric space } X, K \\\\text{ is compact, } F \\\\text{ is closed. Prove that there exists } \\\\delta > 0 \\\\text{ such that } d(p, q) > \\\\delta \\\\text{ if } p \\\\in K, q \\\\in F. \\\\]\\n\\nCode-davinci-002 output:\\n\\n\\\\[\\n\\\\text{theorem exercise_4_21a}{X : \\\\text{Type}} \\\\ [\\\\text{metric_space X}] \\\\ {K F : \\\\text{set X}} (hK : \\\\text{compact_space K}) (hF : \\\\text{is_closed F}) (hKF : \\\\text{disjoint K F}) : \\\\\\\\\\n\\\\exists (\\\\delta : \\\\mathbb{R}), \\\\delta > 0 \\\\land \\\\forall (p q : X), p \\\\in K \\\\to q \\\\in F \\\\to \\\\text{dist } p q \\\\geq \\\\delta\\n\\\\]\\n\\nIn this example, Code-davinci-002 demonstrates strong knowledge of mathlib and some reasoning capability. For example, the model correctly identifies that metric spaces are denoted using a typeclass metric_space X, but closed sets are expressed using a predicate is_closed. Moreover, the model correctly renders a consequent that contains nested quantifiers. Finally, the model recognizes the equivalence between \\\"if \\\\( p \\\\in K \\\\) and \\\\( q \\\\in F \\\\)\\\" and \\\"\\\\( p \\\\in K \\\\to q \\\\in F \\\\to \\\\), which demonstrates some logical reasoning ability. However, note that the formalization is not completely idiomatic, as \\\\( \\\\text{compact_space K} \\\\) or \\\\( \\\\text{hK : compact_space K} \\\\) would be preferred to the model's \\\\( \\\\text{hK : is_compact K} \\\\).\\n\\nCase study 2.\\n\\nThe following problem, exercise 6.4.2 from Michael Artin's Algebra, is an example of vanilla Code-davinci-002 making a mistake that is rectified by prompt retrieval.\\n\\n\\\\[ \\\\text{NL: Prove that no group of order } pq, \\\\text{ where } p \\\\text{ and } q \\\\text{ are prime, is simple.} \\\\]\\n\\nCode-davinci-002 output:\\n\\n\\\\[\\n\\\\text{theorem exercise_6_4_2}{G : \\\\text{Type}} \\\\ [\\\\text{group G}] \\\\ [\\\\text{fintype G}] \\\\ {p q : \\\\mathbb{N}} (hp : \\\\text{nat.prime p}) (hq : \\\\text{nat.prime q}) (h : \\\\text{fintype.card G} = p \\\\times q) : \\\\\\\\\\n\\\\neg \\\\text{simple_group G}\\n\\\\]\\n\\nCode-davinci-002 + retrieval output:\\n\\n\\\\[\\n\\\\text{theorem exercise_6_4_2}{G : \\\\text{Type}} \\\\ [\\\\text{group G}] \\\\ [\\\\text{fintype G}] \\\\ {p q : \\\\mathbb{N}} \\\\[hp : \\\\text{fact(nat.prime p)}\\\\] \\\\[hq : \\\\text{fact(nat.prime q)}\\\\] (h : \\\\text{fintype.card G} = p \\\\times q) : \\\\\\\\\\n\\\\neg \\\\text{is_simple_group G}\\n\\\\]\\n\\nVanilla Code-davinci-002 makes a single lexical error: the model has correctly formalized the hypotheses of the problem, but has tried to use a nonexistent predicate simple_group instead of the correct is_simple_group. The retrieval-augmented model uses the correct declaration because one of the retrieved mathlib statements explicitly uses is_simple_group.\\n\\nCase study 3.\\n\\nThe following is an incorrect formalization of exercise 6.16 from Sheldon Axler's Linear Algebra produced by Code-davinci-002. The retrieval-augmented Code-davinci-002 autoformalization, not shown here, is also incorrect.\"}"}
{"id": "qkhpbRNSSE", "page_num": 9, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Suppose $U$ is a subspace of $V$. Prove that $U \\\\perp = \\\\{0\\\\}$ if and only if $U = V$.\\n\\nHere, Code-davinci-002 makes three straightforward lexical mistakes: in mathlib, vector spaces over a field $K$ are denoted by $\\\\text{module } K V$ rather than $\\\\text{vector_space } K V$, subspaces of a vector space by $\\\\text{submodule } K V$ rather than $\\\\text{subspace } V$, and the trivial subspace is denoted by $\\\\perp$ rather than $\\\\{0\\\\}$. However, the model also makes a much more significant logical error. In order for the orthogonal complement $U \\\\perp$ of a subspace to make sense, the space must be endowed with an inner product space structure rather than merely a vector space structure, which is expressed in mathlib as $\\\\text{inner_product_space } K V$. Furthermore, inner product spaces are only defined over the real and complex fields, so one must also declare $\\\\text{is_R_or_C } K$. Reliably inferring these kinds of implicit hypotheses is a major challenge for autoformalization systems.\\n\\nCase Study 4: Looping. When generating formal and natural language theorem statements with PROOF GPTs, the model will often repeatedly generate the same short phrase instead of producing a plausible theorem. For example, consider the attempted formalization of exercise 10.1.13 from Michael Artin's Algebra generated by PROOF GPT-6.7b via in-context learning.\\n\\nNL: An element $x$ of a ring $R$ is called nilpotent if some power of $x$ is zero. Prove that if $x$ is nilpotent, then $1 + x$ is a unit in $R$.\\n\\nPROOF GPT-6.7b output: theorem nilpotent_of_nilpotent_of_nilpotent_of_nilpotent_of_nilpotent\\n\\nPrior work on decoding methods has shown that the likelihood of a repeated phrase increases with each repetition, and that greedy decoding generates text with higher likelihood than natural text [Holtzman et al., 2019]. These two findings constitute a plausible explanation for repetitive looping if the correct autoformalization is assigned low likelihood by the model. We observe that repetitive looping does not occur with Code-davinci-002, suggesting that the problem may disappear with scale (although there are many other differences between our small-scale models and Code-davinci-002).\\n\\nRelated Work\\n\\nLanguage modeling for theorem proving Language models have found success in theorem proving both in the natural language setting [Lewkowycz et al., 2022, Welleck et al., 2021a], and within many major ITPs such as Metamath [Polu and Sutskever, 2020], Isabelle [Jiang et al., 2022a, First et al., 2023], and Lean [Han et al., 2021b, Polu et al., 2022]. Popular benchmarks for evaluating language model-based provers are Hendrycks et al. [2021b] and Welleck et al. [2021a] for natural language, and Zheng et al. [2022] for formal.\\n\\nAutoformalization Recent work in autoformalization with language models was sparked by Wu et al. [2022a], which demonstrated that models can autoformalize Isabelle theorem statements via in-context learning. In Jiang et al. [2022b], the authors demonstrate a method for autoformalizing proofs in Isabelle. However, their method depends on the availability of a performant black-box automated theorem prover, which is not available for Lean at the time of writing.\"}"}
{"id": "qkhpbRNSSE", "page_num": 10, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Interactive Theorem Proving\\n\\nWork in formal theorem proving and autoformalization depends on libraries of formalized mathematics. This work directly depends on Lean's mathlib, but indirectly benefits from lessons learned from other proofs systems such as Coq [Bertot and Cast\u00e9ran, 2004], Mizar [Grabowski et al., 2010], and Isabelle [Nipkow et al., 2002].\\n\\nUnsupervised Machine Translation\\n\\nBecause the amount of parallel formal and natural language text is negligible, autoformalization faces many of the same challenges as unsupervised machine translation [Lample et al., 2017, Conneau et al., 2018, Lample et al., 2018, Han et al., 2021a, Garcia et al., 2023]. Our distilled backtranslation method is inspired by the distilled and iterated backtranslation algorithm of Han et al. [2021a]. However, the authors of this work regard backtranslation as a temporary workaround and foresee that in-context learning will be enough to elicit maximal performance from a sufficiently good language model, as is now the case for unsupervised translation [Garcia et al., 2023].\\n\\nConclusion\\n\\nWe introduced ProofNet, a benchmarking consisting of parallel natural language theorem statements, natural language proofs, and formal theorem statements in Lean 3. We have shown that pre-trained large language models achieve non-trivial but far from consistent performance via in-context learning on the autoformalization of ProofNet statements. Moreover, we have proposed prompt retrieval and distilled backtranslation, two methods that improve autoformalization performance above baseline.\\n\\nAcknowledgments\\n\\nThe authors would like to thank the Hoskinson Center for Formal Mathematics at Carnegie Mellon University for its generous funding and for providing a stimulating work environment. We additionally thank EleutherAI for providing compute to train the PROOF GPT models. Piotrowski was supported also by the grant of National Science Center, Poland, no. 2018/29/N/ST6/02903, and by the Kosciuszko Fundation. Finally, we would like to thank Eric Wieser, Kaiyu Yang, and Junyan Xu for spotting errors in the dataset.\\n\\nReferences\\n\\nThe Isabelle Archive of Formal Proofs. https://www.isa-afp.org/.\\n\\nAlex Andonian, Quentin Anthony, Stella Biderman, Sid Black, Preetham Gali, Leo Gao, Eric Hallahan, Josh Levy-Kramer, Connor Leahy, Lucas Nestler, Kip Parker, Michael Pieler, Shivanshu Purohit, Tri Songz, Wang Phil, and Samuel Weinbach. GPT-NeoX: Large Scale Autoregressive Language Modeling in PyTorch, 8 2021. URL https://www.github.com/eleutherai/gpt-neox.\\n\\nYves Bertot and Pierre Cast\u00e9ran. Interactive Theorem Proving and Program Development - Coq'Art: The Calculus of Inductive Constructions. Springer, 2004.\\n\\nStella Biderman, Hailey Schoelkopf, Quentin Anthony, Herbie Bradley, Kyle O'Brien, Eric Hallahan, Mohammad Aflah Khan, Shivanshu Purohit, USVSN Sai Prashanth, Aviya Skowron, Lin tang Sutawika, and Oskar van der Wal. Pythia: a scaling suite for language model interpretability research. Computing Research Repository, 2023. doi: 10.48550/arXiv.2201.07311. URL https://arxiv.org/abs/2304.01373. version 1.\"}"}
{"id": "qkhpbRNSSE", "page_num": 11, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, and Dario Amodei. Language models are few-shot learners, 2020. URL https://arxiv.org/abs/2005.14165.\\n\\nKevin Buzzard, Johan Commelin, and Patrick Massot. Formalising perfectoid spaces. In Jasmin Blanchette and Catalin Hritcu, editors, Proceedings of the 9th ACM SIGPLAN International Conference on Certified Programs and Proofs, CPP 2020, New Orleans, LA, USA, January 20-21, 2020, pages 299\u2013312. ACM, 2020. doi: 10.1145/3372885.3373830. URL https://doi.org/10.1145/3372885.3373830.\\n\\nMark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, Alex Ray, Raul Puri, Gretchen Krueger, Michael Petrov, Heidy Khlaaf, Girish Sastry, Pamela Mishkin, Brooke Chan, Scott Gray, Nick Ryder, Mikhail Pavlov, Alethea Power, Lukasz Kaiser, Mohammad Bavarian, Clemens Winter, Philippe Tillet, Felipe Petroski Such, Dave Cummings, Matthias Plappert, Fotios Chantzis, Elizabeth Barnes, Ariel Herbert-Voss, William Hebgen Guss, Alex Nichol, Alex Paino, Nikolas Tezak, Jie Tang, Igor Babuschkin, Suchir Balaji, Shantanu Jain, William Saunders, Christopher Hesse, Andrew N. Carr, Jan Leike, Josh Achiam, Vedant Misra, Evan Morikawa, Alec Radford, Matthew Knight, Miles Brundage, Mira Murati, Katie Mayer, Peter Welinder, Bob McGrew, Dario Amodei, Sam McCandlish, Ilya Sutskever, and Wojciech Zaremba. Evaluating large language models trained on code, 2021. URL https://arxiv.org/abs/2107.03374.\\n\\nAlexis Conneau, Guillaume Lample, Marc'Aurelio Ranzato, Ludovic Denoyer, and Herv\u00e9 J\u00e9gou. Word translation without parallel data. In International Conference on Learning Representations, 2018.\\n\\nLeonardo Mendon\u00e7a de Moura, Soonho Kong, Jeremy Avigad, Floris van Doorn, and Jakob von Raumer. The Lean theorem prover (system description). In Amy P. Felty and Aart Middeldorp, editors, Conference on Automated Deduction (CADE) 2015, pages 378\u2013388. Springer, 2015.\\n\\nEmily First, Markus N. Rabe, Talia Ringer, and Yuriy Brun. Baldur: Whole-proof generation and repair with large language models, 2023.\\n\\nSimon Frieder, Luca Pinchetti, Alexis Chevalier, Ryan-Rhys Griffiths, Tommaso Salvatori, Thomas Lukasiewicz, Philipp Christian Petersen, and Julius Berner. Mathematical capabilities of chatgpt, 2023.\\n\\nXavier Garcia, Yamini Bansal, Colin Cherry, George Foster, Maxim Krikun, Fangxiaoyu Feng, Melvin Johnson, and Orhan Firat. The unreasonable effectiveness of few-shot learning for machine translation, 2023. URL https://arxiv.org/abs/2302.01398.\\n\\nHerbert L. Gelernter. Realization of a geometry theorem proving machine. In IFIP Congress, 1959.\\n\\nAdam Grabowski, Artur Kornilowicz, and Adam Naumowicz. Mizar in a nutshell. J. Formalized Reasoning, 3(2):153\u2013245, 2010.\\n\\nJesse Michael Han, Igor Babuschkin, Harrison Edwards, Arvind Neelakantan, Tao Xu, Stanislas Polu, Alex Ray, Pranav Shyam, Aditya Ramesh, Alec Radford, and Ilya Sutskever. Unsupervised neural machine translation with generative language models only, 2021a. URL https://arxiv.org/abs/2110.05448.\\n\\nJesse Michael Han, Jason Rute, Yuhuai Wu, Edward W. Ayers, and Stanislas Polu. Proof artifact co-training for theorem proving with language models, 2021b. URL https://arxiv.org/abs/2102.06203.\\n\\nDan Hendrycks, Collin Burns, Steven Basart, Andy Zou, Mantas Mazeika, Dawn Song, and Jacob Steinhardt. Measuring massive multitask language understanding. In International Conference on Learning Representations, 2021a. URL https://openreview.net/forum?id=d7KBjmI3GmQ.\"}"}
{"id": "qkhpbRNSSE", "page_num": 12, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Dan Hendrycks, Collin Burns, Saurav Kadavath, Akul Arora, Steven Basart, Eric Tang, Dawn Song, and Jacob Steinhardt. Measuring mathematical problem solving with the math dataset, 2021b. URL https://arxiv.org/abs/2103.03874.\\n\\nAri Holtzman, Jan Buys, Li Du, Maxwell Forbes, and Yejin Choi. The curious case of neural text degeneration, 2019. URL https://arxiv.org/abs/1904.09751.\\n\\nGeoffrey Irving, Christian Szegedy, Alexander A Alemi, Niklas Een, Francois Chollet, and Josef Urban. Deepmath - deep sequence models for premise selection. In D. Lee, M. Sugiyama, U. Luxburg, I. Guyon, and R. Garnett, editors, Advances in Neural Information Processing Systems, volume 29. Curran Associates, Inc., 2016. URL https://proceedings.neurips.cc/paper/2016/file/f197002b9a0853eca5e046d9ca4663d5-Paper.pdf.\\n\\nAlbert Q. Jiang, Wenda Li, Szymon Tworkowski, Konrad Czechowski, Tomasz Odrzyg\u00f3d, Piotr Mio, Yuhuai Wu, and Mateja Jamnik. Thor: Wielding hammers to integrate language models and automated theorem provers, 2022a. URL https://arxiv.org/abs/2205.10893.\\n\\nAlbert Q. Jiang, Sean Welleck, Jin Peng Zhou, Wenda Li, Jiacheng Liu, Mateja Jamnik, Timoth\u00e9e Lacroix, Yuhuai Wu, and Guillaume Lample. Draft, sketch, and prove: Guiding formal theorem provers with informal proofs, 2022b. URL https://arxiv.org/abs/2210.12283.\\n\\nAlbert Qiaochu Jiang, Wenda Li, Jesse Michael Han, and Yuhuai Wu. Lisa: Language models of isabelle proofs. In 6th Conference on Artificial Intelligence and Theorem Proving, pages 378\u2013392, 2021.\\n\\nAlbert Qiaochu Jiang, Sean Welleck, Jin Peng Zhou, Timothee Lacroix, Jiacheng Liu, Wenda Li, Mateja Jamnik, Guillaume Lample, and Yuhuai Wu. Draft, sketch, and prove: Guiding formal theorem provers with informal proofs. In The Eleventh International Conference on Learning Representations, 2023. URL https://openreview.net/forum?id=SMa9EAovKMC.\\n\\nTakeshi Kojima, Shixiang Shane Gu, Machel Reid, Yutaka Matsuo, and Yusuke Iwasawa. Large language models are zero-shot reasoners, 2022. URL https://arxiv.org/abs/2205.11916.\\n\\nGuillaume Lample, Alexis Conneau, Ludovic Denoyer, and Marc'Aurelio Ranzato. Unsupervised machine translation using monolingual corpora only, 2017. URL https://arxiv.org/abs/1711.00043.\\n\\nGuillaume Lample, Myle Ott, Alexis Conneau, Ludovic Denoyer, and Marc'Aurelio Ranzato. Phrase-based & neural unsupervised machine translation. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, 2018.\\n\\nGuillaume Lample, Marie-Anne Lachaux, Thibaut Lavril, Xavier Martinet, Amaury Hayat, Gabriel Ebner, Aur\u00e9lien Rodriguez, and Timoth\u00e9e Lacroix. Hypertree proof search for neural theorem proving, 2022. URL https://arxiv.org/abs/2205.11491.\\n\\nAitor Lewkowycz, Anders Andreassen, David Dohan, Ethan Dyer, Henryk Michalewski, Vinay Ramasesh, Ambrose Slone, Cem Anil, Imanol Schlag, Theo Gutman-Solo, Yuhuai Wu, Behnam Neyshabur, Guy Gur-Ari, and Vedant Misra. Solving quantitative reasoning problems with language models, 2022. URL https://arxiv.org/abs/2206.14858.\\n\\nJiachang Liu, Dinghan Shen, Yizhe Zhang, Bill Dolan, Lawrence Carin, and Weizhu Chen. What makes good in-context examples for gpt-3?, 2021.\\n\\nThe mathlib Community. The lean mathematical library. In Proceedings of the 9th ACM SIGPLAN International Conference on Certified Programs and Proofs. ACM, jan 2020. doi:10.1145/3372885.3373824. URL https://doi.org/10.1145%2F3372885.3373824.\"}"}
{"id": "qkhpbRNSSE", "page_num": 13, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Arvind Neelakantan, Tao Xu, Raul Puri, Alec Radford, Jesse Michael Han, Jerry Tworek, Qiming Yuan, Nikolas Tezak, Jong Wook Kim, Chris Hallacy, Johannes Heidecke, Pranav Shyam, Boris Power, Tyna Eloundou Nekoul, Girish Sastry, Gretchen Krueger, David Schnurr, Felipe Petroski Such, Kenny Hsu, Madeleine Thompson, Tabarak Khan, Toki Sherbakov, Joanne Jang, Peter Welinder, and Lilian Weng. Text and code embeddings by contrastive pre-training, 2022.\\n\\nTobias Nipkow, Lawrence C. Paulson, and Markus Wenzel. Isabelle/HOL \u2013 A Proof Assistant for Higher-Order Logic. Springer, 2002.\\n\\nKishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. Bleu: a method for automatic evaluation of machine translation. In Proceedings of the 40th annual meeting of the Association for Computational Linguistics, pages 311\u2013318, 2002.\\n\\nStanislas Polu and Ilya Sutskever. Generative language modeling for automated theorem proving, 2020. URL https://arxiv.org/abs/2009.03393.\\n\\nStanislas Polu, Jesse Michael Han, Kunhao Zheng, Mantas Baksys, Igor Babuschkin, and Ilya Sutskever. Formal mathematics statement curriculum learning, 2022. URL https://arxiv.org/abs/2202.01344.\\n\\nMarkus N. Rabe and Christian Szegedy. Towards the automatic mathematician. In Andr\u00e9 Platzer and Geoff Sutcliffe, editors, Automated Deduction \u2013 CADE 28, pages 25\u201337, Cham, 2021. Springer International Publishing. ISBN 978-3-030-79876-5.\\n\\nDavid Silver, Thomas Hubert, Julian Schrittwieser, Ioannis Antonoglou, Matthew Lai, Arthur Guez, Marc Lanctot, L. Sifre, Dharshan Kumaran, Thore Graepel, Timothy P. Lillicrap, Karen Simonyan, and Demis Hassabis. Mastering chess and shogi by self-play with a general reinforcement learning algorithm. ArXiv, abs/1712.01815, 2017.\\n\\nChristian Szegedy. A promising path towards autoformalization and general artificial intelligence. In Christoph Benzm\u00fcller and Bruce Miller, editors, Intelligent Computer Mathematics, pages 3\u201320, Cham, 2020. Springer International Publishing. ISBN 978-3-030-53518-6.\\n\\nSzymon Tworkowski, Maciej Mikua, Tomasz Odrzyg\u00f3d, Konrad Czechowski, Szymon Antoniak, Albert Jiang, Christian Szegedy, ukasz Kuciski, Piotr Mio, and Yuhuai Wu. Formal premise selection with language models, 2022. URL http://aitp-conference.org/2022/abstract/AITP_2022_paper_32.pdf.\\n\\nMingzhe Wang and Jia Deng. Learning to prove theorems by learning to generate theorems, 2020.\\n\\nQingxiang Wang, Cezary Kaliszyk, and Josef Urban. First experiments with neural translation of informal to formal mathematics. In Florian Rabe, William M. Farmer, Grant O. Passmore, and Abdou Youssef, editors, Intelligent Computer Mathematics, pages 255\u2013270, Cham, 2018. Springer International Publishing. ISBN 978-3-319-96812-4.\\n\\nSean Welleck, Jiacheng Liu, Ronan Le Bras, Hannaneh Hajishirzi, Yejin Choi, and Kyunghyun Cho. Naturalproofs: Mathematical theorem proving in natural language, 2021a. URL https://arxiv.org/abs/2104.01112.\\n\\nSean Welleck, Jiacheng Liu, Ronan Le Bras, Hannaneh Hajishirzi, Yejin Choi, and Kyunghyun Cho. Naturalproofs: Mathematical theorem proving in natural language. In Thirty-fifth Conference on Neural Information Processing Systems Datasets and Benchmarks Track (Round 1), 2021b. URL https://openreview.net/forum?id=Jvxa8adr3iY.\\n\\nSean Welleck, Jiacheng Liu, Ximing Lu, Hannaneh Hajishirzi, and Yejin Choi. Naturalprover: Grounded mathematical proof generation with language models, 2022. URL https://arxiv.org/abs/2205.12910.\\n\\nDaniel Whalen. Holophrasm: a neural automated theorem prover for higher-order logic, 2016.\"}"}
{"id": "qkhpbRNSSE", "page_num": 14, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 5 displays hyperparameters for PROOF GPT training on the proof-PILE.\\n\\n**Problem Sources**\\n\\nThe following is a complete list of sources ProofNet draws from:\\n\\n- **Analysis**: Walter Rudin's *Principles of Mathematical Analysis* 3rd ed, Charles C. Pugh's *Real Mathematical Analysis* 1st ed, Elias M. Stein and Rami Shakarchi's *Complex Analysis* 1st ed.\\n- **Linear Algebra**: Sheldon Axler's *Linear Algebra Done Right* 2nd ed.\\n- **Abstract Algebra**: David S. Dummit and Richard M. Foote's *Abstract Algebra* 3rd ed, I.N. Herstein's *Abstract Algebra* 3rd ed, and Michael Artin's *Algebra* 1st ed.\\n- **Topology**: James Munkres' *Topology* 2nd ed.\\n- **Examinations**: Putnam Competition.\\n\\n**Comparison to Existing Benchmarks**\\n\\nFor a comparison of ProofNet to existing mathematical reasoning benchmarks, see Table 4.\\n\\n**Prompts**\\n\\nPrompts are viewable in the open-source repository. The retrieval knowledge base and the code for generating it is also available in the repository. We use a 12-shot prompt for Code-davinci-002 autoformalization and informalization, and a 6-shot prompt for PROOF GPT autoformalization and informalization. We give PROOF GPT models fewer examples because of its shorter context (2048 tokens compared to 8192), we only use the last six examples when prompting PROOF GPT.\\n\\nFor retrieval augmented models, we use a 3-shot prompt, where each example consists of 4 reference formal statements and one NL-formal pair.\\n\\n6 [https://github.com/zhangir-azerbayev/ProofNet/tree/main/eval/prompts](https://github.com/zhangir-azerbayev/ProofNet/tree/main/eval/prompts)\\n\\n7 [https://github.com/zhangir-azerbayev/ProofNet/blob/main/train_backtranslation/make_data/docgen_export_with_nl/docgen_export_with_nl.jsonl](https://github.com/zhangir-azerbayev/ProofNet/blob/main/train_backtranslation/make_data/docgen_export_with_nl/docgen_export_with_nl.jsonl)\"}"}
{"id": "qkhpbRNSSE", "page_num": 15, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 4: A comparison of ProofNet to standard benchmarks for evaluating the mathematical capabilities of language models.\\n\\n|                | MATH | MMLU-STEM | PISA | MiniF2F | NaturalProofs | GHOSTS | ProofNet (ours) |\\n|----------------|------|-----------|------|---------|---------------|--------|----------------|\\n| Contains formal? | 7    | 7         | 3    | 3       | 7             | 3      | 7             |\\n| Contains natural language? | 3    | 3         | 7    | 3       | 3             | 3      | 3             |\\n| Problem Level   | a    | HS HS+UG  | Unrestricted | HS UG+G | UG+UG+G       | UG     |                |\\n| Problem diversity | b    | Low High  | High Low | High High | High High      | High   |                |\\n| Answer format   | Numerical | Multi-choice | Text | Text | Text | Text | Text |\\n| Multi-task      | 7    | 7         | 3    | 3       | 7             | 3      | 3             |\\n| Proof-based task available? | 7    | 7         | 3    | 3       | 3             | 3      | 3             |\\n| Training set?   | 3    | 3         | 3    | 7       | 7             | 7      |                |\\n| Validation + test size | 5000 | 3364      | 4000 | 488     | 3825          | 733    | 371            |\\n\\n* Hendrycks et al. [2021b].\\n** Hendrycks et al. [2021a].\\n*** Jiang et al. [2021].\\n\u2020 Zheng et al. [2022], Jiang et al. [2023].\\n\u2020\u2020 Welleck et al. [2021b].\\n\u2020\u2020\u2020 Frieder et al. [2023].\\n\\na: HS refers to \u201chigh school\u201d UG refers to \u201cundergraduate\u201d, and G refers to \u201cgraduate.\u201d\\n\\nThe problem level of PISA is referred to as \u201cunrestricted\u201d because PISA is based on the Archive of Formal Proofs [Isa], which is a library of formalized mathematics containing theorems at a wide variety of levels.\\n\\nb: MATH and MiniF2F are labelled as low diversity because they only contain high-school level Olympiad problems. MMLU-STEM, PISA, and ProofNet are labelled as high diversity because they covers multiple parts of the mathematics curriculum.\\n\\nTable 5: PROOF GPT training hyperparameters.\\n\\n| Setting Parameter | 1.3B | 6.7B |\\n|-------------------|------|------|\\n| Tokens            | 10.5 billion |      |\\n| Epochs            | 1.3  |      |\\n| Training Steps    | 40,000 |      |\\n| Learning Rate Max | $2 \\\\times 10^{-4}$ | $2 \\\\times 10^{-5}$ |\\n| Learning Rate Min | $2 \\\\times 10^{-4}$ | $2 \\\\times 10^{-5}$ |\\n| Optimizer         | Adam |      |\\n| Adam Betas        | (0.9, 0.95) |      |\\n| Adam Eps          | $1 \\\\times 10^{-8}$ |      |\\n| Weight Decay      | 0.1  |      |\\n| LR Scheduler      | Cosine w/ warm-up |      |\\n| LR Warm-up Steps  | 400  |      |\\n| Effective Batch Size | 128 |      |\\n| Precision         | FP16 |      |\\n| Gradient Clipping | 1.0  |      |\\n\\nE Finetuning: 477\\n\\nOur fine-tuning dataset of backtranslations consists of 90,530 NL-formal pairs. Both the Pythia-1.4b and PROOF GPT-1.3B model are finetuned according to the hyperparameters above. The models evaluated in Table 3 are the minimum validation loss checkpoint, which occurs at 15,000 training steps.\"}"}
{"id": "qkhpbRNSSE", "page_num": 16, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Parameter Setting\\n\\nTraining Steps 20,000\\n\\nLearning Rate (LR) $5 \\\\cdot 10^{-5}$\\n\\nOptimizer AdamW\\n\\nAdam Betas $(0.9, 0.999)$\\n\\nAdam Eps $1 \\\\cdot 10^{-8}$\\n\\nWeight Decay 0.1\\n\\nLR Scheduler Cosine w/ warm-up\\n\\nLR Warm-up Steps 2000\\n\\nEffective Batch Size 24\\n\\nPrecision FP16\\n\\nGradient Clipping 1.0\\n\\nTable 6: Student training hyperparameters.\"}"}

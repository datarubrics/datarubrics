{"id": "r8PnfcWQol", "page_num": 1, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"To answer complex queries on knowledge graphs, logical reasoning over incomplete knowledge needs learning-based methods because they are capable of generalizing over unobserved knowledge. Therefore, an appropriate dataset is fundamental to both obtaining and evaluating such methods under this paradigm. In this paper, we propose a comprehensive framework for data generation, model training, and method evaluation that covers the combinatorial space of Existential First-order Queries with multiple variables ($EFO_k$). The combinatorial query space in our framework significantly extends those defined by set operations in the existing literature. Additionally, we construct a dataset, $EFO_k$-CQA, with 741 query types for empirical evaluation, and our benchmark results provide new insights into how query hardness affects the results. Furthermore, we demonstrate that the existing dataset construction process is systematically biased and hinders the appropriate development of query-answering methods, highlighting the importance of our work. Our code and data are provided in https://anonymous.4open.science/r/EFOK-CQA/README.md\\n\\n1 Introduction\\n\\nThe Knowledge Graph (KG) is a powerful database that encodes relational knowledge into a graph representation [34, 31], supporting downstream tasks [41, 8] with essential factual knowledge. However, KGs suffer from incompleteness during its construction [34, 7, 19]. The task of Complex Query Answering (CQA) proposed recently has attracted much research interest [13, 28]. This task ambitiously aims to answer database-level complex queries described by logical complex connectives (conjunction $\\\\land$, disjunction $\\\\lor$, and negation $\\\\neg$) and quantifiers (existential $\\\\exists$) [37, 27, 18]. Currently, learning-based methods dominate the CQA tasks because they can empirically generalize to unseen knowledge as well as prevent the resource-demanding symbolic search.\\n\\nThe thriving of learning-based methods also puts an urgent request on high-quality benchmarks, including datasets with comprehensive coverage of queries and sound answers, and fair evaluation protocol for learning-based approaches. In the previous study, datasets are developed by progressively expanding the syntactical expressiveness, where conjunction [13], union [26], negation [28], and other operators [20] are taken into account sequentially. In particular, BetaE dataset [28] contains all logical connectives and becomes the standard training set for model development. A larger CQA on KG [37, 27] and database query answering [25].\\n\\n1 The universal quantifier is usually not considered in query answering tasks, as a common practice from both CQA on KG [37, 27] and database query answering [25].\\n\\nSubmitted to the 38th Conference on Neural Information Processing Systems (NeurIPS 2024) Track on Datasets and Benchmarks. Do not distribute.\"}"}
{"id": "r8PnfcWQol", "page_num": 2, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Evaluation benchmark EFO-1-QA [36] was proposed to systematically evaluate the combinatorial generalizability of CQA models on such queries. More related works are included in Appendix A. However, the queries in previous datasets [28, 36] are recently justified as \\\"Tree-Form\\\" queries [39] as they rely on the tree combinations of set operations. Compared to the well-established TPC-H decision support benchmark [25] for database query processing, queries in existing CQA benchmarks [28, 36] have two common shortcomings: (1) lack of combinatorial answers: only one variable is queried, and (2) lack of structural hardness: all existing queries subject to the structure-based tractability [29, 37, 39]. It is rather questionable whether existing CQA data under such limited scope can support the future development of methodologies for general decision support with incomplete knowledge.\\n\\nThe goal of this paper is to establish a new framework that addresses the aforementioned shortcomings to support further research in complex query answering on knowledge graphs. Our framework is formally motivated by the well-established investigation of constraint satisfaction problems [29], in which all queries can be formulated. In general, the contribution of our work is four folds.\\n\\n**Complete coverage** We capture the complete Existential First Order (EFO) queries from their rigorous definitions, underscoring both combinatorial hardness and structural hardness and extending the existing coverage [36] which covers only a subset of EFO query. The captured query family is denoted as EFO \\\\(_k\\\\) where \\\\(k\\\\) stands for multiple variables.\\n\\n**Curated datasets** We derive EFO \\\\(_k\\\\)-CQA dataset, a enormous extension of the previous EFO-1-QA benchmark [36] and contains 741 types of query. We design several systematic rules to guarantee that our dataset includes high-quality nontrivial queries, particularly those that contain multiple query variables and are not structure-based tractable.\\n\\n**Convenient implementation** We implement the entire pipeline for query generation, answer sampling, model training and inference, and evaluation for the undiscussed scenarios of combinatorial answers. Our pipeline is backward compatible, which supports both set operation-based methods and more recent ones.\\n\\n**Results and findings** We evaluate six representative CQA methods on our benchmark. Our results refresh the previous empirical findings and further reveal the structural bias of previous data.\\n\\n2 Problem definition\\n\\n2.1 Existential first order (EFO) queries on knowledge graphs\\n\\nGiven a set \\\\(E\\\\) of entities and a set \\\\(R\\\\) of relations, a knowledge graph \\\\(KG\\\\) encodes knowledge as a set of factual triple \\\\(KG^{\\\\perp h, r, t}\\\\) \\\\(\\\\in E \\\\times R \\\\times E\\\\). We always assume the KG that we have observed \\\\(KG_{\\\\text{o}}\\\\) is only part of the real KG, meaning that \\\\(KG_{\\\\text{o}} \\\\subset KG\\\\).\\n\\nThe existing research only focuses on the logical formulas without universal quantifiers [27, 35]. We then offer the definition of it based on strict first order logic.\\n\\n**Definition 1** (Term). A term is either a variable \\\\(x\\\\) or an entity \\\\(a\\\\) \\\\(\\\\in E\\\\).\\n\\n**Definition 2** (Atomic formula). \\\\(\\\\varphi\\\\) is an atomic formula if \\\\(\\\\varphi \\\\rightarrow r_p^{h, t}\\\\), where \\\\(r\\\\) \\\\(\\\\in R\\\\) is a relation, \\\\(h\\\\) and \\\\(t\\\\) are two terms.\\n\\n**Definition 3** (Existential first order formula). The set of the existential formulas is the smallest set \\\\(\\\\Phi\\\\) that satisfies the following 2:\\n\\n(i) For atomic formula \\\\(r_p^{h, t}\\\\), itself and its negation \\\\(\\\\neg r_p^{h, t}\\\\), \\\\(\\\\varphi \\\\in \\\\Phi\\\\).\\n\\n(ii) If \\\\(\\\\varphi, \\\\psi \\\\in \\\\Phi\\\\), then \\\\(\\\\varphi \\\\land \\\\psi, \\\\varphi \\\\lor \\\\psi \\\\in \\\\Phi\\\\).\\n\\n(iii) If \\\\(\\\\varphi \\\\in \\\\Phi\\\\) and \\\\(x_i\\\\) is any variable, then \\\\(\\\\exists x_i \\\\varphi \\\\in \\\\Phi\\\\).\\n\\n**Definition 4** (Free variable). If a variable \\\\(y\\\\) is not associated with an existential quantifier, it is called a free variable, otherwise, it is called a bounded variable. We write \\\\(\\\\varphi[y_1, \\\\ldots, y_k]\\\\) to indicate \\\\(y_1, \\\\ldots, y_k\\\\) are the free variables of \\\\(\\\\varphi\\\\).\\n\\nWe always assume all variables are named differently as common practice in logic.\"}"}
{"id": "r8PnfcWQol", "page_num": 3, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"\\\\[ \\\\exists x_1. \\\\text{Award}(\\\\text{Fields}, y_1) \\\\land \\\\neg \\\\text{Award}(\\\\text{Fields}, y_2) \\\\land \\\\text{Colleague}(y_1, y_2) \\\\land \\\\text{Born}(y_1, x_1) \\\\land \\\\text{Born}(y_1, x_2) \\\\]\\n\\n\\\\[ \\\\exists x_1. \\\\text{Located}(\\\\text{Europe}, x_1) \\\\land \\\\neg \\\\text{Held}(\\\\text{Olympics}, x_1) \\\\land \\\\text{President}(x_1, y_1) \\\\]\\n\\nFigure 1: Operator Tree versus Query Graph.\\n\\nLeft: An operator tree representing a given query \\\"List the presidents of European countries that have never held the Olympics\\\" [28];\\n\\nRight: A query graph representing a given query \\\"Find a pair of persons who are both colleagues and co-authors and were born in the same country, with one having awarded the fields medal while the another not\\\", which is both a multigraph and a cyclic graph, containing two free variables.\\n\\nDefinition 5 (Sentence and query).\\n\\nA formula \\\\( \\\\phi \\\\) is a sentence if it contains no free variables, otherwise, it is called a query. In this paper, we always consider formula with free variables, thus, we use formula and query interchangeably.\\n\\nDefinition 6 (Substitution).\\n\\nFor \\\\( a_1, \\\\ldots, a_k \\\\), where \\\\( a_i \\\\in PE \\\\), we write \\\\( \\\\phi \\\\rho a_1 \\\\{ y_1, \\\\ldots, a_k \\\\{ y_k \\\\} \\\\) or simply \\\\( \\\\phi \\\\rho a_1, \\\\ldots, a_k \\\\) for the result of simultaneously replacing all the occurrence of \\\\( y_i \\\\) in \\\\( \\\\phi \\\\) by \\\\( a_i \\\\), i \\\"1, \\\\ldots, k.\\n\\nDefinition 7 (Answer of an EFO query).\\n\\nFor a given existential query \\\\( \\\\phi \\\\rho y_1, \\\\ldots, y_k \\\\) and a knowledge graph \\\\( KG \\\\), its answer is a set that defined by\\n\\n\\\\[ A_{r\\\\phi} y_1, \\\\ldots, y_k \\\\rho a_1, \\\\ldots, a_k \\\\mid a_i \\\\in PE, i \\\"1, \\\\ldots, k, \\\\phi \\\\rho a_1, \\\\ldots, a_k \\\\] is True in \\\\( KG \\\\).\\n\\nDefinition 8 (Disjunctive Normal Form (DNF)).\\n\\nFor any existential formula \\\\( \\\\phi \\\\rho y_1, \\\\ldots, y_k \\\\), it can be converted to the Disjunctive normal form as shown below:\\n\\n\\\\[ \\\\phi \\\\rho y_1, \\\\ldots, y_k \\\\rho \\\\gamma_1 \\\\rho y_1, \\\\ldots, y_k \\\\rho \\\\ldots \\\\rho \\\\gamma_m \\\\rho y_1, \\\\ldots, y_k \\\\rho | \\\\rho \\\\gamma_i \\\\rho y_1, \\\\ldots, y_k \\\\rho \\\\rho x_1, \\\\ldots, x_n. \\\\rho | \\\\rho \\\\gamma_i \\\\rho y_1, \\\\ldots, y_k \\\\rho = \\\\rho x_1, \\\\ldots, x_n. \\\\rho \\\\]\\n\\nwhere \\\\( \\\\rho_{ij} \\\\) is either an atomic formula or its negation, \\\\( x_i \\\\) is called an existential variable.\\n\\nDNF form has a strong property that\\n\\n\\\\[ A_{r\\\\phi} y_1, \\\\ldots, y_k \\\\rho \\\\gamma_1 \\\\rho y_1, \\\\ldots, y_k \\\\rho \\\\ldots \\\\rho \\\\gamma_m \\\\rho y_1, \\\\ldots, y_k \\\\rho = Y \\\\gamma_i \\\\rho y_1, \\\\ldots, y_k \\\\rho \\\\rho x_1, \\\\ldots, x_n. \\\\rho \\\\]\\n\\nwhich allows us to only consider conjunctive formulas \\\\( \\\\gamma_i \\\\) and then aggregate those answers to retrieve the final answers. This practical technique has been used in many previous research [22, 27]. Therefore, we only discuss conjunctive formulas in the rest of this paper.\\n\\n2.2 Constraint satisfaction problem for EFO queries\\n\\nFormally, a Constraint Satisfaction Problem (CSP) \\\\( P \\\\) can be represented by a triple \\\\( P \\\\rho X, D, C \\\\rho \\\\) where\\n\\n\\\\( X \\\\rho v_1, \\\\ldots, v_n \\\\) is an \\\\( n \\\\)-tuple of variables,\\n\\n\\\\( D \\\\rho D_1, \\\\ldots, D_n \\\\) is the corresponding \\\\( n \\\\)-tuple of domains,\\n\\n\\\\( C \\\\rho C_1, \\\\ldots, C_t \\\\) is \\\\( t \\\\)-tuple constraint, each constraint \\\\( C_i \\\\) is a pair of \\\\( S_i, R_{S_i} \\\\) where\\n\\n\\\\( S_i \\\\) is a set of variables \\\\( v_{i_{j_u}} \\\\) and \\\\( R_{S_i} \\\\) is the constraint over those variables [29].\\n\\nHistorically, there are strong parallels between CSP and conjunctive queries in knowledge bases [10, 17]. The terms correspond to the variable set \\\\( X \\\\). The domain \\\\( D_i \\\\) of a constant entity contains only itself, while it is the whole entity set \\\\( E \\\\) for other variables. Each constraint \\\\( C_i \\\\) is binary that is induced by an atomic formula or its negation, for example, for an atomic formula \\\\( r \\\\rho h, t \\\\rho \\\\), we have\\n\\n\\\\( S_i = h, t \\\\rho u \\\\) and \\\\( R_{S_i} = \\\\rho h, t \\\\rho | h, t \\\\rho P \\\\rho E, p h, r, t \\\\rho P \\\\rho KG \\\\).\\n\\nFinally, by the definition of existential quantifier, we only consider the answer of free variables, rather than tracking all terms within the existential formulas.\\n\\nDefinition 9 (CSP answer of conjunctive formula).\\n\\nFor a conjunctive formula \\\\( \\\\gamma \\\\) in Equation 2 with \\\\( k \\\\) free variables and \\\\( n \\\\) existential variables, the answer set, \\\\( A \\\\), of it formulated as CSP instance is:\\n\\n\\\\[ A_{r\\\\gamma} y_1, \\\\ldots, y_k \\\\rho a_1, \\\\ldots, a_k \\\\rho \\\\gamma_1 \\\\rho y_1, \\\\ldots, y_k \\\\rho \\\\ldots \\\\rho \\\\gamma_m \\\\rho y_1, \\\\ldots, y_k \\\\rho, \\\\]\"}"}
{"id": "r8PnfcWQol", "page_num": 4, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 2: Left: Example of trivial abstract query graph, in the upper left graph, the x\u2081 is redundant violating Assumption 13, in the bottom left graph, answers for the whole query can be decomposed to answer two free variables y\u2081 and y\u2082 alone, violating Assumption 14. Right: Example of new query graph that is not included in previous benchmark [36] even though it can be represented by operator-tree. The representation of query graph follows Figure 1.\\n\\n2.3 The representation of existential formula\\n\\nTo give an explicit representation of existential formula, operator tree [13] was proposed to represent a formula, where each node represents the answer set for a sub-query, and the logic operators in it naturally represent set operations. This method allows for the recursive computation from constant entity to the final answer set in a bottom-up manner [28]. We also provide full details of the operator tree and tree-form query in Appendix C. However, this representation method is inherently directed, acyclic, and simple, therefore more recent research breaks these constraints by being bidirectional [21, 37] or being cyclic or multi graph [39]. To meet these new requirements, they propose to represent the formula by the query graph [39], which inherits the convention of constraint network in representing CSP instance. We utilize this design and further extend it to represent EFO formula that contains multiple free variables. We provide the illustration and comparison of the operator tree and the query graph in Figure 1, where we show the strong expressiveness of the query graph. We also provide the formal definition of query graph as follows:\\n\\nDefinition 10 (Query graph). Let \\\\( \\\\gamma \\\\) be a conjunctive formula in equation 2, its query graph is defined by \\\\( G_{\\\\gamma} \\\\), where an atomic formula \\\\( r_{p h, t q} \\\\) in \\\\( \\\\gamma \\\\) corresponds to \\\\( p_{h, r, t, T q} \\\\) and \\\\( r_{p h, t q} \\\\) corresponds to \\\\( p_{h, r, t, F q} \\\\). Therefore, any conjunctive formulas can be represented by a query graph, in the rest of the paper, we use query graphs and conjunctive formulas interchangeably.\\n\\n3 The combinatorial space of EFO \\\\( k \\\\) queries\\n\\nAlthough previous research has given a systematic investigation in the combinatorial space of operator trees [36], the combinatorial space of the query graph is much more challenging due to the extremely large search space and the lack of explicit recursive formulation. To tackle this issue on a strong theoretical background, we put forward additional assumptions to exclude trivial query graphs. Such assumptions or restrictions also exist in the previous dataset and benchmark [28, 36]. Specifically, we propose to split the task of generating data into two levels, the abstract level, and the grounded level. At the abstract level, we create abstract query graph, at the grounded level, we provide the abstract query graph with the relation and constant and instantiate it as a query graph. In this section, we elaborate on how we investigate the scope of the nontrivial EFO \\\\( k \\\\) query of interest step by step.\\n\\n3.1 Nontrivial abstract query graph of EFO \\\\( k \\\\)\\n\\nThe abstract query graph is the ungrounded query graph without information of certain knowledge graphs, and we give an example in Figure 3.\\n\\nDefinition 11 (Abstract query graph). The abstract query graph \\\\( G_{\\\\gamma} \\\\) is a directed graph with three node types, \\\\( Constant Entity \\\\), \\\\( Existential Variable \\\\), \\\\( Free Variable \\\\), and two edge types, \\\\( positive \\\\), \\\\( negative \\\\). The \\\\( V \\\\) is the set of nodes, \\\\( E \\\\) is the set of directed edges, \\\\( f \\\\) is the function maps node to node type, \\\\( g \\\\) is the function maps edge to edge type.\"}"}
{"id": "r8PnfcWQol", "page_num": 5, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"We propose two assumptions of the abstract query graph as follows:\\n\\nAssumption 13 (No redundancy).\\nFor an abstract query graph $G$, there is not a subgraph $G_s$ such that for every grounding $I$, $A_{r I} p G_{qs}$.\\n\\nAssumption 14 (No decomposition).\\nFor an abstract query graph $G$, there are no such two subgraphs $G_1, G_2$, satisfying that $G_1, G_2 \\\\sqsubseteq G$, such that for every instantiation $I$, $A_{r I} p G_{qs} \\\\pitchfork A_{r I} p G_1_{qs} \\\\sqcup A_{r I} p G_2_{qs}$, where the $\\\\sqcup$ represents the cartesian product.\\n\\nThe assumption 14 inherits the idea of the structural decomposition technique in CSP [11], which allows for solving a CSP instance by solving several sub-problems and combining the answer together based on topology property. Additionally, meeting these two assumptions in the grounded query graph is extremely computationally costly thus we avoid it in practice.\\n\\nWe provide some easy examples to be excluded for violating the assumptions above in Figure 2.\\n\\n3.2 Nontrivial query graph of EFO\\n\\nSimilarly, we propose two assumptions on the query graph.\\n\\nAssumption 15 (Meaningful negation).\\nFor any negative edge $e$ in query graph $G$, we require removing it results in different CSP answers: $A_{r G \\\\neg e} s \\\\pitchfork A_{r G} s$.\\n\\nAssumption 15 treats negation separately because of the fact that for any $KG$, any relation $r \\\\in R$, there is $|t_{p h, t q}|_{h, t} \\\\in E$, $p_{h, r, t q} \\\\in KG \\\\cup |E|$, which means that the constraint induced by the negation of an atomic formula is much less \\\"strict\\\" than the one induced by a positive atomic formula.\\n\\nAssumption 16 (Appropriate answer size).\\nThere is a constant $M \\\\in |E|$ to bound the candidate set for each free variable $y_i$ in $G$, such that for any $i$, $|t_{a_1, \\\\ldots, a_i, \\\\ldots, a_k}|_{a_1, \\\\ldots, a_i, \\\\ldots, a_k} \\\\leq M$.\\n\\nWe note the Assumption 16 extends the \\\"bounded negation\\\" assumption in the previous dataset [28, 36]. We give an example \\\"Find a city that is located in Europe and is the capital of a country that has not held the Olympics\\\" in Figure 2, where the candidate set of $x_1$ is in fact bounded by its relation with the $y_1$ variable but not from the bottom \\\"Olympics\\\" constant, hence, this query is excluded in their dataset due to the directionality of operator tree.\\n\\nOverall, the scope of the formula investigated in this paper surpasses the previous EFO-1-QA benchmark because of: (1). We include the EFO formula with multiple free variables for the first time; (2). We include the whole family of EFO query, many of them can not be represented by operator tree; (3) Our assumption is more systematic than previous ones as shown by the example in Figure 2. More details are offered in Appendix D.3.\\n\\n4 Framework\\n\\nWe develop a versatile framework that supports five key functionalities fundamental to the whole CQA task: (1) Enumeration of nontrivial abstract query graphs as discussed in Section 3; (2) Sample grounding for the abstract query graph; (3) Compute answer for any query graph efficiently; (4) Support implementation of existing CQA models; (5) Conduct evaluation including newly introduced EFO queries with multiple free variables. We explain each functionality in the following. An illustration of the first three functionalities is given in Figure 3, where we show how each functionality cooperates to help CQA tasks. We note that preprocessing allows us to extend our framework to more avant-garde settings, like inductive settings or graphs with numerics, more discussions in Appendix G.\\n\\n4.1 Enumerate abstract query graph\\n\\nAs discussed in Section 3, we are able to abide by those assumptions as well as enumerate all possible query graphs within a given search space where certain parameters, including the number...\"}"}
{"id": "r8PnfcWQol", "page_num": 6, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"Figure 3: Illustration of the all functionalities of our framework. Real-world KG is preprocessed and fed into our pipeline, which contains the whole process of data generation and supports end-to-end machine learning as well as evaluation. The origin of the KG picture is in Appendix I.\\n\\n4.2 Ground abstract query graph\\n\\nTo ground an abstract query graph $G$ and comply with the assumption 15, we split the abstract query graph into two parts, the positive part and the negative part, $G^P$ and $G^N$. Then the grounding process is also split into two steps: 1. Sample grounding for the positive subgraph $G^P$ and compute its answer, 2. Ground the $G^N$ to decrease the answer got in the first step. Details in Appendix D.2.\\n\\nFinally, to fulfill the assumption 16, we follow the previous practice of manually filtering out queries that have more than 100 answers [28, 36], as we have introduced the $\\\\text{EFO}_k$ queries.\\n\\n4.3 Answer for existential formula\\n\\nAs illustrated in Section 2.2, the answer to an existential formula can be solved by a CSP solver, however, we also show in Definition 9 that solve it as CSP leads to huge computation costs. Thus, we develop our own algorithm following the standard solving technique of CSP, which ensures consistency conditions in the first step, and do the backtracking to get the final answers in the second step. Finally, we select part of our sampled queries and double-check it with the CSP solver https://github.com/python-constraint/python-constraint.\\n\\n4.4 Learning-based methods\\n\\nAs the query graph is an extension to the operator tree regarding the express ability to existential formulas, we are able to reproduce CQA models that are initially implemented by the operator tree in our new framework. Specifically, since the operator tree is directed and acyclic, we compute its topology ordering that allows for step-by-step computation in the query graph. This algorithm is illustrated in detail in the Appendix F. Therefore, our pipeline is backward compatible.\\n\\nConversely, for the newly proposed models that are based on query graphs, the original operator tree framework is not able to implement them, while our framework is powerful enough. We have therefore clearly shown that the query graph representation is more powerful than the previous operator tree and is able to support arbitrary existential formulas as explained in Section 2.3.\\n\\n4.5 Evaluation protocol\\n\\nAs we have mentioned in Section 2.1, there is an observed knowledge graph $KG_o$ and a full knowledge graph $KG$. Thus, there is a set of observed answers $A_o$ and a set of full answers $A$ correspondingly.\\n\\nSince the goal of CQA is to tackle the challenge of incompleteness, it has been a common practice to\"}"}
{"id": "r8PnfcWQol", "page_num": 7, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 1: HIT@10 scores(%) for inferring queries with one free variable on FB15k-237. We denote $e$, $c$ as the number of existential variables, constant entities correspondingly. SDAG represents Simple Directed Acyclic Graph, Multi for multigraph, and Cyclic for cyclic graph. A VG.($c$) and A VG.($e$) is the average score of queries with the number of constant entities / existential variables fixed.\\n\\n| Model  | $c$ | $e$ | 0 | 1 | 2 | A VG.($c$) | A VG.($e$) | SDAG | Multi | SDAG | Multi | Cyclic |\\n|--------|-----|-----|---|---|---|------------|------------|------|-------|------|-------|--------|\\n| BetaE  | 1   |     | 31.4 | 33.0 | 22.3 | 17.7 | 30.7 | 22.1 |       |      |       |        |\\n|        |     |     | 36.42 | 57.2 | 36.2 | 35.5 | 29.3 | 29.4 | 45.3  | 32.5 |       |        |\\n|        | 3   |     | 80.0 | 53.1 | 53.6 | 38.2 | 37.8 | 58.2 | 42.1  |      |       |        |\\n|        |     |     | 59.3 | 43.8 | 40.6 | 33.8 | 32.7 | 49.3 |       |      |       |        |\\n| LogicE | 1   |     | 34.4 | 34.9 | 23.0 | 21.4 | 17.4 | 30.3 | 22.4  |      |       |        |\\n|        |     |     | 36.72 | 60.0 | 38.4 | 36.8 | 29.8 | 29.3 | 45.3  | 33.0 |       |        |\\n|        | 3   |     | 83.0 | 55.5 | 55.5 | 38.5 | 37.8 | 57.8 | 42.4  |      |       |        |\\n|        |     |     | 62.2 | 46.0 | 42.0 | 34.2 | 32.6 | 49.1 |       |      |       |        |\\n| ConE   | 1   |     | 34.9 | 35.4 | 23.6 | 21.8 | 18.4 | 34.2 | 23.5  |      |       |        |\\n|        |     |     | 39.02 | 61.0 | 39.1 | 38.4 | 32.0 | 31.5 | 50.2  | 35.2 |       |        |\\n|        | 3   |     | 84.8 | 56.7 | 57.1 | 41.1 | 40.0 | 63.4 | 44.9  |      |       |        |\\n|        |     |     | 63.4 | 47.0 | 43.5 | 36.5 | 34.7 | 54.1 |       |      |       |        |\\n| CQD    | 1   |     | 39.0 | 34.2 | 17.6 | 17.4 | 12.7 | 28.7 | 18.7  |      |       |        |\\n|        |     |     | 35.92 | 50.7 | 33.8 | 33.6 | 28.4 | 28.4 | 45.7  | 31.4 |       |        |\\n|        | 3   |     | 58.4 | 49.6 | 52.4 | 39.3 | 39.1 | 60.4 | 42.6  |      |       |        |\\n|        |     |     | 50.7 | 41.4 | 38.4 | 33.8 | 32.4 | 50.2 |       |      |       |        |\\n| LMPNN  | 1   |     | 38.6 | 37.8 | 21.8 | 22.9 | 17.8 | 31.7 | 23.2  |      |       |        |\\n|        |     |     | 35.82 | 62.2 | 40.2 | 35.0 | 30.8 | 28.1 | 44.4  | 32.5 |       |        |\\n|        | 3   |     | 86.6 | 56.9 | 51.9 | 38.3 | 35.3 | 55.8 | 40.8  |      |       |        |\\n|        |     |     | 65.4 | 47.8 | 39.6 | 34.5 | 30.8 | 48.0 |       |      |       |        |\\n| FIT    | 1   |     | 38.7 | 42.7 | 32.5 | 26.1 | 22.5 | 41.5 | 28.8  |      |       |        |\\n|        |     |     | 47.0 | 65.5 | 47.7 | 48.2 | 39.7 | 40.1 | 56.5  | 43.4 |       |        |\\n|        | 3   |     | 84.2 | 63.9 | 63.5 | 50.5 | 50.4 | 63.5 | 53.6  |      |       |        |\\n|        |     |     | 65.8 | 54.7 | 51.5 | 44.9 | 43.7 | 57.5 |       |      |       |        |\\n\\nevaluate CQA models by the \\\"hard\\\" answers $A_h$ and $A_{ho}$ [26, 27]. However, to the best of our knowledge, there has not been a systematic evaluation protocol for EFO$_k$ queries, thus we leverage this idea and propose three types of different metrics to fill the research gap in the area of evaluation of queries with multiple free variables, and thus have combinatorial answers.\\n\\nMarginal. For any free variable $y_i$, its full answer is $A_{y_i}$. The observed answer of it $A_{y_i}o$ is defined similarly. This is termed \\\"solution projection\\\" in CSP theory [12] to evaluate whether the locally retrieved answer can be extended to an answer for the whole problem.\\n\\nThen, we rank the hard answer $A_{y_i}h$ against those non-answers $E_{y_i}h$ and $A_{y_i}o$ to compute standard metrics like MRR, HIT@K for every free variable. Finally, the metric on the whole query graph is taken as the average of the metric on all free variables. We note that this metric is an extension of the previous design [20]. However, this metric has the inherent drawback that it fails to evaluate the combinatorial answer by the $k$-length tuple and thus fails to find the correspondence among free variables.\\n\\nMultiply. Because of the limitation of the marginal metric discussed above, we propose to evaluate the combinatorial answer by each $k$-length tuple $p_{a_1}, \\\\ldots, a_k q$ in the hard answer set $A_h$. Specifically, we rank each $a_i$ in the corresponding node $y_i$ the same as the marginal metric. Then, we propose the HIT$_n@k$ metric, it is 1 if all $a_i$ is ranked in the top $n$ in the corresponding node $y_i$, and 0 otherwise.\\n\\nJoint. Finally, we note these metrics above are not the standard way of evaluation, which is based on a joint ranking for all the $E_k$ combinations of the entire search space. We propose to estimate the joint ranking in a closed form given certain assumptions, see Appendix E for the proof and details.\"}"}
{"id": "r8PnfcWQol", "page_num": 8, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 4: Relative performance of the six representative CQA models in queries with one free variable, where the ranking of query types is determined by the average HIT@10 score. A Gaussian filter with sigma=1 is added to smooth the curve.\\n\\nThen, we conduct experiments on our new EFO \\\\( k \\\\)-CQA dataset with six representative CQA models including BetaE [28], LogicE [24], and ConE [40], which are built on the operator tree, CQD [2], LMPNN [35], and FIT [39] which are built on query graph. The experiments are conducted in two parts, (1). the queries with one free variable, specifically, including those that cannot be represented by an operator tree; (2). the queries that contain multiple free variables.\\n\\nThe parameters and the generation process, as well as its statistics, are detailed in Appendix D.4, where we also provide a dataset constructed in inductive settings. However, we mainly focus on transductive settings in the main paper since there are very few inductive models to benchmark. We have made some adaptations to the implementation of CQA models, allowing them to infer EFO \\\\( k \\\\) queries, full detail in Appendix F. The experiment is conducted on a standard KG FB15k-237 [32], additional experiments on other standard KGs FB15k and NELL are presented in Appendix H.\\n\\n5.2 Benchmark results for \\\\( k \\\\) \\\"\\n\\nBecause of the great number of abstract query graphs, we follow previous work [36] to group query graphs by three factors: (1). the number of constant entities; (2). the number of existential variables, and (3). the topology of the query graph. The result is shown in Table 1 and Figure 4.\\n\\nStructure analysis. Firstly, we find a clear monotonic trend that adding constant entities makes a query easier while adding existential variables makes a query harder, which the previous research [36] fails to uncover. Besides, we are the first to consider the topology of query graphs: when the number of constants and existential variables is fixed, we have found the originally investigated queries that correspond to Simple Directed Acyclic Graphs (SDAG) are generally easier than the multigraphs ones but harder than the cyclic graph ones. This is an intriguing result that greatly deviates from traditional CSP theory which finds that the cyclic graph is NP-complete, while the acyclic graph is tractable [6]. We conjecture that the cyclic graph contains one more constraint than SDAG that serves as a source of information for CQA models, while the multigraph tightens an existing constraint and thus makes the query harder.\\n\\nModel analysis. For models that are built on operator tree, including BetaE, LogicE, and ConE, their relative performance is steady among all breakdowns and is consistent with their reported score in the original dataset [28]. However, for models that are built on query graphs, including CQD, LMPNN, and FIT, we found that LMPNN performs generally better than CQD in SDAG, but falls behind CQD in multigraphs and cyclic graphs. We assume the reason is that LMPNN requires training while CQD does not, however, the original dataset are biased which only considers SDAG, leading to the result.\"}"}
{"id": "r8PnfcWQol", "page_num": 9, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 2: HIT@10 scores(%) of three different types for answering queries with two free variables on FB15k-237. The constant number is fixed to be two. \\n\\n\\\\[ e \\\\] is the number of existential variables. The SDAG, Multi, and Cyclic are the same as Table 1.\\n\\n| Model   | Type | e | HIT@10 |\\n|---------|------|---|--------|\\n|         |      | 0 |        |\\n| BetaE   | Marginal | 54.5 | 50.2 |\\n|         | Multiply | 27.3 | 22.4 |\\n|         | Joint | 6.3 | 5.4 |\\n| LogicE  | Marginal | 58.2 | 50.9 |\\n|         | Multiply | 32.1 | 23.1 |\\n|         | Joint | 6.8 | 6.0 |\\n| ConE    | Marginal | 50.4 | 46.5 |\\n|         | Multiply | 33.7 | 25.2 |\\n|         | Joint | 6.7 | 6.4 |\\n| CQD     | Marginal | 50.4 | 46.5 |\\n|         | Multiply | 28.9 | 23.4 |\\n|         | Joint | 8.0 | 8.0 |\\n| LMPNN   | Marginal | 58.4 | 51.1 |\\n|         | Multiply | 35.0 | 26.7 |\\n|         | Joint | 7.6 | 7.5 |\\n| FIT     | Marginal | 64.3 | 61.0 |\\n|         | Multiply | 39.7 | 32.2 |\\n|         | Joint | 7.4 | 9.0 |\\n\\nthat LMPNN doesn't generalize well to the unseen tasks with different topology property. We expect future CQA models may use our framework to address this issue and gain better generalization. \\n\\nMoreover, by the detailed observation in Figure 4, we plot two boxes. In the red box, we find that even the worst model and the best model have pretty similar performance in these easiest queries despite that they may differ greatly in other queries. In the black box, we note that CQD [2], though designed in a rather general form, is pretty unstable when comes to empirical evaluation, as it has a clear downward curve and deviates from other model's performance enormously in most difficult query types. Therefore, though its performance is better than LMPNN on average as reported in Table 1, its unsteady performance suggests its inherent weakness, especially when the users are risk-sensitive and desire a trustworthy machine-learning model that does not crash in extreme cases [33]. We note FIT is designed to infer all EFO \\\\( k \\\\) queries and is indeed able to outperform other models in almost all breakdowns, however, its performance comes with the price of computational cost, and face challenges in cyclic graph where it degenerates to enumeration: we further explain in Appendix F.\\n\\n5.3 Benchmark results for \\\\( k = 2 \\\\)\\n\\nAs we have explained in Section 4.5, we propose three kinds of metrics, marginal ones, multiply ones, and joint ones, from easy to hard, to evaluate the performance of a model in the scenario of multiple variables. The evaluation result is shown in Table 2. As the effect of the number of constant variables is quite clear, we remove it and add the metrics based on HIT@10 as the new factor. For the impact regarding the number of existential variables and the topology property of the query graph, we find the result is similar to Table 1, which may be explained by the fact that those models are all initially designed to infer queries with one free variable. For the three metrics we have proposed, we have identified a clear difficulty difference among them though they generally show similar trends. The scores of joint HIT@10 are pretty low, indicating the great hardness of answering queries with multiple variables. Moreover, we have found that FIT falls behind other models in some breakdowns which are mostly cyclic graphs, corroborating our discussion in Section 5.2. We offer more experiment results and further discussion in Appendix H.\\n\\n6 Conclusion\\n\\nIn this paper, we make a thorough investigation of the family of EFO \\\\( k \\\\) formulas based on a strong theoretical background. We then present a new powerful framework that supports several functionalities essential to CQA task, and build the EFO \\\\( k \\\\)-CQA dataset that greatly extends the previous datasets. Our evaluation result brings new empirical findings and reflects the biased selection in the previous datasets impairs the performance of CQA models, emphasizing the contribution of our work.\"}"}
{"id": "r8PnfcWQol", "page_num": 10, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"[1] Dimitrios Alivanistos, Max Berrendorf, Michael Cochez, and Mikhail Galkin. Query Embedding on Hyper-relational Knowledge Graphs, September 2022. arXiv:2106.08166 [cs].\\n\\n[2] Erik Arakelyan, Daniel Daza, Pasquale Minervini, and Michael Cochez. Complex Query Answering with Neural Link Predictors. In International Conference on Learning Representations, 2020.\\n\\n[3] Jiaxin Bai, Zihao Wang, Hongming Zhang, and Yangqiu Song. Query2Particles: Knowledge Graph Reasoning with Particle Embeddings. In Findings of the Association for Computational Linguistics: NAACL 2022, pages 2703\u20132714, 2022.\\n\\n[4] Yushi Bai, Xin Lv, Juanzi Li, and Lei Hou. Answering Complex Logical Queries on Knowledge Graphs via Query Computation Tree Optimization. In Proceedings of the 40th International Conference on Machine Learning, pages 1472\u20131491. PMLR, July 2023. ISSN: 2640-3498.\\n\\n[5] Antoine Bordes, Nicolas Usunier, Alberto Garcia-Duran, Jason Weston, and Oksana Yakhnenko. Translating Embeddings for Modeling Multi-relational Data. In Advances in Neural Information Processing Systems, volume 26. Curran Associates, Inc., 2013.\\n\\n[6] Cl\u00e9ment Carbonnel and Martin C Cooper. Tractability in constraint satisfaction problems: a survey. Constraints, 21(2):115\u2013144, 2016. Publisher: Springer.\\n\\n[7] Andrew Carlson, Justin Betteridge, Bryan Kisiel, Burr Settles, Estevam Hruschka, and Tom Mitchell. Toward an architecture for never-ending language learning. In Proceedings of the AAAI conference on artificial intelligence, volume 24, pages 1306\u20131313, 2010. Issue: 1.\\n\\n[8] Lisa Ehrlinger and Wolfram W\u00f6\u00df. Towards a definition of knowledge graphs. SEMANTiCS (Posters, Demos, SuCCESS), 48(1-4):2, 2016.\\n\\n[9] Michael Galkin, Zhaocheng Zhu, Hongyu Ren, and Jian Tang. Inductive logical query answering in knowledge graphs. Advances in Neural Information Processing Systems, 35:15230\u201315243, 2022.\\n\\n[10] Georg Gottlob, Nicola Leone, and Francesco Scarcello. Hypertree decompositions and tractable queries. In Proceedings of the eighteenth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems, pages 21\u201332, 1999.\\n\\n[11] Georg Gottlob, Nicola Leone, and Francesco Scarcello. A comparison of structural CSP decomposition methods. Artificial Intelligence, 124(2):243\u2013282, December 2000.\\n\\n[12] Gianluigi Greco and Francesco Scarcello. On The Power of Tree Projections: Structural Tractability of Enumerating CSP Solutions. Constraints, 18(1):38\u201374, January 2013. arXiv:1005.1567 [cs].\\n\\n[13] Will Hamilton, Payal Bajaj, Marinka Zitnik, Dan Jurafsky, and Jure Leskovec. Embedding logical queries on knowledge graphs. Advances in neural information processing systems, 31, 2018.\\n\\n[14] Zhiwei Hu, V\u00edctor Guti\u00e9rrez-Basulto, Zhiliang Xiang, Xiaoli Li, and Jeff Pan. Type-aware Embeddings for Multi-Hop Reasoning over Knowledge Graphs. May 2022.\\n\\n[15] Qian Huang, Hongyu Ren, and Jure Leskovec. Few-shot relational reasoning via connection subgraph pretraining. Advances in Neural Information Processing Systems, 35:6397\u20136409, 2022.\\n\\n[16] Zhen Jia, Soumajit Pramanik, Rishiraj Saha Roy, and Gerhard Weikum. Complex Temporal Question Answering on Knowledge Graphs. In Proceedings of the 30th ACM International Conference on Information & Knowledge Management, CIKM '21, pages 792\u2013802, New York, NY, USA, 2021. Association for Computing Machinery.\"}"}
{"id": "r8PnfcWQol", "page_num": 11, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"[10] Phokion G Kolaitis and Moshe Y Vardi. Conjunctive-query containment and constraint satisfaction. In Proceedings of the seventeenth ACM SIGACT-SIGMOD-SIGART symposium on Principles of database systems, pages 205\u2013213, 1998.\\n\\n[11] Jure Leskovec. Databases as Graphs: Predictive Queries for Declarative Machine Learning. In Proceedings of the 42nd ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS '23, page 1, New York, NY, USA, 2023. Association for Computing Machinery.\\n\\n[12] Leonid Libkin and Cristina Sirangelo. Open and Closed World Assumptions in Data Exchange. Description Logics, 477, 2009.\\n\\n[13] Lihui Liu, Boxin Du, Heng Ji, ChengXiang Zhai, and Hanghang Tong. Neural-Answering Logical Queries on Knowledge Graphs. In Proceedings of the 27th ACM SIGKDD Conference on Knowledge Discovery & Data Mining, pages 1087\u20131097, 2021.\\n\\n[14] Xiao Liu, Shiyu Zhao, Kai Su, Yukuo Cen, Jiezhong Qiu, Mengdi Zhang, Wei Wu, Yuxiao Dong, and Jie Tang. Mask and Reason: Pre-Training Knowledge Graph Transformers for Complex Logical Queries. In Proceedings of the 28th ACM SIGKDD Conference on Knowledge Discovery and Data Mining, pages 1120\u20131130, August 2022. arXiv:2208.07638 [cs].\\n\\n[15] Xiao Long, Liansheng Zhuang, Li Aodi, Shafei Wang, and Houqiang Li. Neural-based Mixture Probabilistic Query Embedding for Answering FOL queries on Knowledge Graphs. 2022.\\n\\n[16] Haoran Luo, Yuhao Yang, Gengxian Zhou, Yikai Guo, Tianyu Yao, Zichen Tang, Xueyuan Lin, Kaiyang Wan, and others. NQE: N-ary Query Embedding for Complex Query Answering over Hyper-relational Knowledge Graphs. arXiv preprint arXiv:2211.13469, 2022.\\n\\n[17] Francois Luus, Prithviraj Sen, Pavan Kapanipathi, Ryan Riegel, Ndivhuwo Makondo, Thabang Lebese, and Alexander Gray. Logic embeddings for complex query answering. arXiv preprint arXiv:2103.00418, 2021.\\n\\n[18] Meikel Poess and Chris Floyd. New TPC benchmarks for decision support and web commerce. ACM Sigmod Record, 29(4):64\u201371, 2000. Publisher: ACM New York, NY, USA.\\n\\n[19] H Ren, W Hu, and J Leskovec. Query2box: Reasoning Over Knowledge Graphs In Vector Space Using Box Embeddings. In International Conference on Learning Representations (ICLR), 2020.\\n\\n[20] Hongyu Ren, Mikhail Galkin, Michael Cochez, Zhaocheng Zhu, and Jure Leskovec. Neural Graph Reasoning: Complex Logical Query Answering Meets Graph Databases, March 2023. arXiv:2303.14617 [cs].\\n\\n[21] Hongyu Ren and Jure Leskovec. Beta embeddings for multi-hop logical reasoning in knowledge graphs. Advances in Neural Information Processing Systems, 33:19716\u201319726, 2020.\\n\\n[22] Francesca Rossi, Peter van Beek, and Toby Walsh. Handbook of Constraint Programming. Elsevier Science Inc., USA, 2006.\\n\\n[23] Apoorv Saxena, Soumen Chakrabarti, and Partha Talukdar. Question Answering Over Temporal Knowledge Graphs, June 2021. arXiv:2106.01515 [cs].\\n\\n[24] Fabian M Suchanek, Gjergji Kasneci, and Gerhard Weikum. Yago: a core of semantic knowledge. In Proceedings of the 16th international conference on World Wide Web, pages 697\u2013706, 2007.\\n\\n[25] Kristina Toutanova and Danqi Chen. Observed versus latent features for knowledge base and text inference. In Proceedings of the 3rd workshop on continuous vector space models and their compositionality, pages 57\u201366, 2015.\"}"}
{"id": "r8PnfcWQol", "page_num": 12, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Kush R. Varshney. Trustworthy machine learning and artificial intelligence. XRDS: Crossroads, The ACM Magazine for Students, 25(3):26\u201329, 2019.\\n\\nDenny Vrande\u010di\u0107 and Markus Kr\u00f6tzsch. Wikidata: a free collaborative knowledgebase. Communications of the ACM, 57(10):78\u201385, 2014. Publisher: ACM New York, NY, USA.\\n\\nZihao Wang, Yangqiu Song, Ginny Wong, and Simon See. Logical Message Passing Networks with One-hop Inference on Atomic Formulas. In The Eleventh International Conference on Learning Representations, 2023.\\n\\nZihao Wang, Hang Yin, and Yangqiu Song. Benchmarking the Combinatorial Generalizability of Complex Query Answering on Knowledge Graphs. Proceedings of the Neural Information Processing Systems Track on Datasets and Benchmarks, 1, December 2021.\\n\\nZihao Wang, Hang Yin, and Yangqiu Song. Logical Queries on Knowledge Graphs: Emerging Interface of Incomplete Relational Data. Data Engineering, page 3, 2022.\\n\\nZezhong Xu, Wen Zhang, Peng Ye, Hui Chen, and Huajun Chen. Neural-Symbolic Entangled Framework for Complex Query Answering, September 2022. arXiv:2209.08779 [cs].\\n\\nHang Yin, Zihao Wang, and Yangqiu Song. Rethinking existential first order queries and their inference on knowledge graphs. In The Twelfth International Conference on Learning Representations, 2024.\\n\\nZhanqiu Zhang, Jie Wang, Jiajun Chen, Shuiwang Ji, and Feng Wu. Cone: Cone embeddings for multi-hop reasoning over knowledge graphs. Advances in Neural Information Processing Systems, 34:19172\u201319183, 2021.\\n\\nTao Zhou, Jie Ren, Mat\u00fa\u0161 Medo, and Yi-Cheng Zhang. Bipartite network projection and personal recommendation. Physical review E, 76(4):046115, 2007. Publisher: APS.\\n\\nChecklist\\n\\n1. For all authors...\\n   (a) Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope? [Yes]\\n   (b) Did you describe the limitations of your work? [Yes] We can not handle queries with the universal quantifier, meaning that we can not cover all queries that have been proposed by previous dataset and benchmarks.\\n   (c) Did you discuss any potential negative societal impacts of your work? [Yes] We have discussed the possible negative social impact, see Appendix I.\\n   (d) Have you read the ethics review guidelines and ensured that your paper conforms to them? [Yes]\\n\\n2. If you are including theoretical results...\\n   (a) Did you state the full set of assumptions of all theoretical results? [Yes] Clear assumptions are made in Section 3 to define the scope of the query we investigate.\\n   (b) Did you include complete proofs of all theoretical results? [Yes] All the proofs are provided in Appendix D.1.\\n\\n3. If you ran experiments (e.g. for benchmarks)...\\n   (a) Did you include the code, data, and instructions needed to reproduce the main experimental results (either in the supplemental material or as a URL)? [Yes] We have given the link in the abstract.\\n   (b) Did you specify all the training details (e.g., data splits, hyperparameters, how they were chosen)? [Yes] This is in Appendix F.\"}"}
{"id": "r8PnfcWQol", "page_num": 13, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"A Related works\\n\\nAnswering complex queries on knowledge graphs differs from database query answering by being a data-driven task [37], where the incompleteness of the knowledge graph is addressed by methods that learn from data. Meanwhile, learning-based methods enable faster neural approximate solutions of symbolic query answering problems [27].\\n\\nThe prevailing way is query embedding, where the computational results are embedded and computed in the low-dimensional embedding space. Specifically, the query embedding over the set operator trees is the earliest proposed [13]. The supported set operators include projection [13], intersection [26], union and negation [28], and later on be improved by various designs [40, 3]. Such methods assume queries can be converted into the recursive execution of set operations, which imposes additional assumptions on the solvable class of queries [36]. These assumptions introduce additional limitations of such query embeddings.\\n\\nRecent advancements in query embedding methods adapt query graph representation and graph neural networks, supporting atomics [21] and negated atomics [35]. Query embedding on graphs bypasses the assumptions for queries [36]. Meanwhile, other search-based inference methods [2, 39] are rooted in fuzzy calculus and not subject to the query assumptions [36].\\n\\nThough many efforts have been made, the datasets of complex query answering are usually subject to the assumptions by set operator query embeddings [36]. Many other datasets are proposed to enable queries with additional features, see [27] for a comprehensive survey of datasets. However, only one small dataset proposed by [39] introduced queries and answers beyond such assumptions [36]. It is questionable that this small dataset is fair enough to justify the advantages claimed in advancement methods [35, 39] that aim at complex query answering. The dataset [39] is still far away from the systematical evaluation as proposed in [36] and EFOk-CQA proposed in this paper fills this gap.\\n\\nB Details of constraint satisfaction problem\\n\\nIn this section, we introduce the constraint satisfaction problem (CSP) again. One instance of CSP P can be represented by a triple P = (X, D, C) where X = (x1, ..., xn) is an n-tuple of variables,\"}"}
{"id": "r8PnfcWQol", "page_num": 14, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"D is the corresponding n-tuple of domains, meaning for each $i$, $x_i \\\\in D_i$. Then, $C_1, \\\\ldots, C_t$ is a t-tuple constraint, each constraint $C_i$ is a pair of $S_i, R_{S_i}$ where $S_i$ is called the scope of the constraint, meaning it is a set of variables $x_{i_1}, \\\\ldots, x_{i_k}$ and $R_{S_i}$ is the constraint over those variables [29], meaning that $R_{S_i}$ is a subset of the cartesian product of variables in $S_i$.\\n\\nThen the formulation of existential conjunctive formulas as CSP has already been discussed in Section 2.2. Additionally, for the negation of atomic formula $r$, $t$, we note the constraint $C$ is also binary with $S_{i}, R_{S_{i}}$ where $S_{i}$ is treated as two projections, $N$ represents set complement, and $I$ represents set intersection. Therefore, the embedding of the root representing the answer set can be computed based on these set operations in a bottom-up manner [28].\\n\\nFinally, it has been noticed that tree-form query is subject to structural traceability and only has polynomial time combined complexity for inference while the general EFO $k$ or even EFO 1 queries, is NP-complete, with detailed proof in [39]. Therefore, this result highlights the importance of investigating the EFO $k$ queries as it greatly extends the previous tree-form queries.\\n\\nD.1 Enumeration of the abstract query graphs\\n\\nWe first give a proposition of the property of abstract query graph:\\n\\n**Proposition 18.** For an abstract query graph $G$, if it conforms Assumption 13 and Assumption 14, then removing all constant entities in $G$ will lead to only one connected component and no edge is connected between two constant entities.\"}"}
{"id": "r8PnfcWQol", "page_num": 15, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 5: The four steps of enumerating the abstract query graphs. We note that the example and representation follow Figure 3.\\n\\nProof. We prove this by contradiction. If there is an edge (whether positive or negative) between constant entities, then this edge is redundant, violating Assumption 13. Then, if there is more than one connected component after removing all constant entities in $G$. Suppose one connected component has no free variable, then this part is a sentence and thus has a certain truth value, whether 0 or 1, which is redundant, violating Assumption 13. Then, we assume every connected component has at least one free variable, we assume there is $m$ connected component and we have:\\n\\n$$\\\\text{Node}_p G_q = \\\\bigcup_{i=1}^{m} \\\\text{Node}_p G_i q \\\\text{Node}_p G_c q$$\\n\\nwhere $m \\\\geq 1$, the $G_c$ is the set of constant entities and each $G_i$ is the connected component, we use $\\\\text{Node}_p G_q$ to denote the node set for a graph $G$. Then this equation describes the partition of the node set of the original $G$.\\n\\nThen, we construct $G_a = G_r Node_p G_1 q \\\\text{Node}_p G_c s$ and $G_b = G_r Node_p G_i q \\\\text{Node}_p G_c s$, where $G_r$ represents the induced graph. Then we naturally have that $A_r I_p G_s = A_r I_p G_a q \\\\text{Node}_p G_c s$, where $\\\\text{Node}_p G_c s$ represents the Cartesian product, violating Assumption 14.\\n\\nAdditionally, as mentioned in Appendix B, the negative constraint is less \\\"strict\\\", we formally put an additional assumption of the real knowledge graph as the following:\\n\\nAssumption 19. For any knowledge graph $KG$, with its entity set $E$ and relations set $R$, we assume it is somewhat sparse with regard to each relation, meaning: for any $r \\\\in R$, $|t_{a} \\\\in E| D_{b. p_{a, r, b}} q \\\\in KG$ or $p_{b, r, a} q \\\\in KG \\\\neq |E|$. Then we develop another proposition for the abstract query graph:\\n\\nProposition 20. With the knowledge graph conforming Assumption 19, for any node $u$ in the abstract query graph $G$, if $u$ is an existential variable or free variable, then it can not only connect with negative edges.\\n\\nProof. Suppose $u$ only connects to $m$ negative edge $e_1, \\\\ldots, e_m$. For any grounding $I$, we assume $I_{e_i} = r_i \\\\in R$. For each $r_i$, we construct its endpoint set $\\\\text{Endpoint}_p r_i q = t_{a \\\\in E | D_{b. p_{a, r, b}} p} \\\\in KG$ or $p_{b, r, a} q \\\\in KG$ by the assumption 19, we have $|\\\\text{Endpoint}_p r_i q| \\\\neq |E|$, then we have:\\n\\n$$|Y_{i=1}^{m} \\\\text{Endpoint}_p r_i q| \\\\leq \\\\sum_{i=1}^{m} |\\\\text{Endpoint}_p r_i q| \\\\neq |E|$$\\n\\nsince $m$ is small due to the size of the abstract query graph. Then we have two situations about the type of node $u$:\\n\\n1. If node $u$ is an existential variable.\\n\\nThen we construct a subgraph $G_s$ be the induced subgraph of $\\\\text{Node}_p G_q \\\\setminus u$, then for any possible grounding $I$, we prove that $A_r I_p G_s q = A_r I_p G_q q$, the right is clearly a subset of the left due to it...\"}"}
{"id": "r8PnfcWQol", "page_num": 16, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"contains more constraints, then we show every answer of the left is also an answer on the right, we\\nmerely need to give an appropriate candidate in the entity set for node $v$, and in fact, we choose any\\nentity in the set $E$ since it suffices to satisfies all constraints of node $u$, and we have proved that\\n$|E \\\\cap Y_m| > 0$.\\n\\n2. If node $u$ is a free variable.\\n\\nSimilarly, any entity in the set $E \\\\cap Y_m$ will be an answer for the node $u$, thus violating\\nthe Assumption 16.\\n\\nWe note the proposition 20 extends the previous requirement about negative queries, which is firstly\\nproposed in [28] and inherited and named as \\\"bounded negation\\\" in [36], the \\\"bounded negation\\\"\\nrequires the negation operator should be followed by the intersection operator in the operator tree.\\nObviously, the abstract query graph that conforms to \\\"bounded negation\\\" will also conform to the\\nrequirement in Proposition 20. A vivid example is offered in Figure 2.\\n\\nFinally, we make the assumption of the distance to the free variable of the query graph:\\nAssumption 21. There is a constant $d$, such that for every node $u$ in the abstract query graph $G$, it\\ncan find a free variable in its $d$-hop neighbor.\\nWe have this assumption to exclude the extremely long-path queries.\\n\\nEquipped with the propositions and assumptions above, we explore the combinatorial space of the\\nabstract query graph given certain hyperparameters, including: the max number of free variables,\\nmax number of existential variables, max number of constant entities, max number of all nodes, max\\nnumber of all edges, max number of edges surpassing the number of nodes, max number of negative\\nedge, max distance to the free variable. In practice, these numbers are set to be: 2, 2, 3, 6, 6, 0, 1, 3.\\nWe note that the max number of edges surpassing the number of nodes is set to 0, which means that\\nthe query graph can at most have one more edge than a simple tree, thus, we exclude those query\\ngraphs that are both cyclic graphs and multigraphs, making our categorization and discussion in the\\nexperiments in Section 5.2 and Section 5.3 much more straightforward and clear.\\n\\nThen, we create the abstract query graph by the following steps, which is a graph with three types of\\nnodes and two kinds of edges:\\n1. First, create a simple connected graph $G_1$ with two types of nodes, the existential variable\\nand the free variable, and one type of edge, the positive edge.\\n2. We add additional edges to the simple graph $G_1$ and make it a multigraph $G_2$.\\n3. Then, the constant variable is added to the graph $G_2$, In this step, we make sure not too long\\nexistential leaves. The result is graph $G_3$.\\n4. Finally, random edges in $G_3$ are replaced by the negation edge, and we get the final abstract\\nquery graph $G_4$.\\n\\nIn this way, all possible query graphs within a certain combinatorial space are enumerated, and finally,\\nwe filter duplicated graphs with the help of the graph isomorphism algorithm. We give an example to\\nillustrate the four-step construction of an abstract query graph in Figure 5.\\n\\nD.2 Ground abstract query graph with meaningful negation\\nTo fulfill the Assumption 15 as discussed in Section 4.2, for an abstract query graph $G = pV, E, f, g q$,\\nwe have two steps: (1). Sample grounding for the positive subgraph $G_p$ and compute its answer (2).\\nGround the $G$ to decrease the answer got in the first step. Then we define positive subgraph $G_p$ to\\nbe defined as such, its edge set $E_1$ = $e | g_p e q$ positive $u$, its node set $V_1$ = $u | u P V, D e P 1$.\"}"}
{"id": "r8PnfcWQol", "page_num": 17, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 6: Illustration of the comparison between the EFO\\\\textsuperscript{k}-CQA dataset (navy blue box) and the previous dataset (three yellow boxes), where the BetaE and EFO\\\\textsuperscript{1}-QA aim to investigate the tree form query, explained in Appendix C, while the FIT dataset aims to investigate EFO\\\\textsuperscript{1} query that is not tree form. FIT is not a subset of EFO\\\\textsuperscript{k}-CQA because its \u201c3pm\u201d query is not included in EFO\\\\textsuperscript{k}.\\n\\nThen we sample the grounding for the positive subgraph $G_p$, we also compute the CSP answer $A_p$ for this subgraph. Then we ground what is left in the positive subgraph, we split each negative edge in $E'$ into two categories:\\n\\n1. This edge $e$ connects two nodes $u, v$, and $u, v \\\\in V_1$.\\n   In this case, we sample the relation $r$ to be the grounding of $e$ such that it negates some of the answers in $A_p$.\\n\\n2. This edge $e$ connects two nodes $u, v$, where $u \\\\in V_1$, while $v \\\\in \\\\overline{V}_1$.\\n   In this case, we sample the relation $r$ for $e$ and entity $a$ for $v$ such that they negate some answer in $A_p$, we note we only need to consider the possible candidates for node $u$ and it is quite efficient.\\n\\nWe note that there is no possibility that neither of the endpoints is in $V_1$ because as we have discussed above, this means that both nodes are constant entities, but in Proposition 18 we have asserted that no edge is connected between two entities.\\n\\nD.3 The comparison to previous benchmark\\nTo give an intuitive comparison of our EFO\\\\textsuperscript{k}-CQA dataset against those previous datasets and benchmark, including the BetaE dataset [28], the EFO\\\\textsuperscript{1}-QA benchmark [36] that extends BetaE dataset, and the FIT dataset [39] that explores 10 more new query types, we offer a new figure in Figure 6. It can be clearly observed that EFO\\\\textsuperscript{1}-QA covers the BetaE dataset and has provided a quite systematic investigation in tree form query, while FIT deviates from them and studies ten new query types that are in EFO\\\\textsuperscript{1} but not tree form. As discussed in Section 3, the scope of the formula investigated in our EFO\\\\textsuperscript{k}-CQA dataset surpasses the previous EFO\\\\textsuperscript{1}-QA benchmark and FIT dataset because of three reasons: (1). We include the EFO\\\\textsuperscript{k} formula with multiple free variables that has never been investigated (the bottom part of...\"}"}
{"id": "r8PnfcWQol", "page_num": 18, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 3: The number of abstract query graphs with one free variable. We denote \\\\( e \\\\) as the number of existential variables and \\\\( c \\\\) as the number of constant entities. SDAG represents the Simple Directed Acyclic Graph, Multi for multigraph, and Cyclic for the cyclic graph. \\\\( \\\\text{Sum.}(c) \\\\) and \\\\( \\\\text{Sum.}(e) \\\\) is the total number of queries with the number of constant entities / existential variables fixed.\\n\\n| \\\\( c \\\\) | \\\\( e \\\\) | Sum.\\\\((c)\\\\) | SDAG | SDAG | Multi | SDAG | Multi | Cyclic | Sum.\\\\((e)\\\\) |\\n|---|---|---|---|---|---|---|---|---|---|\\n| 1 | 1 | 2 | 4 | 4 | 16 | 4 | 31 |\\n| 2 | 2 | 6 | 6 | 20 | 40 | 8 | 82 |\\n| 3 | 2 | 8 | 8 | 36 | 72 | 12 | 138 |\\n\\nD.4 EFO\\\\(_k\\\\)-CQA statistics\\n\\nThe statistics of our EFO\\\\(_k\\\\)-CQA dataset are shown in Table 3 and Table 4, they show the statistics of our abstract query graph by their topology property, the statistics are split into the situation that the number of free variable \\\\( k = 1 \\\\) and the number of free variable \\\\( k = 2 \\\\), correspondingly. We note abstract query graphs with seven nodes have been excluded as the setting of hyperparameters discussed in Appendix D.1, we make these restrictions to control the quadratic growth in the number of abstract query graphs.\\n\\nFinally, in FB15k-237, we sample 1000 queries for an abstract query graph without negation, 500 queries for an abstract query graph with negation; in FB15k, we sample 800 queries for an abstract query graph without negation, 400 queries for an abstract query graph with negation; in NELL, we sample 400 queries for an abstract query graph without negation, 100 queries for an abstract query graph with negation. As we have discussed in Appendix D.2, sample negative query is computationally costly, thus we sample less of them.\\n\\nMoreover, we provide our EFO\\\\(_k\\\\)-CQA dataset an inductive version, with the same query types as the transductive version, while the number of queries per query type is set to 400 for positive ones and 100 for negative ones. The inductive ratio is set to 175%, following the setting in [9].\"}"}
{"id": "r8PnfcWQol", "page_num": 19, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 4: The number of abstract query graphs with two free variables. The notation of $e$, SDAG, Multi, and Cyclic are the same as Table 3. And \\\"-\\\" means that this type of abstract query graph is not included.\\n\\n| c | e | SDAG | Multi | SDAG | Multi | Cyclic | SDAG | Multi | Cyclic |\\n|---|---|------|-------|------|-------|--------|------|-------|--------|\\n| 0 | 1 | 2    | 7     | 18   | 4     | 6      | 32   | 26    | 96     |\\n| 1 | 4  | 4    | 20    | 36   | 8     | 38     | 108  | 64    | 282    |\\n| 2 | 4  | 4    | 32    | 60   | 12    | -      | -    | -     | 112     |\\n\\nAlgorithm 1\\n\\nEmbedding computation on the query graph.\\n\\nRequire: The query graph $G$.\\n\\nCompute the ordering of the nodes as explained in Algorithm 2.\\n\\nCreate a dictionary $E$ to store the embedding for each node in the query graph\\n\\nfor $i \\\\leftarrow 1$ to $n$\\n\\nif node $u_i$ is a constant entity\\n\\nThe embedding of $u_i$, $E_{ri}$ is gotten from the entity embedding\\n\\nelse\\n\\nThen we know node $u_i$ is either free variable or existential variable\\n\\nCompute the set of nodes $t_{u_j}$ that are previous to $i$ and adjacency to node $u_i$.\\n\\nCreate a list to store projection embedding $L$.\\n\\nfor $j \\\\leftarrow 1$ to $t$\\n\\nFind the relation $r$ between node $u_i$ and $u_{ij}$, get the embedding of node $u_{ij}$ as $E_{rij}$.\\n\\nif $E_{rij}$ is not None\\n\\nif The edge between $u_i$ and $u_{ij}$ is positive\\n\\nCompute the embedding of projection($E_{rij}$), add it to the list $L$.\\n\\nelse\\n\\nCompute the embedding of the negation of the projection($E_{rij}$), add it to the list $L$.\\n\\nend if\\n\\nend if\\n\\nend for\\n\\nif The list $L$ has no element\\n\\n$E_{ri}$ is set to none.\\n\\nelse if The list $L$ has one element\\n\\n$E_{ri} = L_{ri}0$\\n\\nelse\\n\\nCompute the embedding as the intersection of the embedding in the list $L$, and set $E_{ri}$ as the outcome.\\n\\nend if\\n\\nend if\\n\\nend for\\n\\nreturn The embedding dictionary $E$ for each node in the query graph.\\n\\nSpecifically, we rank each hard answer $a_P$ against all non-answers $E_{A^o}$, the reason is that we need to neglect other answers so that answers do not interfere with each other, finally, we get the ranking for $a$ as $r$. Then its MRR is $\\\\{r\\\\}$, and its HIT@k is $r \\\\leq k$, thus, the score of a query is the mean of the scores of every its hard answer. We usually compute the score for a query type (which corresponds to an abstract query graph) as the mean score of every query within this type.\\n\\nAs the marginal score and the multiply score have already been explained in Section 4.5, we only mention one point that it is possible that every free variable does not have marginal hard answer. Assume that for a query with two free variables, its answer set $A = \\\\{a_1, a_2, a_3, a_4\\\\}$ and its observed answer set $A^o = \\\\{a_1, a_3, a_4\\\\}$. In this case, $a_1$ is not the marginal hard answer for the first free variable and $a_2$ is not the marginal hard answer for the second free variable, in general, no free variable has its own marginal hard answer.\"}"}
{"id": "r8PnfcWQol", "page_num": 20, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Algorithm 2\\nNode ordering on the abstract query graph.\\n\\nRequire: The abstract query graph $G = (p, V, E, f, g)$. $V$ consists of $m$ nodes, $u_1, \\\\ldots, u_m$.\\n\\n1. Create an empty list $L$ to store the ordering of the nodes.\\n2. Create another two sets $S_1$ and $S_2$ to store the nodes that are to be explored next.\\n3. **for** $i = 1$ to $m$ **do**\\n   4. **if** the type of node $f_{p, u_i}$ is constant entity **then**\\n      5. Append the node $u_i$ to list $L$.\\n      6. **for** each node $u_j$ that connects to $u_i$ **do**\\n         7. **if** $f_{p, u_j}$ is existential variable **then**\\n            8. $u_j$ is added to set $S_1$.\\n         9. **else**\\n            10. $u_j$ is added to set $S_2$.\\n         11. **end if**\\n      12. **end for**\\n   13. **end if**\\n5. **while** not all nodes are included in $L$ **do**\\n6. **if** set $S_1$ is not empty **then**\\n7. We sort the set $S_1$ by the sum of their distance to every free variable in $G$, choose the most remote one, and if there is a tie, randomly choose one node, $u_i$ to be the next to explore.\\n8. We remove $u_i$ from set $S_1$.\\n9. **else**\\n10. In this case, we know set $S_2$ is not empty because of the connectivity of $G$.\\n11. We randomly choose a node $u_i \\\\in S_2$ to be the next node to explore.\\n12. We remove $u_i$ from set $S_2$.\\n13. **end if**\\n14. **end while**\\n5. **end for**\\n16. Return the list $L$ as the ordering of nodes in the whole abstract query graph $G$.\\n\\nThen we only discuss the joint metric, specifically, we only explain how to estimate the joint ranking by the individual ranking of each free variable. For each possible $k$-tuple $p_{a_1}, \\\\ldots, a_k$, if $a_i$ is ranked as $r_i$ among the whole entity set $E$, we compute the score of this tuple as $\\\\sum_{i=1}^{k} r_i$, then we sort the whole $E_k$-tuple by their score, for the situation of a tie, we just use the lexicographical order.\\n\\nAfter the whole joint ranking is got, we use the standard evaluation protocol that ranks each hard answer against all non-answers. It can be confirmed that this estimation method admits a closed-form solution for the sorting in $E_k$ space, thus the computation cost is affordable.\\n\\nWe just give the closed-form solution when there are two free variables: for the tuple $p_{r_1}, r_2$, the possible combinations that sum less than $r_1$ is $r_1 - r_2 \\\\leq 1$, then there is $r_1 \\\\leq 1$ tuple that ranks before $p_{r_1}, r_2$ because of lexicographical order, thus, the final ranking for the tuple $p_{r_1}, r_2$ is just $r_1 - r_2 \\\\leq 1$ that can be computed efficiently.\"}"}
{"id": "r8PnfcWQol", "page_num": 21, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"the embedding for each node in the query graph. Algorithm 1, the final embedding of every free\\nnode are gotten to be the predicted answer. Especially, the node ordering we got in Algorithm 2\\ncoincides with the natural topology ordering induced by the directed acyclic operator tree, so we can\\ncompute the embedding in the same order as the original implementation. Then, in Algorithm 1, we\\nimplement each set operation in the operator tree, including intersection, negation, and set projection.\\nBy the merit of the Disjunctive Normal Form (DNF), the union is tackled in the final step. Thus, our\\nimplementation can coincide with the original implementation in the original dataset [28].\\n\\nFor CQD [2] and LMPNN [35], their original implementation does not require the operator tree, so\\nwe just use their original implementation. Specifically, in a query graph with multiple free variables,\\nfor CQD we predict the answer for each free variable individually as taking others free variables as\\nexistential variables, for LMPNN, we just got all embedding of nodes that represent free variables.\\n\\nFor FIT [39], though it is proposed to solve EFO queries, it is computationally costly: it has a\\ncomplexity of $O^2$ in the acyclic graphs and is even not polynomial in the cyclic graphs, the\\nreason is that FIT degrades to enumeration to deal with cyclic graph. In our implementation, we\\nfurther restrict FIT to at most enumerate 10 possible candidates for each node in the query graph, this\\npractice has allowed FIT to be implemented in the dataset FB15k-237 [32]. However, it cost 20 hours\\nto evaluate FIT on our EFO-k-CQA dataset while other models only need no more than two hours.\\nMoreover, for larger knowledge graph, including NELL [7] and FB15k [5], we have also encountered\\nan out-of-memory error in a Tesla V100 GPU with 32G memory when implementing FIT, thus, we\\nomit its result in these two knowledge graphs.\\n\\nG Extension to more complex query answering\\n\\nIn this section, we discuss possible further development in the task of complex query answering and\\nhow our work, especially our framework proposed in Section 4 can help with future development.\\nWe list some new features that may be of interest and show the maximum versatility our framework\\ncan reach. Our analysis and characterization of future queries inherit the outlook in [37] and also is\\nbased on the current development.\\n\\nInductive Reasoning\\n\\nInductive reasoning is a new trend in the field of complex query answering. Some entities [9] or even\\nrelations [15] are not seen in the training period, namely they can not be found by the observed\\nknowledge graph $G_o$ therefore, the inductive generalization is essential for the model to infer\\nanswers. We note that our framework is powerful enough to sample inductive queries with the\\nobserved knowledge graph $G_o$ given. Therefore, the functionality of sampling inductive query is\\neasily contained and implemented in our framework, see https://github.com/HKUST-KnowComp/EFOK-\\nCQA. We note there we have already provided our EFO-k-CQA dataset in this setting as discussed in\\nAppendix D.4.\\n\\nN-ary relation\\n\\nN-ary relation is a relation that has $n > 2$ corresponding entities, therefore, the factual\\ninformation in the knowledge graph is not a triple but a $p^n-1$-tuple. Moreover, the query graph is\\nalso a hypergraph, making the corresponding CSP problem even harder. This is a newly introduced\\ntopic [23, 1] in complex query answering, which our framework has limitations in representing.\\n\\nKnowledge graph with attribute\\n\\nCurrently, there has been some research that has taken the additional attribute of the knowledge\\ngraph into account. Typical attributes include entity types [14], numerical literals [4], triple\\ntimestamps [16, 30], and triple probabilities [7]. We note that attributes expand the entity set\\nfrom all entities to entities with attribute values, it is also possible that the relation set $R$\\nis also extended to contain corresponding relations, like \u201cgreater\u201d, \u201cless\u201d when dealing\\nwith numerical literals. Then, our framework can represent queries on such extended knowledge\\ngraphs like in [4], where no function like \u201cplus\u201d, or \u201cminus\u201d is considered and the predicates are also\\nbinary.\\n\\nOverall, our framework can be applied to some avant-garde problem settings given certain properties,\\nthus those functionalities proposed in Section 4 can be useful. We hope our discussion helps with the\\nfuture development of complex query answering.\"}"}
{"id": "r8PnfcWQol", "page_num": 22, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 7: Relative performance of the six representative CQA models in referring queries with two free variables, the ranking of query types is determined by the average Multiply HIT@10 score. A Gaussian filter with sigma=1 is added to smooth the curve.\\n\\nIn this section, we offer another experiment result not available to be shown in the main paper. For the purpose of supplementation, we select some representative experiment result as the experiment result is extremely complex to be categorized and be shown. we present the further benchmark result of the following: the analysis of benchmark result in detail, more than just the averaged score in Table 1 and Table 2, which is provided in Appendix H.1; result of different knowledge graphs, including NELL and FB15k, which is provided in Appendix H.2 and H.3, the situation of more constant entities since we only discuss when there are two constant entities in Table 2, the result is provided in Appendix H.4, and finally, all queries (including the queries without marginal hard answers), in Appendix H.5.\\n\\nWe note that we have explained in Section 4.5 and Appendix E that for a query with multiple free variables, some or all of the free variables may not have their marginal hard answer and thus the marginal metric can not be computed. Therefore, in the result shown in Table 2 in Section 5.3, we only conduct evaluation on those queries that both of their free variables have marginal hard answers, and we offer the benchmark result of all queries in Appendix H.5 where only two kinds of metrics are available.\\n\\nH.1 Further result and analysis of the experiment in main paper\\n\\nTo supplement the experiment result already shown in Section 5.2 and Section 5.3, we have included more benchmark results in this section. Though the averaged score is a broadly-used statistic to benchmark the model performance on our EFO \\\\( k \\\\) queries, this is not enough and we have offered much more detail in this section.\\n\\nWhole combinatorial space helps to develop trustworthy machine learning models. Firstly, we show more detailed benchmark results of the relative performance between our selected six CQA models, the result is shown in Table 4. Specifically, we plot two boxes, the black one, including the most difficult query types, and the red box, including the easiest query types. In the easiest part, we find that even the worst model and the best model have pretty similar performance despite that they\"}"}
{"id": "r8PnfcWQol", "page_num": 23, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"Figure 8: Query type distribution in three different datasets, BetaE one, FIT one, and the EFO 1 part in our EFO k-CQA dataset. The left part shows the histogram that represents the probability density function of each dataset. The ranking of query types is also determined by the mean HIT@10 score as in Figure 4, with the standard deviation of the performance of the six CQA models shown as the light blue error bar.\\n\\nEmpirical hardness of query types and incomplete discussion of the previous dataset. Moreover, we also discuss the empirical hardness of query types themselves and compare different datasets accordingly in Figure 8. We find the standard deviation of the six representative CQA models increases in the most difficult part and decreases in the easiest part, corroborating our discussion in the first paragraph. We also highlight those query types that have already been investigated in BetaE dataset [28] and FIT dataset [39]. We intuitively find that the BetaE dataset does not include very challenging query types while the FIT dataset mainly focuses on them. This can be explained by the fact that nine out of ten most challenging query types correspond to multigraph, which the BetaE dataset totally ignores while the FIT dataset highlights it as a key feature. To give a quantitative analysis of whether their hand-crafted query types are sampled from the whole combinatorial space, we have adopted the Kolmogorov\u2013Smirnov test to test the distribution discrepancy between their distribution and the query type distribution in EFO k-CQA since EFO k-CQA enumerates all possible query types in the given combinatorial space and is thus unbiased. We find that the BetaE dataset is indeed generally easier and its p-value is 0.78, meaning that it has a 78 percent possibility to be unbiased, while the FIT dataset is significantly harder and its p-value is 0.27. Therefore, there is...\"}"}
{"id": "r8PnfcWQol", "page_num": 24, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 5: MRR scores(%) for inferring queries with one free variable on FB15k-237. We denote $e$ as the number of existential variables and $c$ as the number of constant entities. SDAG represents the Simple Directed Acyclic Graph, Multi for multigraph, and Cyclic for the cyclic graph. A VG.($c$) and A VG.($e$) is the average score of queries with the number of constant entities / existential variables fixed.\\n\\n| Model  | $c$ | $e$ | SDAG | SDAG | Multi | SDAG | Multi | Cyclic |\\n|--------|-----|-----|------|------|-------|------|-------|--------|\\n| BetaE  | 1   | 0   | 16.2 | 17.9 | 10.9  | 10.6 | 8.5   | 16.5   |\\n|        |     | 1   |      |      |       |      |       |        |\\n|        |     | 2   |      |      |       |      |       |        |\\n| LogicE | 1   | 0   | 17.4 | 19.0 | 11.5  | 11.0 | 8.5   | 16.8   |\\n|        |     | 1   |      |      |       |      |       |        |\\n|        |     | 2   |      |      |       |      |       |        |\\n| ConE   | 1   | 0   | 18.6 | 19.9 | 11.8  | 11.4 | 9.3   | 18.7   |\\n|        |     | 1   |      |      |       |      |       |        |\\n|        |     | 2   |      |      |       |      |       |        |\\n| CQD    | 1   | 0   | 22.2 | 19.5 | 9.0   | 9.2  | 6.4   | 15.6   |\\n|        |     | 1   |      |      |       |      |       |        |\\n|        |     | 2   |      |      |       |      |       |        |\\n| LMPNN  | 1   | 0   | 20.5 | 21.4 | 11.2  | 11.6 | 8.7   | 17.0   |\\n|        |     | 1   |      |      |       |      |       |        |\\n|        |     | 2   |      |      |       |      |       |        |\\n| FIT    | 1   | 0   | 22.2 | 25.0 | 17.4  | 13.9 | 11.7  | 23.3   |\\n|        |     | 1   |      |      |       |      |       |        |\\n|        |     | 2   |      |      |       |      |       |        |\\n\\nno significant statistical evidence to prove they are sampled from the whole combinatorial space unbiasedly.\\n\\nH.2 Further benchmark result of $k=1$\\n\\nFirstly, we present the benchmark result when there is only one free variable, since the result in FB15k-237 is provided in Table 1, we provide the result for other standard knowledge graphs, FB15k and NELL, their result is shown in Table 6 and Table 7, correspondingly. We note that FIT is out of memory with the two large graphs FB15k and NELL as explained in Appendix F and we do not include its result. As FB15k and NELL are both reported to be easier than FB15k-237, the models have better performance. The trend and analysis are generally similar to our discussion in Section 5.2 with some minor, unimportant changes that LogicE [24] has outperformed ConE [40] in the knowledge graph NELL, indicating one model may not perform identically well in all knowledge graphs.\\n\\nH.3 Further benchmark result for $k=2$ in more knowledge graphs\\n\\nThen, similar to Section 5.3, we provide the result for other standard knowledge graphs, FB15k and NELL, when the number of constant entities is fixed to two, their result is shown in Table 8 and Table 9, correspondingly.\"}"}
{"id": "r8PnfcWQol", "page_num": 25, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"### Table 6: MRR scores(%) for inferring queries with one free variable on FB15k.\\n\\n| Model  | c | e | SDAG | Multi | SDAG | Multi | Cyclic | A VG. c | A VG. e |\\n|--------|---|---|------|-------|------|-------|--------|--------|--------|\\n| BetaE  | 1 | 38.6 | 30.4 | 29.2 | 21.7 | 21.7 | 24.1 | 24.3 |\\n|        | 2 | 34.0 | 2 | 23.2 | 28.3 | 29.2 | 35.5 | 31.0 |\\n|        | 3 | 63.5 | 46.4 | 48.6 | 33.9 | 36.1 | 45.8 | 38.1 |\\n| LogicE | 1 | 46.0 | 33.8 | 32.1 | 23.3 | 22.8 | 25.6 | 26.2 |\\n|        | 2 | 35.6 | 2 | 23.3 | 30.6 | 30.5 | 36.9 | 32.7 |\\n|        | 3 | 64.5 | 48.6 | 49.8 | 35.4 | 37.5 | 47.7 | 39.6 |\\n| ConE   | 1 | 52.5 | 35.8 | 34.9 | 25.9 | 25.9 | 29.5 | 29.3 |\\n|        | 2 | 39.5 | 2 | 23.3 | 33.2 | 34.2 | 40.8 | 36.3 |\\n|        | 3 | 70.6 | 53.1 | 55.3 | 39.3 | 41.8 | 52.5 | 43.9 |\\n| CQD    | 1 | 74.6 | 36.1 | 32.7 | 17.6 | 16.7 | 25.4 | 23.7 |\\n|        | 2 | 37.2 | 2 | 23.3 | 29.2 | 31.5 | 39.2 | 33.2 |\\n|        | 3 | 53.3 | 32.4 | 33.1 | 21.7 | 21.6 | 37.4 | 24.8 |\\n| LMPNN  | 1 | 63.7 | 39.9 | 35.3 | 28.7 | 26.4 | 28.7 | 30.7 |\\n|        | 2 | 37.7 | 2 | 23.3 | 34.4 | 31.7 | 38.4 | 35.1 |\\n|        | 3 | 79.8 | 54.0 | 49.5 | 38.9 | 37.1 | 48.0 | 40.8 |\\n|        | 4 | 70.2 | 47.4 | 42.8 | 36.6 | 34.1 | 41.6 |     |\\n\\nWe note that though in some breakdowns, the marginal score is over 90 percent, almost close to 100 percent, the joint score is pretty slow, which further corroborates our findings that joint metric is significantly harder and more challenging in Section 5.3.\\n\\n### H.4 Further benchmark result for $k=2$ with more constant numbers.\\n\\nAs the experiment in Section 5.3 only contains the situation where the number of constant entity is fixed as one, we offer the further experiment result in Table 10. The result shows that models perform worse with fewer constant variables when compares to the result in Table 2, this observation is the same as the previous result with one free variable that has been discussed in Section 5.2.\\n\\n### H.5 Further benchmark result for $k=2$ including all queries\\n\\nFinally, as we have explained in Section 4.5 and Appendix E, there are some valid EFO queries without marginal hard answers when $k \\\\geq 1$. Thus, there is no way to calculate the marginal scores, all our previous experiments are therefore only conducted on those queries that all their free variables have marginal hard answers. In this section, we only present the result of the Multiply and Joint score, as they can be computed for any valid EFO queries, and therefore this experiment is conducted on the whole EFO-CQA dataset.\\n\\nWe follow the practice in Section 5.3 that fixed the number of constant entities as two, as the impact of constant entities is pretty clear, which has been further corroborated in Appendix H.4. The experiments are conducted on all three knowledge graphs, FB15k-237, FB15k, and NELL, the result is shown in Table 11, Table 12, and Table 13, correspondingly.\"}"}
{"id": "r8PnfcWQol", "page_num": 26, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"### Table 7: MRR scores (%) for inferring queries with one free variable on NELL\\n\\n| Model | 1 | 2 | 3 | A VG.($c$) | A VG.($e$) |\\n|------|---|---|---|------------|------------|\\n| BetaE | 13.9 | 26.4 | 35.0 | 8.6 | 14.9 |\\n|      | 33.62 | 58.8 | 31.5 | 43.8 | 22.4 |\\n|      | 37.6 | 30.7 | 30.7 |\\n| LogicE | 18.3 | 29.2 | 39.6 | 12.1 | 19.0 |\\n|      | 36.92 | 63.5 | 34.4 | 47.3 | 26.4 |\\n|      | 34.2 | 34.2 |\\n| ConE | 16.7 | 26.9 | 36.6 | 11.1 | 16.9 |\\n|      | 36.62 | 60.5 | 33.6 | 46.6 | 25.3 |\\n|      | 33.6 | 33.6 |\\n| CQD | 22.3 | 30.6 | 37.3 | 13.3 | 17.9 |\\n|      | 38.22 | 59.8 | 34.0 | 45.2 | 28.8 |\\n|      | 35.3 | 35.3 |\\n| LMPNN | 20.7 | 29.8 | 33.3 | 13.4 | 16.5 |\\n|      | 35.12 | 63.5 | 35.4 | 43.3 | 27.0 |\\n|      | 32.3 | 32.3 |\\n\\nInterestingly, comparing the result in Table 2 and Table 11, the multiple scores actually increase through the joint scores are similar. This may be explained by the fact that if one free variable has no marginal hard answer, then it can be easily predicted, leading to a better performance for the whole query.\\n\\n### Society impact\\n\\nThis paper addresses the topic of complex query answering on knowledge graphs, a subject that has garnered attention within the machine learning community for approximately four years. This paper mainly focuses on extending the scope of the complex query given the same knowledge graph and also presents systematic benchmarks and convenient implementation for the whole pipeline of complex query answering, which holds the potential to significantly advance the development of complex query answering models.\\n\\nThe outcomes of this work have practical applications, particularly in areas such as fraud detection, where queries involving multiple free variables and cyclic patterns are necessary. Furthermore, since this study utilizes publicly available knowledge graphs without incorporating new information sources, concerns regarding data leakage are unlikely to arise. However, it's still important to note that this work may lead to unexpected negative societal impact which we are unable to foresee in the current stages. We recognize the necessity of ongoing evaluation and responsible oversight to identify and address any unintended consequences that may arise as a result of this research.\\n\\nAdditionally, the figure of the real-world KG in Figure 3 is taken from [https://medium.com/@fakrami/re-evaluation-of-knowledge-graph-completion-methods-7dfe2e981a77](https://medium.com/@fakrami/re-evaluation-of-knowledge-graph-completion-methods-7dfe2e981a77).\"}"}
{"id": "r8PnfcWQol", "page_num": 27, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 8: HIT@10 scores(%) of three different types for answering queries with two free variables on FB15k. The constant number is fixed to be two. The notation of $e$, SDAG, Multi, and Cyclic is the same as Table 2.\\n\\n| Model | HIT@10 Type | Marginal | Multiply | Joint |\\n|-------|-------------|----------|----------|-------|\\n| BetaE | Marginal    | 76.9     | 68.9     | 11.6  |\\n|       | Multiply    | 41.7     | 31.7     | 13.7  |\\n|       | Joint       | 11.6     | 8.7      | 8.7   |\\n| LogicE| Marginal    | 82.9     | 73.6     | 12.7  |\\n|       | Multiply    | 47.5     | 36.3     | 10.0  |\\n|       | Joint       | 12.7     | 10.0     | 10.0  |\\n| ConE  | Marginal    | 84.1     | 76.5     | 14.2  |\\n|       | Multiply    | 48.7     | 37.7     | 10.3  |\\n|       | Joint       | 14.2     | 10.3     | 10.3  |\\n| CQD   | Marginal    | 73.8     | 69.0     | 17.1  |\\n|       | Multiply    | 45.0     | 37.4     | 13.1  |\\n|       | Joint       | 17.1     | 13.1     | 13.1  |\\n| LMPNN | Marginal    | 89.2     | 80.3     | 18.9  |\\n|       | Multiply    | 56.6     | 45.7     | 12.9  |\\n|       | Joint       | 18.9     | 12.9     | 12.9  |\\n\\nTable 9: HIT@10 scores(%) of three different types for answering queries with two free variables on NELL. The constant number is fixed to be two. The notation of $e$, SDAG, Multi, and Cyclic is the same as Table 2.\\n\\n| Model | HIT@10 Type | Marginal | Multiply | Joint |\\n|-------|-------------|----------|----------|-------|\\n| BetaE | Marginal    | 81.3     | 72.8     | 19.2  |\\n|       | Multiply    | 48.2     | 41.3     | 21.2  |\\n|       | Joint       | 19.2     | 21.2     | 21.2  |\\n| LogicE| Marginal    | 87.1     | 81.0     | 21.1  |\\n|       | Multiply    | 52.5     | 47.6     | 25.4  |\\n|       | Joint       | 21.1     | 25.4     | 25.4  |\\n| ConE  | Marginal    | 82.6     | 76.0     | 17.0  |\\n|       | Multiply    | 48.7     | 41.9     | 19.3  |\\n|       | Joint       | 17.0     | 19.3     | 19.3  |\\n| CQD   | Marginal    | 79.5     | 83.2     | 23.0  |\\n|       | Multiply    | 49.2     | 51.1     | 29.7  |\\n|       | Joint       | 23.0     | 29.7     | 29.7  |\\n| LMPNN | Marginal    | 88.5     | 81.5     | 23.4  |\\n|       | Multiply    | 55.7     | 50.3     | 25.5  |\\n|       | Joint       | 23.4     | 25.5     | 25.5  |\"}"}
{"id": "r8PnfcWQol", "page_num": 28, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 10: HIT@10 scores(%) of three different types for answering queries with two free variables on FB15k-237. The constant number is fixed to be one. The notation of $e$, SDAG, Multi, and Cyclic is the same as Table 2.\\n\\n| Model | Type | $e$ | SDAG | Multi | SDAG | Multi | Cyclic | SDAG | Multi | Cyclic |\\n|-------|------|-----|------|-------|------|-------|--------|------|-------|--------|\\n|       |      | 0   |      |       |      |       |        | 1    |       |        |\\n| BetaE | Multiply | 37.5 | 29.7 | 33.4 | 28.1 | 35.6 | 30.0 | 25.9 | 41.2 | 31.2 |\\n|       | Joint | 0.9 | 1.1 | 1.4 | 0.9 | 3.3 | 1.1 | 0.9 | 3.9 | 1.7 |\\n| LogicE | Multiply | 40.6 | 30.7 | 36.0 | 29.1 | 34.6 | 29.8 | 25.3 | 41.5 | 31.4 |\\n|       | Joint | 1.4 | 1.4 | 1.6 | 0.9 | 3.7 | 1.4 | 1.0 | 4.3 | 1.9 |\\n| ConE | Multiply | 40.8 | 32.4 | 37.3 | 30.4 | 40.7 | 31.1 | 26.9 | 45.0 | 33.5 |\\n|       | Joint | 1.4 | 1.0 | 1.7 | 1.0 | 4.3 | 1.4 | 1.0 | 4.4 | 2.0 |\\n| CQD | Multiply | 73.8 | 76.8 | 69.0 | 71.9 | 76.3 | 51.1 | 54.4 | 77.0 | 62.9 |\\n|       | Joint | 1.5 | 0.6 | 2.0 | 1.1 | 3.4 | 1.5 | 0.9 | 4.4 | 1.9 |\\n| LMPNN | Multiply | 39.0 | 27.6 | 40.0 | 29.5 | 39.3 | 30.6 | 24.8 | 42.7 | 32.0 |\\n|       | Joint | 1.6 | 1.3 | 2.5 | 1.3 | 3.9 | 1.5 | 1.0 | 4.0 | 2.0 |\\n\\nTable 11: HIT@10 scores(%) of two different types for answering queries with two free variables on FB15k-237 (including queries without the marginal hard answer). The constant number is fixed to be two. The notation of $e$, SDAG, Multi, and Cyclic is the same as Table 2.\\n\\n| Model | Type | $e$ | SDAG | Multi | SDAG | Multi | Cyclic | SDAG | Multi | Cyclic |\\n|-------|------|-----|------|-------|------|-------|--------|------|-------|--------|\\n|       |      | 0   |      |       |      |       |        | 2    |       |        |\\n| BetaE | Multiply | 29.1 | 29.1 | 18.3 | 37.5 | 10.4 | 28.0 | 93.6 | 74.6 | 24.1 |\\n|       | Joint | 2.1 | 2.2 | 1.7 | 3.0 | 2.4 | 1.8 | 5.8 | 14.2 | 4.6 |\\n| LogicE | Multiply | 31.6 | 32.9 | 19.8 | 39.6 | 10.9 | 28.7 | 96.3 | 73.8 | 25.4 |\\n|       | Joint | 2.6 | 2.5 | 2.1 | 3.1 | 2.5 | 2.2 | 6.4 | 15.6 | 5.0 |\\n| ConE | Multiply | 32.6 | 31.9 | 20.5 | 41.0 | 12.6 | 29.0 | 99.7 | 86.8 | 27.0 |\\n|       | Joint | 3.0 | 2.1 | 1.9 | 3.3 | 2.7 | 2.2 | 6.6 | 16.8 | 5.4 |\\n| CQD | Multiply | 34.5 | 23.4 | 22.3 | 36.8 | 10.6 | 26.4 | 75.3 | 77.3 | 25.6 |\\n|       | Joint | 2.9 | 1.4 | 2.1 | 3.3 | 2.3 | 2.0 | 5.0 | 15.0 | 5.6 |\\n| LMPNN | Multiply | 36.8 | 29.3 | 27.5 | 45.8 | 13.9 | 31.2 | 97.0 | 86.5 | 27.9 |\\n|       | Joint | 2.7 | 2.2 | 2.7 | 3.9 | 2.5 | 2.1 | 5.8 | 14.6 | 5.0 |\\n| FIT | Multiply | 41.5 | 44.4 | 28.9 | 56.8 | 10.2 | 39.4 | 139.7 | 100.3 | 35.0 |\\n|       | Joint | 2.4 | 2.3 | 2.1 | 3.4 | 1.6 | 2.2 | 7.4 | 15.4 | 5.9 |\"}"}
{"id": "r8PnfcWQol", "page_num": 29, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 12: HIT@10 scores(%) of two different types for answering queries with two free variables on FB15k (including queries without the marginal hard answer). The constant number is fixed to be two. The notation of e, SDAG, Multi, and Cyclic is the same as Table 2.\\n\\n| Model | Type | e<sup>0</sup> | e<sup>1</sup> | e<sup>2</sup> | A VG. | SDAG Multi | SDAG Multi | Cyclic | SDAG Multi | Cyclic |\\n|-------|------|--------------|--------------|--------------|----------|------------|------------|--------|------------|--------|\\n| BetaE | Multiply | 42.1 | 57.2 | 26.5 | 66.5 | 15.5 | 34.6 | 134.9 | 100.0 | 35.0 |\\n|       | Joint | 6.6 | 9.4 | 4.5 | 10.2 | 4.6 | 4.3 | 16.7 | 26.0 | 9.2 |\\n| LogicE | Multiply | 48.2 | 65.6 | 31.0 | 71.6 | 16.8 | 37.8 | 143.9 | 105.8 | 38.1 |\\n|       | Joint | 7.5 | 11.2 | 5.6 | 12.5 | 5.3 | 5.6 | 20.4 | 28.5 | 10.5 |\\n| ConE  | Multiply | 50.2 | 72.2 | 32.8 | 74.6 | 18.3 | 38.3 | 149.3 | 114.3 | 40.4 |\\n|       | Joint | 6.8 | 10.0 | 5.2 | 12.5 | 5.5 | 5.2 | 19.4 | 30.4 | 11.0 |\\n| CQD   | Multiply | 48.1 | 55.9 | 31.9 | 69.0 | 15.8 | 29.5 | 93.5 | 103.2 | 37.6 |\\n|       | Joint | 9.4 | 11.4 | 6.6 | 14.8 | 4.8 | 5.5 | 17.5 | 27.2 | 12.0 |\\n| LMPNN | Multiply | 58.4 | 79.5 | 43.1 | 94.6 | 21.3 | 40.9 | 146.2 | 135.9 | 45.0 |\\n|       | Joint | 8.6 | 12.9 | 6.8 | 15.6 | 6.2 | 5.4 | 19.3 | 31.7 | 11.6 |\\n\\nTable 13: HIT@10 scores(%) of two different types for answering queries with two free variables on NELL (including queries without the marginal hard answer). The constant number is fixed to be two. The notation of e, SDAG, Multi, and Cyclic is the same as Table 2.\\n\\n| Model | Type | e<sup>0</sup> | e<sup>1</sup> | e<sup>2</sup> | A VG. | SDAG Multi | SDAG Multi | Cyclic | SDAG Multi | Cyclic |\\n|-------|------|--------------|--------------|--------------|----------|------------|------------|--------|------------|--------|\\n| BetaE | Multiply | 21.2 | 47.3 | 22.0 | 51.9 | 14.7 | 24.1 | 80.5 | 79.7 | 33.4 |\\n|       | Joint | 4.2 | 19.6 | 6.8 | 19.1 | 5.1 | 6.8 | 26.7 | 24.0 | 14.1 |\\n| LogicE | Multiply | 26.6 | 52.8 | 28.8 | 63.4 | 16.0 | 32.8 | 103.1 | 88.5 | 38.9 |\\n|       | Joint | 3.8 | 21.5 | 9.7 | 26.0 | 5.9 | 11.5 | 36.9 | 27.3 | 16.5 |\\n| ConE  | Multiply | 25.3 | 51.4 | 23.9 | 53.9 | 16.9 | 27.3 | 90.7 | 90.6 | 36.7 |\\n|       | Joint | 3.4 | 20.2 | 6.4 | 17.0 | 6.1 | 7.2 | 27.0 | 27.1 | 14.2 |\\n| CQD   | Multiply | 30.3 | 48.9 | 30.6 | 64.3 | 15.9 | 33.1 | 88.9 | 91.2 | 40.9 |\\n|       | Joint | 4.4 | 21.9 | 9.8 | 27.5 | 5.6 | 12.0 | 37.6 | 28.1 | 18.0 |\\n| LMPNN | Multiply | 33.4 | 58.3 | 33.7 | 65.3 | 19.4 | 30.7 | 85.1 | 105.0 | 41.8 |\\n|       | Joint | 4.4 | 23.7 | 10.0 | 21.9 | 5.8 | 8.2 | 23.2 | 28.8 | 15.7 |\"}"}
{"id": "r8PnfcWQol", "page_num": 5, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"We propose two assumptions of the abstract query graph as follows:\\n\\n**Assumption 13 (No redundancy).**\\nFor an abstract query graph $G$, there is not a subgraph $G_s$ such that for every grounding $I$, $ArI_pGqs = ArI_pGsqs$.\\n\\n**Assumption 14 (No decomposition).**\\nFor an abstract query graph $G$, there are no such two subgraphs $G_1, G_2$, satisfying that $G_1, G_2 \\\\sqsubseteq G$, such that for every instantiation $I$, $ArI_pGqs \\\\subseteq ArI_pG_1qs \\\\times ArI_pG_2qs$, where the $\\\\times$ represents the cartesian product.\\n\\nThe assumption 14 inherits the idea of the structural decomposition technique in CSP [11], which allows for solving a CSP instance by solving several sub-problems and combining the answers together based on topology property. Additionally, meeting these two assumptions in the grounded query graph is extremely computationally costly thus we avoid it in practice.\\n\\nWe provide some easy examples to be excluded for violating the assumptions above in Figure 2.\\n\\n### 3.2 Nontrivial query graph of EFO\\n\\nSimilarly, we propose two assumptions on the query graph.\\n\\n**Assumption 15 (Meaningful negation).**\\nFor any negative edge $e$ in query graph $G$, we require removing it results in different CSP answers: $ArG\u00b4e \u2260 ArGs$.\\n\\nAssumption 15 treats negation separately because of the fact that for any $KG$, any relation $r \\\\subseteq R$, there is $|tp_{h, t}p_{h, r}q|p_{K}u|!|E|2$, which means that the constraint induced by the negation of an atomic formula is much less \\\"strict\\\" than the one induced by a positive atomic formula.\\n\\n**Assumption 16 (Appropriate answer size).**\\nThere is a constant $M!|E|$ to bound the candidate set for each free variable $y_i$ in $G$, such that for any $i$, $|ta_i \\\\subseteq E|p_{a_1}, \\\\ldots, a_kq\\\\subseteq ArGsu|\\\\leq M$.\\n\\nWe note the Assumption 16 extends the \\\"bounded negation\\\" assumption in the previous dataset [28, 36]. We give an example \\\"Find a city that is located in Europe and is the capital of a country that has not held the Olympics\\\" in Figure 2, where the candidate set of $x_1$ is in fact bounded by its relation with the $y_1$ variable but not from the bottom \\\"Olympics\\\" constant, hence, this query is excluded in their dataset due to the directionality of operator tree.\\n\\nOverall, the scope of the formula investigated in this paper surpasses the previous EFO-1-QA benchmark because of: (1). We include the EFO formula with multiple free variables for the first time; (2). We include the whole family of EFO query, many of them can not be represented by operator tree; (3) Our assumption is more systematic than previous ones as shown by the example in Figure 2. More details are offered in Appendix D.3.\\n\\n### 4 Framework\\n\\nWe develop a versatile framework that supports five key functionalities fundamental to the whole CQA task: (1) Enumeration of nontrivial abstract query graphs as discussed in Section 3; (2) Sample grounding for the abstract query graph; (3) Compute answer for any query graph efficiently; (4) Support implementation of existing CQA models; (5) Conduct evaluation including newly introduced EFO queries with multiple free variables. We explain each functionality in the following. An illustration of the first three functionalities is given in Figure 3, where we show how each functionality cooperates to help CQA tasks. We note that preprocessing allows us to extend our framework to more avant-garde settings, like inductive settings or graphs with numerics, more discussions in Appendix G.\"}"}
{"id": "r8PnfcWQol", "page_num": 6, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 3: Illustration of the all functionalities of our framework. Real-world KG is preprocessed and fed into our pipeline, which contains the whole process of data generation and supports end-to-end machine learning as well as evaluation. The origin of the KG picture is in Appendix I.\\n\\nof constants, free variables, existential variables, and the number of edges are all given, shown in Figure 3. Additionally, we apply the graph isomorphism algorithm to avoid duplicated query graphs being generated. More details for our generation method are provided in Appendix D.1.\\n\\n4.2 Ground abstract query graph\\n\\nTo ground an abstract query graph $G$ and comply with the assumption 15, we split the abstract query graph into two parts, the positive part and the negative part, $G^p$ and $G^n$. Then the grounding process is also split into two steps: 1. Sample grounding for the positive subgraph $G^p$ and compute its answer, 2. Ground the $G^n$ to decrease the answer got in the first step. Details in Appendix D.2.\\n\\nFinally, to fulfill the assumption 16, we follow the previous practice of manually filtering out queries that have more than $100$ answers [28, 36], as we have introduced the EFO $k$ queries.\\n\\n4.3 Answer for existential formula\\n\\nAs illustrated in Section 2.2, the answer to an existential formula can be solved by a CSP solver, however, we also show in Definition 9 that solve it as CSP leads to huge computation costs. Thus, we develop our own algorithm following the standard solving technique of CSP, which ensures consistency conditions in the first step, and do the backtracking to get the final answers in the second step. Finally, we select part of our sampled queries and double-check it with the CSP solver https://github.com/python-constraint/python-constraint.\\n\\n4.4 Learning-based methods\\n\\nAs the query graph is an extension to the operator tree regarding the express ability to existential formulas, we are able to reproduce CQA models that are initially implemented by the operator tree in our new framework. Specifically, since the operator tree is directed and acyclic, we compute its topology ordering that allows for step-by-step computation in the query graph. This algorithm is illustrated in detail in the Appendix F. Therefore, our pipeline is backward compatible.\\n\\nConversely, for the newly proposed models that are based on query graphs, the original operator tree framework is not able to implement them, while our framework is powerful enough. We have therefore clearly shown that the query graph representation is more powerful than the previous operator tree and is able to support arbitrary existential formulas as explained in Section 2.3.\\n\\n4.5 Evaluation protocol\\n\\nAs we have mentioned in Section 2.1, there is an observed knowledge graph $KG_o$ and a full knowledge graph $KG$. Thus, there is a set of observed answers $A_o$ and a set of full answers $A_c$ correspondingly.\\n\\nSince the goal of CQA is to tackle the challenge of incompleteness, it has been a common practice to...\"}"}
{"id": "r8PnfcWQol", "page_num": 7, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 1: HIT\\\\(\\\\@10\\\\) scores(\\\\%) for inferring queries with one free variable on FB15k-237. We denote \\\\(e\\\\) as the number of existential variables, \\\\(c\\\\) as constant entities correspondingly. SDAG represents Simple Directed Acyclic Graph, Multi for multigraph, and Cyclic for cyclic graph. A VG.\\\\((c)\\\\) and A VG.\\\\((e)\\\\) is the average score of queries with the number of constant entities / existential variables fixed.\\n\\n| Model  | 0  | 1  | 2  | A VG.\\\\((c)\\\\) | A VG.\\\\((e)\\\\) |\\n|--------|----|----|----|---------------|---------------|\\n| BetaE  | 31.4 | 33.0 | 22.3 | 17.7 | 30.7 |\\n|        | 36.42 | 57.2 | 36.2 | 35.5 | 29.3 |\\n|        | 3  | 80.0 | 53.1 | 53.6 | 38.2 |\\n|        | 2 | A VG.\\\\((e)\\\\) | 58.2 | 42.1 | 43.8 |\\n| LogicE | 34.4 | 34.9 | 23.0 | 21.4 | 17.4 |\\n|        | 36.72 | 60.0 | 38.4 | 36.8 | 29.8 |\\n|        | 3 | 83.0 | 55.5 | 55.5 | 38.5 |\\n|        | 2 | A VG.\\\\((e)\\\\) | 57.8 | 42.4 | 46.0 |\\n| ConE   | 34.9 | 35.4 | 23.6 | 21.8 | 18.4 |\\n|        | 39.02 | 61.0 | 39.1 | 38.4 | 32.0 |\\n|        | 3 | 84.8 | 56.7 | 57.1 | 41.1 |\\n|        | 2 | A VG.\\\\((e)\\\\) | 63.4 | 44.9 | 47.0 |\\n| CQD    | 39.0 | 34.2 | 17.6 | 17.4 | 12.7 |\\n|        | 35.92 | 50.7 | 33.8 | 33.6 | 28.4 |\\n|        | 3 | 58.4 | 49.6 | 52.4 | 39.3 |\\n|        | 2 | A VG.\\\\((e)\\\\) | 50.7 | 42.6 | 38.4 |\\n| LMPNN  | 38.6 | 37.8 | 21.8 | 22.9 | 17.8 |\\n|        | 35.82 | 62.2 | 40.2 | 35.0 | 30.8 |\\n|        | 3 | 86.6 | 56.9 | 51.9 | 38.3 |\\n|        | 2 | A VG.\\\\((e)\\\\) | 65.4 | 40.8 | 34.5 |\\n| FIT    | 38.7 | 42.7 | 32.5 | 26.1 | 22.5 |\\n|        | 47.02 | 65.5 | 47.7 | 48.2 | 40.1 |\\n|        | 3 | 84.2 | 63.9 | 63.5 | 50.5 |\\n|        | 2 | A VG.\\\\((e)\\\\) | 65.8 | 54.7 | 51.5 |\\n\\nevaluate CQA models by the \u201chard\u201d answers \\\\(A_h\\\\) \\\\(\\\\text{[26, 27]}\\\\). However, to the best of our knowledge, there has not been a systematic evaluation protocol for EFO \\\\(k\\\\) queries, thus we leverage this idea and propose three types of different metrics to fill the research gap in the area of evaluation of queries with multiple free variables, and thus have combinatorial answers.\\n\\nMarginal. For any free variable \\\\(y_i\\\\), its full answer is \\\\(A_{y_i}^{P_{a_1}, \\\\ldots, a_k}P_{a_1}, \\\\ldots, a_k\\\\), the observed answer of it \\\\(A_{y_i}^o\\\\) is defined similarly. This is termed \u201csolution projection\u201d in CSP theory \\\\(\\\\text{[12]}\\\\) to evaluate whether the locally retrieved answer can be extended to an answer for the whole problem. Then, we rank the hard answer \\\\(A_{y_i}^{h}\\\\) against those non-answers \\\\(E_{y_i}^{\\\\text{\\\\'}h}\\\\) \\\\(A_{y_i}^o\\\\), use the ranking to compute standard metrics like MRR, \\\\(\\\\text{HIT}\\\\@n\\\\) for every free variable. Finally, the metric on the whole query graph is taken as the average of the metric on all free variables. We note that this metric is an extension of the previous design \\\\(\\\\text{[20]}\\\\). However, this metric has the inherent drawback that it fails to evaluate the combinatorial answer by the \\\\(k\\\\)-length tuple and thus fails to find the correspondence among free variables.\\n\\nMultiply. Because of the limitation of the marginal metric discussed above, we propose to evaluate the combinatorial answer by each \\\\(k\\\\)-length tuple \\\\(a_1, \\\\ldots, a_k\\\\) in the hard answer set \\\\(A_h\\\\). Specifically, we rank each \\\\(a_i\\\\) in the corresponding node \\\\(y_i\\\\) the same as the marginal metric. Then, we propose the \\\\(\\\\text{HIT}\\\\@n\\\\) metric, it is 1 if all \\\\(a_i\\\\) is ranked in the top \\\\(n\\\\) in the corresponding node \\\\(y_i\\\\), and 0 otherwise.\\n\\nJoint. Finally, we note these metrics above are not the standard way of evaluation, which is based on a joint ranking for all the \\\\(E_k\\\\) combinations of the entire search space. We propose to estimate the joint ranking in a closed form given certain assumptions, see Appendix E for the proof and details.\\n\\n5 The EFO \\\\(k\\\\)-CQA dataset and benchmark results\\n\\n5.1 The EFO \\\\(k\\\\)-CQA dataset\\n\\nWith the help of our framework developed in Section 4, we develop a new dataset called EFO \\\\(k\\\\)-CQA, whose combinatorial space is parameterized by the number of constants, existential and free variables, and the number of edges. EFO \\\\(k\\\\)-CQA dataset includes 741 different abstract query graphs in total.\"}"}
{"id": "r8PnfcWQol", "page_num": 8, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":true,\"natural_text\":\"Figure 4: Relative performance of the six representative CQA models in queries with one free variable, where the ranking of query types is determined by the average HIT@10 score. A Gaussian filter with sigma=1 is added to smooth the curve.\\n\\nThen, we conduct experiments on our new EFO\\\\(k\\\\)-CQA dataset with six representative CQA models including BetaE [28], LogicE [24], and ConE [40], which are built on the operator tree, CQD [2], LMPNN [35], and FIT [39] which are built on query graph. The experiments are conducted in two parts, (1). the queries with one free variable, specifically, including those that can not be represented by an operator tree; (2). the queries that contain multiple free variables.\\n\\nThe parameters and the generation process, as well as its statistics, are detailed in Appendix D.4, where we also provide a dataset constructed in inductive settings. However, we mainly focus on transductive settings in the main paper since there are very few inductive models to benchmark. We have made some adaptations to the implementation of CQA models, allowing them to infer EFO\\\\(k\\\\) queries, full detail in Appendix F. The experiment is conducted on a standard KG FB15k-237 [32], additional experiments on other standard KGs FB15k and NELL are presented in Appendix H.\\n\\n5.2 Benchmark results for \\\\(k=1\\\\) Because of the great number of abstract query graphs, we follow previous work [36] to group query graphs by three factors: (1). the number of constant entities; (2). the number of existential variables, and (3). the topology of the query graph. The result is shown in Table 1 and Figure 4.\\n\\nStructure analysis. Firstly, we find a clear monotonic trend that adding constant entities makes a query easier while adding existing variables makes a query harder, which the previous research [36] fails to uncover. Besides, we are the first to consider the topology of query graphs: when the number of constants and existential variables is fixed, we have found the originally investigated queries that correspond to Simple Directed Acyclic Graphs (SDAG) are generally easier than the multigraphs ones but harder than the cyclic graph ones. This is an intriguing result that greatly deviates from traditional CSP theory which finds that the cyclic graph is NP-complete, while the acyclic graph is tractable [6]. We conjecture that the cyclic graph contains one more constraint than SDAG that serves as a source of information for CQA models, while the multigraph tightens an existing constraint and thus makes the query harder.\\n\\nModel analysis. For models that are built on operator tree, including BetaE, LogicE, and ConE, their relative performance is steady among all breakdowns and is consistent with their reported score in the original dataset [28]. However, for models that are built on query graphs, including CQD, LMPNN, and FIT, we found that LMPNN performs generally better than CQD in SDAG, but falls behind CQD in multigraphs and cyclic graphs. We assume the reason is that LMPNN requires training while CQD does not, however, the original dataset are biased which only considers SDAG, leading to the result.\"}"}
{"id": "r8PnfcWQol", "page_num": 1, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"To answer complex queries on knowledge graphs, logical reasoning over incomplete knowledge needs learning-based methods because they are capable of generalizing over unobserved knowledge. Therefore, an appropriate dataset is fundamental to both obtaining and evaluating such methods under this paradigm. In this paper, we propose a comprehensive framework for data generation, model training, and method evaluation that covers the combinatorial space of Existential First-order Queries with multiple variables ($EFO_k$). The combinatorial query space in our framework significantly extends those defined by set operations in the existing literature. Additionally, we construct a dataset, $EFO_k$-CQA, with 741 query types for empirical evaluation, and our benchmark results provide new insights into how query hardness affects the results. Furthermore, we demonstrate that the existing dataset construction process is systematically biased and hinders the appropriate development of query-answering methods, highlighting the importance of our work. Our code and data are provided in https://anonymous.4open.science/r/EFOK-CQA/README.md\\n\\nIntroduction\\n\\nThe Knowledge Graph (KG) is a powerful database that encodes relational knowledge into a graph representation [34, 31], supporting downstream tasks [41, 8] with essential factual knowledge. However, KGs suffer from incompleteness during its construction [34, 7, 19]. The task of Complex Query Answering (CQA) proposed recently has attracted much research interest [13, 28]. This task ambitiously aims to answer database-level complex queries described by logical complex connectives (conjunction $\\\\land$, disjunction $\\\\lor$, and negation $\\\\neg$) and quantifiers (existential $\\\\exists$) [37, 27, 18]. Currently, learning-based methods dominate the CQA tasks because they can empirically generalize to unseen knowledge as well as prevent the resource-demanding symbolic search.\\n\\nThe thriving of learning-based methods also puts an urgent request on high-quality benchmarks, including datasets with comprehensive coverage of queries and sound answers, and fair evaluation protocol for learning-based approaches. In the previous study, datasets are developed by progressively expanding the syntactical expressiveness, where conjunction [13], union [26], negation [28], and other operators [20] are taken into account sequentially. In particular, BetaE dataset [28] contains all logical connectives and becomes the standard training set for model development. A larger CQA on KG [37, 27] and database query answering [25].\\n\\nSubmitted to the 38th Conference on Neural Information Processing Systems (NeurIPS 2024) Track on Datasets and Benchmarks. Do not distribute.\"}"}
{"id": "r8PnfcWQol", "page_num": 2, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"evaluation benchmark EFO-1-QA [36] was proposed to systematically evaluate the combinatorial generalizability of CQA models on such queries. More related works are included in Appendix A. However, the queries in previous datasets [28, 36] are recently justified as \u201cTree-Form\u201d queries [39] as they rely on the tree combinations of set operations. Compared to the well-established TPC-H decision support benchmark [25] for database query processing, queries in existing CQA benchmarks [28, 36] have two common shortcomings: (1) lack of combinatorial answers: only one variable is queried, and (2) lack of structural hardness: all existing queries subject to the structure-based tractability [29, 37, 39]. It is rather questionable whether existing CQA data under such limited scope can support the future development of methodologies for general decision support with incomplete knowledge. The goal of this paper is to establish a new framework that addresses the aforementioned shortcomings to support further research in complex query answering on knowledge graphs. Our framework is formally motivated by the well-established investigation of constraint satisfaction problems [29], in which all queries can be formulated. In general, the contribution of our work is four folds.\\n\\nComplete coverage\\nWe capture the complete Existential First Order (EFO) queries from their rigorous definitions, underscoring both combinatorial hardness and structural hardness and extending the existing coverage [36] which covers only a subset of EFO query. The captured query family is denoted as EFO\\\\(^k\\\\) where \\\\(k\\\\) stands for multiple variables.\\n\\nCurated datasets\\nWe derive EFO\\\\(^k\\\\)-CQA dataset, a enormous extension of the previous EFO-1-QA benchmark [36] and contains 741 types of query. We design several systematic rules to guarantee that our dataset includes high-quality nontrivial queries, particularly those that contain multiple query variables and are not structure-based tractable.\\n\\nConvenient implementation\\nWe implement the entire pipeline for query generation, answer sampling, model training and inference, and evaluation for the undiscussed scenarios of combinatorial answers. Our pipeline is backward compatible, which supports both set operation-based methods and more recent ones.\\n\\nResults and findings\\nWe evaluate six representative CQA methods on our benchmark. Our results refresh the previous empirical findings and further reveal the structural bias of previous data.\\n\\n2 Problem definition\\n2.1 Existential first order (EFO) queries on knowledge graphs\\n\\nGiven a set \\\\(E\\\\) of entities and a set \\\\(R\\\\) of relations, a knowledge graph \\\\(KG\\\\) encodes knowledge as a set of factual triple \\\\(KG \\\\{h, r, t \\\\in E \\\\land R \\\\land E\\\\}\\\\). We always assume the KG that we have observed \\\\(KG_o\\\\) is only part of the real KG, meaning that \\\\(KG_o \\\\subseteq KG\\\\).\\n\\nThe existing research only focuses on the logical formulas without universal quantifiers [27, 35]. We then offer the definition of it based on strict first order logic.\\n\\n**Definition 1** (Term). A term is either a variable \\\\(x\\\\) or an entity \\\\(a_P\\\\) \\\\(E\\\\).\\n\\n**Definition 2** (Atomic formula). \\\\(\\\\varphi\\\\) is an atomic formula if \\\\(\\\\varphi = \\\\langle r, p \\\\rangle h, t\\\\), where \\\\(r_P\\\\) \\\\(R\\\\) is a relation, \\\\(h\\\\) and \\\\(t\\\\) are two terms.\\n\\n**Definition 3** (Existential first order formula). The set of the existential formulas is the smallest set \\\\(\\\\Phi\\\\) satisfying the following 2:\\n\\n(i) For atomic formula \\\\(\\\\langle r, p \\\\rangle h, t\\\\) \\\\(\\\\varphi\\\\), itself and its negation \\\\(\\\\langle r, p \\\\rangle h, t\\\\) \\\\(\\\\not\\\\varphi\\\\), \\\\(\\\\varphi, \\\\not\\\\varphi \\\\in \\\\Phi\\\\).\\n\\n(ii) If \\\\(\\\\varphi, \\\\psi \\\\in \\\\Phi\\\\), then \\\\(\\\\langle r, p \\\\rangle h, t\\\\) \\\\(\\\\varphi \\\\land \\\\psi\\\\), \\\\(\\\\varphi \\\\lor \\\\psi \\\\in \\\\Phi\\\\).\\n\\n(iii) If \\\\(\\\\varphi \\\\in \\\\Phi\\\\) and \\\\(x_i\\\\) is any variable, then \\\\(D_{x_i} \\\\varphi \\\\in \\\\Phi\\\\).\\n\\n**Definition 4** (Free variable). If a variable \\\\(y\\\\) is not associated with an existential quantifier, it is called a free variable, otherwise, it is called a bounded variable. We write \\\\(\\\\varphi[y_1, \\\\ldots, y_k]\\\\) to indicate \\\\(y_1, \\\\ldots, y_k\\\\) are the free variables of \\\\(\\\\varphi\\\\)\"}"}
{"id": "r8PnfcWQol", "page_num": 3, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"\\\\[ \\\\exists x_1. \\\\text{Award}(\\\\text{Fields}, y_1) \\\\land \\\\neg \\\\text{Award}(\\\\text{Fields}, y_2) \\\\land \\\\text{Colleague}(y_1, y_2) \\\\land \\\\text{Born}(y_1, x_1) \\\\land \\\\text{Born}(y_1, x_2) \\\\]\\n\\n\\\\[ \\\\exists x_1. \\\\text{Located}(\\\\text{Europe}, x_1) \\\\land \\\\neg \\\\text{Held}(\\\\text{Olympics}, x_1) \\\\land \\\\text{Presdient}(x_1, y_1) \\\\]\\n\\nFigure 1: Operator Tree versus Query Graph. \\n\\nLeft: An operator tree representing a given query \\\"List the presidents of European countries that have never held the Olympics\\\" \\n\\nRight: A query graph representing a given query \\\"Find a pair of persons who are both colleagues and co-authors and were born in the same country, with one having awarded the fields medal while the another not\\\", which is both a multigraph and a cyclic graph, containing two free variables.\\n\\nDefinition 5 (Sentence and query). A formula \\\\( \\\\varphi \\\\) is a sentence if it contains no free variables, otherwise, it is called a query. In this paper, we always consider formula with free variables, thus, we use formula and query interchangeably.\\n\\nDefinition 6 (Substitution). For \\\\( a_1, \\\\ldots, a_k \\\\), where \\\\( a_i \\\\in \\\\mathcal{P}_E \\\\), we write \\\\( \\\\varphi \\\\varphi_{a_1} \\\\{ y_1, \\\\ldots, a_k \\\\} \\\\) or simply \\\\( \\\\varphi_{a_1, \\\\ldots, a_k} \\\\) for the result of simultaneously replacing all the occurrence of \\\\( y_i \\\\) in \\\\( \\\\varphi \\\\) by \\\\( a_i \\\\), \\\\( i = 1, \\\\ldots, k \\\\).\\n\\nDefinition 7 (Answer of an EFO query). For a given existential query \\\\( \\\\varphi \\\\varphi_{y_1, \\\\ldots, y_k} \\\\) and a knowledge graph \\\\( \\\\mathcal{K} \\\\), its answer is a set that defined by \\\\( A_{\\\\gamma_1 \\\\varphi_{y_1, \\\\ldots, y_k} } = \\\\{ a \\\\mid a \\\\in \\\\mathcal{E}, a \\\\notin \\\\mathcal{E} \\\\} \\\\) is True in \\\\( \\\\mathcal{K} \\\\).\\n\\nDefinition 8 (Disjunctive Normal Form (DNF)). For any existential formula \\\\( \\\\varphi \\\\varphi_{y_1, \\\\ldots, y_k} \\\\), it can be converted to the Disjunctive normal form as shown below:\\n\\n\\\\[ \\\\varphi \\\\varphi_{y_1, \\\\ldots, y_k} \\\\Rightarrow \\\\gamma_1 \\\\varphi_{y_1, \\\\ldots, y_k} \\\\land \\\\ldots \\\\land \\\\gamma_m \\\\varphi_{y_1, \\\\ldots, y_k} \\\\]\\n\\nwhere \\\\( \\\\gamma_i \\\\varphi_{y_1, \\\\ldots, y_k} \\\\) is either an atomic formula or its negation, \\\\( x_i \\\\) is called an existential variable.\\n\\nThe DNF form has a strong property that \\\\( A_{\\\\gamma_1 \\\\varphi_{y_1, \\\\ldots, y_k}} \\\\cap \\\\ldots \\\\cap \\\\gamma_m \\\\varphi_{y_1, \\\\ldots, y_k} = A_{\\\\gamma_1 \\\\varphi_{y_1, \\\\ldots, y_k}} \\\\), which allows us to only consider conjunctive formulas and then aggregate those answers to retrieve the final answers. This practical technique has been used in many previous research [22, 27]. Therefore, we only discuss conjunctive formulas in the rest of this paper.\\n\\n2.2 Constraint satisfaction problem for EFO queries\\n\\nFormally, a Constraint Satisfaction Problem (CSP) \\\\( P \\\\) can be represented by a triple \\\\( P = (X, D, C) \\\\) where \\\\( X = (v_1, \\\\ldots, v_n) \\\\) is an \\\\( n \\\\)-tuple of variables, \\\\( D = (D_1, \\\\ldots, D_n) \\\\) is the corresponding \\\\( n \\\\)-tuple of domains, \\\\( C = (C_1, \\\\ldots, C_t) \\\\) is \\\\( t \\\\)-tuple constraint, each constraint \\\\( C_i \\\\) is a pair of \\\\( (S_i, R_{S_i}) \\\\) where \\\\( S_i \\\\) is a set of variables \\\\( S_i = (v_i_1, \\\\ldots, v_i_u) \\\\) and \\\\( R_{S_i} \\\\) is the constraint over those variables [29].\\n\\nHistorically, there are strong parallels between CSP and conjunctive queries in knowledge bases [10, 17]. The terms correspond to the variable set \\\\( X \\\\). The domain \\\\( D_i \\\\) of a constant entity contains only itself, while it is the whole entity set \\\\( \\\\mathcal{E} \\\\) for other variables. Each constraint \\\\( C_i \\\\) is binary that is induced by an atomic formula or its negation, for example, for an atomic formula \\\\( r_{h, t} \\\\), we have \\\\( S_i = (h, t, u) \\\\) and \\\\( R_{S_i} = \\\\varphi_{h, t} | h, t \\\\in \\\\mathcal{E}, P_{KG} u \\\\). Finally, by the definition of existential quantifier, we only consider the answer of free variables, rather than tracking all terms within the existential formulas.\\n\\nDefinition 9 (CSP answer of conjunctive formula). For a conjunctive formula \\\\( \\\\varphi \\\\) in Equation 2 with \\\\( k \\\\) free variables and \\\\( n \\\\) existential variables, the answer set, \\\\( A \\\\), of it formulated as CSP instance is:\\n\\n\\\\[ A_{\\\\gamma \\\\varphi_{y_1, \\\\ldots, y_k}} = \\\\{ a \\\\mid a \\\\in \\\\mathcal{E}, a \\\\notin \\\\mathcal{E} \\\\} \\\\]\\n\\nThis shows that the inference of existential formulas is easier than solving CSP instances since the existential variables do not need to be kept track of.\"}"}
{"id": "r8PnfcWQol", "page_num": 4, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 2: Left: Example of trivial abstract query graph, in the upper left graph, $x_1$ is redundant violating Assumption 13, in the bottom left graph, answers for the whole query can be decomposed to answer two free variables $y_1$ and $y_2$ alone, violating Assumption 14. Right: Example of new query graph that is not included in previous benchmark [36] even though it can be represented by operator-tree. The representation of query graph follows Figure 1.\\n\\n2.3 The representation of existential formula\\n\\nTo give an explicit representation of existential formula, operator tree [13] was proposed to represent a formula, where each node represents the answer set for a sub-query, and the logic operators in it naturally represent set operations. This method allows for the recursive computation from constant entity to the final answer set in a bottom-up manner [28]. We also provide full details of the operator tree and tree-form query in Appendix C. However, this representation method is inherently directed, acyclic, and simple, therefore more recent research breaks these constraints by being bidirectional [21, 37] or being cyclic or multi graph [39]. To meet these new requirements, they propose to represent the formula by the query graph [39], which inherits the convention of constraint network in representing CSP instance. We utilize this design and further extend it to represent EFO$_k$ formula that contains multiple free variables. We provide the illustration and comparison of the operator tree and the query graph in Figure 1, where we show the strong expressiveness of the query graph. We also provide the formal definition of query graph as follows:\\n\\nDefinition 10 (Query graph). Let $\\\\gamma$ be a conjunctive formula in equation 2, its query graph is defined by $G_{p\\\\gamma q}^{h, r, t, T/F}$, where an atomic formula $r_{p h, t q}$ in $\\\\gamma$ corresponds to $p_{h, r, t, T q}$ and $r_{p h, t q}$ corresponds to $p_{h, r, t, F q}$.\\n\\nTherefore, any conjunctive formulas can be represented by a query graph, in the rest of the paper, we use query graphs and conjunctive formulas interchangeably.\\n\\n3 The combinatorial space of EFO$_k$ queries\\n\\nAlthough previous research has given a systematic investigation in the combinatorial space of operator trees [36], the combinatorial space of the query graph is much more challenging due to the extremely large search space and the lack of explicit recursive formulation. To tackle this issue on a strong theoretical background, we put forward additional assumptions to exclude trivial query graphs. Such assumptions or restrictions also exist in the previous dataset and benchmark [28, 36]. Specifically, we propose to split the task of generating data into two levels, the abstract level, and the grounded level. At the abstract level, we create abstract query graph, at the grounded level, we provide the abstract query graph with the relation and constant and instantiate it as a query graph. In this section, we elaborate on how we investigate the scope of the nontrivial EFO$_k$ query of interest step by step.\\n\\n3.1 Nontrivial abstract query graph of EFO$_k$\\n\\nThe abstract query graph is the ungrounded query graph without information of certain knowledge graphs, and we give an example in Figure 3.\\n\\nDefinition 11 (Abstract query graph). The abstract query graph $G_{p V, E, f, g q}$ is a directed graph with three node types, $t$ Constant Entity, Existential Variable, Free Variable $u$, and two edge types, $t$ positive, negative $u$. The $V$ is the set of nodes, $E$ is the set of directed edges, $f$ is the function maps node to node type, $g$ is the function maps edge to edge type.\\n\\nDefinition 12 (Grounding). For an abstract query graph $G_p$, a grounding is a function $I$ that maps it into a query graph $G_p^I G_q$. \\n\\n4\"}"}
{"id": "r8PnfcWQol", "page_num": 13, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"**A. Related works**\\n\\nAnswering complex queries on knowledge graphs differs from database query answering by being a data-driven task [37], where the incompleteness of the knowledge graph is addressed by methods that learn from data. Meanwhile, learning-based methods enable faster neural approximate solutions of symbolic query answering problems [27].\\n\\nThe prevailing way is query embedding, where the computational results are embedded and computed in the low-dimensional embedding space. Specifically, the query embedding over the set operator trees is the earliest proposed [13]. The supported set operators include projection [13], intersection [26], union and negation [28], and later on be improved by various designs [40, 3]. Such methods assume queries can be converted into the recursive execution of set operations, which imposes additional assumptions on the solvable class of queries [36]. These assumptions introduce additional limitations of such query embeddings.\\n\\nRecent advancements in query embedding methods adapt query graph representation and graph neural networks, supporting atomics [21] and negated atomics [35]. Query embedding on graphs bypasses the assumptions for queries [36]. Meanwhile, other search-based inference methods [2, 39] are rooted in fuzzy calculus and not subject to the query assumptions [36].\\n\\nThough many efforts have been made, the datasets of complex query answering are usually subject to the assumptions by set operator query embeddings [36]. Many other datasets are proposed to enable queries with additional features, see [27] for a comprehensive survey of datasets. However, only one small dataset proposed by [39] introduced queries and answers beyond such assumptions [36]. It is questionable that this small dataset is fair enough to justify the advantages claimed in advancement methods [35, 39] that aim at complex query answering. The dataset [39] is still far away from the systematical evaluation as proposed in [36] and EFO_k-CQA proposed in this paper fills this gap.\\n\\n**B. Details of constraint satisfaction problem**\\n\\nIn this section, we introduce the constraint satisfaction problem (CSP) again. One instance of CSP $P$ can be represented by a triple $P = \\\\langle X, D, C \\\\rangle$ where $X = \\\\langle x_1, \\\\ldots, x_n \\\\rangle$ is an $n$-tuple of variables,\"}"}
{"id": "r8PnfcWQol", "page_num": 14, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"D.1 Enumeration of the abstract query graphs\\n\\nWe first give a proposition of the property of abstract query graph:\\n\\n**Proposition 18.** For an abstract query graph $G$, if it conforms Assumption 13 and Assumption 14, then removing all constant entities in $G$ will lead to only one connected component and no edge is connected between two constant entities.\"}"}
{"id": "r8PnfcWQol", "page_num": 15, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 5: The four steps of enumerating the abstract query graphs. We note that the example and representation follow Figure 3.\\n\\nProof. We prove this by contradiction. If there is an edge (whether positive or negative) between constant entities, then this edge is redundant, violating Assumption 13. Then, if there is more than one connected component after removing all constant entities in $G$, suppose one connected component has no free variable, then this part is a sentence and thus has a certain truth value, whether 0 or 1, which is redundant, violating Assumption 13. Then, we assume every connected component has at least one free variable, we assume there is $m$ connected component and we have:\\n\\n$$\\\\text{Node } p \\\\in G \\\\text{q} \\\\cap \\\\bigcup_{i=1}^{m} \\\\text{Node } p \\\\in G \\\\text{i} \\\\text{q} \\\\cap \\\\text{Node } p \\\\in G \\\\text{c} \\\\text{q}$$\\n\\nwhere $m \\\\geq 1$, the $G \\\\text{c} \\\\text{q}$ is the set of constant entities and each $G \\\\text{i} \\\\text{q}$ is the connected component, we use $\\\\text{Node } p \\\\in G \\\\text{q}$ to denote the node set for a graph $G$. Then this equation describes the partition of the node set of the original $G$.\\n\\nThen, we construct $G \\\\text{a} \\\\text{q} = G \\\\text{r} \\\\text{p} \\\\in G \\\\text{1} \\\\text{q} \\\\cap G \\\\text{c} \\\\text{q}$ and $G \\\\text{b} \\\\text{q} = G \\\\text{r} \\\\text{p} \\\\in \\\\bigcup_{i=1}^{m} \\\\text{Node } p \\\\in G \\\\text{i} \\\\text{q} \\\\cap G \\\\text{c} \\\\text{q}$, where $G \\\\text{rep}$ represents the induced graph. Then we naturally have that $A \\\\text{r} \\\\text{I} \\\\text{p} \\\\in G \\\\text{a} \\\\text{q} = A \\\\text{r} \\\\text{I} \\\\text{p} \\\\in G \\\\text{b} \\\\text{q}$, where the $\\\\bigcap$ represents the Cartesian product, violating Assumption 14.\\n\\nAdditionally, as mentioned in Appendix B, the negative constraint is less \\\"strict\\\", we formally put an additional assumption of the real knowledge graph as the following:\\n\\nAssumption 19. For any knowledge graph $KG$, with its entity set $E$ and relations set $R$, we assume it is somewhat sparse with regard to each relation, meaning: for any $r \\\\in R$, $|t_a \\\\in E| \\\\leq |D_b|$. Then we develop another proposition for the abstract query graph:\\n\\nProposition 20. With the knowledge graph conforming Assumption 19, for any node $u$ in the abstract query graph $G$, if $u$ is an existential variable or free variable, then it can not only connect with negative edges.\\n\\nProof. Suppose $u$ only connects to $m$ negative edge $e_1, \\\\ldots, e_m$. For any grounding $I$, we assume $I \\\\in e_i \\\\in R$. For each $r_i$, we construct its endpoint set $\\\\text{Endpoint } r_i \\\\text{q} = t_a \\\\in E \\\\mid D_b$. $p_{a, r, b} \\\\in KG$ or $p_{b, r, a} \\\\in KG$. By the assumption 19, we have $|\\\\text{Endpoint } r_i \\\\text{q}|! \\\\in E$, then we have:\\n\\n$$|\\\\bigcup_{i=1}^{m} \\\\text{Endpoint } r_i \\\\text{q}| \\\\leq \\\\sum_{i=1}^{m} |\\\\text{Endpoint } r_i \\\\text{q}| \\\\leq |E|$$\\n\\nsince $m$ is small due to the size of the abstract query graph. Then we have two situations about the type of node $u$:\\n\\n1. If node $u$ is an existential variable. Then we construct a subgraph $G \\\\text{s} \\\\text{q}$ be the induced subgraph of $\\\\text{Node } p \\\\in G \\\\text{q} \\\\setminus u$, then for any possible grounding $I$, we prove that $A \\\\text{r} \\\\text{I} \\\\text{p} \\\\in G \\\\text{s} \\\\text{q} = A \\\\text{r} \\\\text{I} \\\\text{p} \\\\in G \\\\text{qs}$, the right is clearly a subset of the left due to it...\"}"}
{"id": "r8PnfcWQol", "page_num": 16, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"contains more constraints, then we show every answer of the left is also an answer on the right, we merely need to give an appropriate candidate in the entity set for node $v$, and in fact, we choose any entity in the set $E_{1} \\\\subseteq \\\\text{Endpoint}$ since it suffices to satisfies all constraints of node $u$, and we have proved that $|E_{1} \\\\subseteq \\\\text{Endpoint}| > 0$.\\n\\n2. If node $u$ is a free variable.\\n\\nSimilarly, any entity in the set $E_{1} \\\\subseteq \\\\text{Endpoint}$ will be an answer for the node $u$, thus violating the Assumption 16.\\n\\nWe note the proposition 20 extends the previous requirement about negative queries, which is firstly proposed in [28] and inherited and named as \\\"bounded negation\\\" in [36], the \\\"bounded negation\\\" requires the negation operator should be followed by the intersection operator in the operator tree. Obviously, the abstract query graph that conforms to \\\"bounded negation\\\" will also conform to the requirement in Proposition 20. A vivid example is offered in Figure 2.\\n\\nFinally, we make the assumption of the distance to the free variable of the query graph:\\n\\nAssumption 21. There is a constant $d$, such that for every node $u$ in the abstract query graph $G$, it can find a free variable in its $d$-hop neighbor.\\n\\nWe have this assumption to exclude the extremely long-path queries.\\n\\nEquipped with the propositions and assumptions above, we explore the combinatorial space of the abstract query graph given certain hyperparameters, including: the max number of free variables, max number of existential variables, max number of constant entities, max number of all nodes, max number of all edges, max number of edges surpassing the number of nodes, max number of negative edge, max distance to the free variable. In practice, these numbers are set to be: 2, 2, 3, 6, 6, 0, 1, 3.\\n\\nWe note that the max number of edges surpassing the number of nodes is set to 0, which means that the query graph can at most have one more edge than a simple tree, thus, we exclude those query graphs that are both cyclic graphs and multigraphs, making our categorization and discussion in the experiments in Section 5.2 and Section 5.3 much more straightforward and clear.\\n\\nThen, we create the abstract query graph by the following steps, which is a graph with three types of nodes and two kinds of edges:\\n\\n1. First, create a simple connected graph $G_1$ with two types of nodes, the existential variable and the free variable, and one type of edge, the positive edge.\\n\\n2. We add additional edges to the simple graph $G_1$ and make it a multigraph $G_2$.\\n\\n3. Then, the constant variable is added to the graph $G_2$, In this step, we make sure not too long existential leaves. The result is graph $G_3$.\\n\\n4. Finally, random edges in $G_3$ are replaced by the negation edge, and we get the final abstract query graph $G_4$.\\n\\nIn this way, all possible query graphs within a certain combinatorial space are enumerated, and finally, we filter duplicated graphs with the help of the graph isomorphism algorithm. We give an example to illustrate the four-step construction of an abstract query graph in Figure 5.\\n\\nD.2 Ground abstract query graph with meaningful negation\\n\\nTo fulfill the Assumption 15 as discussed in Section 4.2, for an abstract query graph $G = (V, E, f, g)$, we have two steps: (1). Sample grounding for the positive subgraph $G_p$ and compute its answer (2). Ground the $G_n$ to decrease the answer got in the first step. Then we define positive subgraph $G_p$ to be defined as such, its edge set $E_1 = \\\\{e \\\\mid g(e) = \\\\text{positive} u\\\\}$, its node set $V_1 = \\\\{u \\\\mid u \\\\in V, \\\\text{D}e\\\\}$. \"}"}
{"id": "r8PnfcWQol", "page_num": 9, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 2: HIT@10 scores(%) of three different types for answering queries with two free variables on FB15k-237. The constant number is fixed to be two. \\n\\n| Model       | e | 0  | 1  | 2  |\\n|-------------|---|----|----|----|\\n| BetaE       |   | 54.5 | 50.2 | 49.5 | 46.0 | 58.8 | 37.2 | 35.5 | 58.3 | 43.8 |\\n|            |   | Multiply | 27.3 | 22.4 | 22.3 | 16.9 | 26.2 | 16.9 | 13.9 | 25.7 | 18.3 |\\n|            |   | Joint | 6.3 | 5.4 | 5.2 | 4.2 | 10.8 | 2.2 | 2.3 | 9.5 | 4.5 |\\n| LogicE      |   | 58.2 | 50.9 | 52.2 | 47.4 | 60.4 | 37.7 | 35.8 | 59.2 | 44.6 |\\n|            |   | Multiply | 32.1 | 23.1 | 24.9 | 18.1 | 28.3 | 18.1 | 14.8 | 26.6 | 19.5 |\\n|            |   | Joint | 6.8 | 6.0 | 6.1 | 4.5 | 12.3 | 2.5 | 2.7 | 10.3 | 5.1 |\\n| ConE        |   | 60.3 | 53.8 | 54.2 | 50.3 | 66.2 | 40.1 | 38.5 | 63.7 | 47.7 |\\n|            |   | Multiply | 33.7 | 25.2 | 26.1 | 19.8 | 32.1 | 19.5 | 16.3 | 30.3 | 21.5 |\\n|            |   | Joint | 6.7 | 6.4 | 6.2 | 4.8 | 12.6 | 2.6 | 2.7 | 10.9 | 5.3 |\\n| CQD         |   | 50.4 | 46.5 | 49.1 | 45.6 | 59.7 | 33.5 | 33.1 | 61.5 | 42.8 |\\n|            |   | Multiply | 28.9 | 23.4 | 25.4 | 19.5 | 31.3 | 17.8 | 16.0 | 30.5 | 21.0 |\\n|            |   | Joint | 8.0 | 8.0 | 7.4 | 6.0 | 13.9 | 3.6 | 3.9 | 12.0 | 6.4 |\\n| LMPNN       |   | 58.4 | 51.1 | 54.9 | 49.2 | 64.7 | 39.6 | 36.1 | 58.7 | 45.4 |\\n|            |   | Multiply | 35.0 | 26.7 | 29.2 | 21.7 | 33.4 | 21.4 | 17.0 | 28.4 | 22.2 |\\n|            |   | Joint | 7.6 | 7.5 | 7.1 | 5.3 | 12.9 | 2.8 | 2.9 | 9.5 | 5.2 |\\n| FIT         |   | 64.3 | 61.0 | 63.1 | 60.7 | 58.5 | 49.0 | 49.1 | 60.2 | 54.3 |\\n|            |   | Multiply | 39.7 | 32.2 | 35.9 | 27.8 | 27.4 | 29.5 | 26.8 | 32.4 | 29.2 |\\n|            |   | Joint | 9.0 | 7.8 | 6.5 | 6.5 | 10.1 | 3.7 | 4.6 | 10.6 | 6.4 |\\n\\nthat LMPNN doesn't generalize well to the unseen tasks with different topology property. We expect future CQA models may use our framework to address this issue and gain better generalization.\\n\\nMoreover, by the detailed observation in Figure 4, we plot two boxes. In the red box, we find that even the worst model and the best model have pretty similar performance in these easiest queries despite that they may differ greatly in other queries. In the black box, we note that CQD [2], though designed in a rather general form, is pretty unstable when comes to empirical evaluation, as it has a clear downward curve and deviates from other model's performance enormously in most difficult query types. Therefore, though its performance is better than LMPNN on average as reported in Table 1, its unsteady performance suggests its inherent weakness, especially when the users are risk-sensitive and desire a trustworthy machine-learning model that does not crash in extreme cases [33].\\n\\nWe note FIT is designed to infer all EFO$^k$ queries and is indeed able to outperform other models in almost all breakdowns, however, its performance comes with the price of computational cost, and face challenges in cyclic graph where it degenerates to enumeration: we further explain in Appendix F.\\n\\n5.3 Benchmark results for $k = 2$\\n\\nAs we have explained in Section 4.5, we propose three kinds of metrics, marginal ones, multiply ones, and joint ones, from easy to hard, to evaluate the performance of a model in the scenario of multiple variables. The evaluation result is shown in Table 2. As the effect of the number of constant variables is quite clear, we remove it and add the metrics based on HIT@10 as the new factor.\\n\\nFor the impact regarding the number of existential variables and the topology property of the query graph, we find the result is similar to Table 1, which may be explained by the fact that those models are all initially designed to infer queries with one free variable. For the three metrics we have proposed, we have identified a clear difficulty difference among them though they generally show similar trends. The scores of joint HIT@10 are pretty low, indicating the great hardness of answering queries with multiple variables. Moreover, we have found that FIT falls behind other models in some breakdowns which are mostly cyclic graphs, corroborating our discussion in Section 5.2. We offer more experiment results and further discussion in Appendix H.\\n\\n6 Conclusion\\n\\nIn this paper, we make a thorough investigation of the family of EFO$^k$ formulas based on a strong theoretical background. We then present a new powerful framework that supports several functionalities essential to CQA task, and build the EFO$^k$-CQA dataset that greatly extends the previous datasets. Our evaluation result brings new empirical findings and reflects the biased selection in the previous dataset impairs the performance of CQA models, emphasizing the contribution of our work.\"}"}
{"id": "r8PnfcWQol", "page_num": 10, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"[1] Dimitrios Alivanistos, Max Berrendorf, Michael Cochez, and Mikhail Galkin. Query Embedding on Hyper-relational Knowledge Graphs, September 2022. arXiv:2106.08166 [cs].\\n\\n[2] Erik Arakelyan, Daniel Daza, Pasquale Minervini, and Michael Cochez. Complex Query Answering with Neural Link Predictors. In International Conference on Learning Representations, 2020.\\n\\n[3] Jiaxin Bai, Zihao Wang, Hongming Zhang, and Yangqiu Song. Query2Particles: Knowledge Graph Reasoning with Particle Embeddings. In Findings of the Association for Computational Linguistics: NAACL 2022, pages 2703\u20132714, 2022.\\n\\n[4] Yushi Bai, Xin Lv, Juanzi Li, and Lei Hou. Answering Complex Logical Queries on Knowledge Graphs via Query Computation Tree Optimization. In Proceedings of the 40th International Conference on Machine Learning, pages 1472\u20131491. PMLR, July 2023. ISSN: 2640-3498.\\n\\n[5] Antoine Bordes, Nicolas Usunier, Alberto Garcia-Duran, Jason Weston, and Oksana Yakhnenko. Translating Embeddings for Modeling Multi-relational Data. In Advances in Neural Information Processing Systems, volume 26. Curran Associates, Inc., 2013.\\n\\n[6] Cl\u00e9ment Carbonnel and Martin C Cooper. Tractability in constraint satisfaction problems: a survey. Constraints, 21(2):115\u2013144, 2016. Publisher: Springer.\\n\\n[7] Andrew Carlson, Justin Betteridge, Bryan Kisiel, Burr Settles, Estevam Hruschka, and Tom Mitchell. Toward an architecture for never-ending language learning. In Proceedings of the AAAI conference on artificial intelligence, volume 24, pages 1306\u20131313, 2010. Issue: 1.\\n\\n[8] Lisa Ehrlinger and Wolfram W\u00f6\u00df. Towards a definition of knowledge graphs. SEMANTiCS (Posters, Demos, SuCCESS), 48(1-4):2, 2016.\\n\\n[9] Michael Galkin, Zhaocheng Zhu, Hongyu Ren, and Jian Tang. Inductive logical query answering in knowledge graphs. Advances in Neural Information Processing Systems, 35:15230\u201315243, 2022.\\n\\n[10] Georg Gottlob, Nicola Leone, and Francesco Scarcello. Hypertree decompositions and tractable queries. In Proceedings of the eighteenth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems, pages 21\u201332, 1999.\\n\\n[11] Georg Gottlob, Nicola Leone, and Francesco Scarcello. A comparison of structural CSP decomposition methods. Artificial Intelligence, 124(2):243\u2013282, December 2000.\\n\\n[12] Gianluigi Greco and Francesco Scarcello. On The Power of Tree Projections: Structural Tractability of Enumerating CSP Solutions. Constraints, 18(1):38\u201374, January 2013. arXiv:1005.1567 [cs].\\n\\n[13] Will Hamilton, Payal Bajaj, Marinka Zitnik, Dan Jurafsky, and Jure Leskovec. Embedding logical queries on knowledge graphs. Advances in neural information processing systems, 31, 2018.\\n\\n[14] Zhiwei Hu, V\u00edctor Guti\u00e9rrez-Basulto, Zhiliang Xiang, Xiaoli Li, and Jeff Pan. Type-aware Embeddings for Multi-Hop Reasoning over Knowledge Graphs. May 2022.\\n\\n[15] Qian Huang, Hongyu Ren, and Jure Leskovec. Few-shot relational reasoning via connection subgraph pretraining. Advances in Neural Information Processing Systems, 35:6397\u20136409, 2022.\\n\\n[16] Zhen Jia, Soumajit Pramanik, Rishiraj Saha Roy, and Gerhard Weikum. Complex Temporal Question Answering on Knowledge Graphs. In Proceedings of the 30th ACM International Conference on Information & Knowledge Management, CIKM \u201921, pages 792\u2013802, New York, NY, USA, 2021. Association for Computing Machinery.\"}"}
{"id": "r8PnfcWQol", "page_num": 11, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"1. Phokion G Kolaitis and Moshe Y Vardi. Conjunctive-query containment and constraint satisfaction. In Proceedings of the seventeenth ACM SIGACT-SIGMOD-SIGART symposium on Principles of database systems, pages 205\u2013213, 1998.\\n\\n2. Jure Leskovec. Databases as Graphs: Predictive Queries for Declarative Machine Learning. In Proceedings of the 42nd ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS '23, page 1, New York, NY, USA, 2023. Association for Computing Machinery.\\n\\n3. Leonid Libkin and Cristina Sirangelo. Open and Closed World Assumptions in Data Exchange. Description Logics, 477, 2009.\\n\\n4. Lihui Liu, Boxin Du, Heng Ji, ChengXiang Zhai, and Hanghang Tong. Neural-Answering Logical Queries on Knowledge Graphs. In Proceedings of the 27th ACM SIGKDD Conference on Knowledge Discovery & Data Mining, pages 1087\u20131097, 2021.\\n\\n5. Xiao Liu, Shiyu Zhao, Kai Su, Yukuo Cen, Jiezhong Qiu, Mengdi Zhang, Wei Wu, Yuxiao Dong, and Jie Tang. Mask and Reason: Pre-Training Knowledge Graph Transformers for Complex Logical Queries. In Proceedings of the 28th ACM SIGKDD Conference on Knowledge Discovery and Data Mining, pages 1120\u20131130, August 2022. arXiv:2208.07638 [cs].\\n\\n6. Xiao Long, Liansheng Zhuang, Li Aodi, Shafei Wang, and Houqiang Li. Neural-based Mixture Probabilistic Query Embedding for Answering FOL queries on Knowledge Graphs. 2022.\\n\\n7. Haoran Luo, Yuhao Yang, Gengxian Zhou, Yikai Guo, Tianyu Yao, Zichen Tang, Xueyuan Lin, Kaiyang Wan, and others. NQE: N-ary Query Embedding for Complex Query Answering over Hyper-relational Knowledge Graphs. arXiv preprint arXiv:2211.13469, 2022.\\n\\n8. Francois Luus, Prithviraj Sen, Pavan Kapanipathi, Ryan Riegel, Ndivhuwo Makondo, Thabang Lebese, and Alexander Gray. Logic embeddings for complex query answering. arXiv preprint arXiv:2103.00418, 2021.\\n\\n9. Meikel Poess and Chris Floyd. New TPC benchmarks for decision support and web commerce. ACM Sigmod Record, 29(4):64\u201371, 2000. Publisher: ACM New York, NY, USA.\\n\\n10. H Ren, W Hu, and J Leskovec. Query2box: Reasoning Over Knowledge Graphs In Vector Space Using Box Embeddings. In International Conference on Learning Representations (ICLR), 2020.\\n\\n11. Hongyu Ren, Mikhail Galkin, Michael Cochez, Zhaocheng Zhu, and Jure Leskovec. Neural Graph Reasoning: Complex Logical Query Answering Meets Graph Databases, March 2023. arXiv:2303.14617 [cs].\\n\\n12. Hongyu Ren and Jure Leskovec. Beta embeddings for multi-hop logical reasoning in knowledge graphs. Advances in Neural Information Processing Systems, 33:19716\u201319726, 2020.\\n\\n13. Francesca Rossi, Peter van Beek, and Toby Walsh. Handbook of Constraint Programming. Elsevier Science Inc., USA, 2006.\\n\\n14. Apoorv Saxena, Soumen Chakrabarti, and Partha Talukdar. Question Answering Over Temporal Knowledge Graphs, June 2021. arXiv:2106.01515 [cs].\\n\\n15. Fabian M Suchanek, Gjergji Kasneci, and Gerhard Weikum. Yago: a core of semantic knowledge. In Proceedings of the 16th international conference on World Wide Web, pages 697\u2013706, 2007.\\n\\n16. Kristina Toutanova and Danqi Chen. Observed versus latent features for knowledge base and text inference. In Proceedings of the 3rd workshop on continuous vector space models and their compositionality, pages 57\u201366, 2015.\"}"}
{"id": "r8PnfcWQol", "page_num": 12, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Kush R. Varshney. Trustworthy machine learning and artificial intelligence. XRDS: Crossroads, 393 The ACM Magazine for Students, 25(3):26\u201329, 2019.\\n\\nDenny Vrande\u010di\u0107 and Markus Kr\u00f6tzsch. Wikidata: a free collaborative knowledgebase. Communications of the ACM, 57(10):78\u201385, 2014. Publisher: ACM New York, NY, USA.\\n\\nZihao Wang, Yangqiu Song, Ginny Wong, and Simon See. Logical Message Passing Networks with One-hop Inference on Atomic Formulas. In The Eleventh International Conference on Learning Representations, 2023.\\n\\nZihao Wang, Hang Yin, and Yangqiu Song. Benchmarking the Combinatorial Generalizability of Complex Query Answering on Knowledge Graphs. Proceedings of the Neural Information Processing Systems Track on Datasets and Benchmarks, 1, December 2021.\\n\\nZihao Wang, Hang Yin, and Yangqiu Song. Logical Queries on Knowledge Graphs: Emerging Interface of Incomplete Relational Data. Data Engineering, page 3, 2022.\\n\\nZezhong Xu, Wen Zhang, Peng Ye, Hui Chen, and Huajun Chen. Neural-Symbolic Entangled Framework for Complex Query Answering, September 2022. arXiv:2209.08779 [cs].\\n\\nHang Yin, Zihao Wang, and Yangqiu Song. Rethinking existential first order queries and their inference on knowledge graphs. In The Twelfth International Conference on Learning Representations, 2024.\\n\\nZhanqiu Zhang, Jie Wang, Jiajun Chen, Shuiwang Ji, and Feng Wu. Cone: Cone embeddings for multi-hop reasoning over knowledge graphs. Advances in Neural Information Processing Systems, 34:19172\u201319183, 2021.\\n\\nTao Zhou, Jie Ren, Mat\u00fa\u0161 Medo, and Yi-Cheng Zhang. Bipartite network projection and personal recommendation. Physical review E, 76(4):046115, 2007. Publisher: APS.\\n\\nChecklist\\n\\n1. For all authors...\\n   (a) Do the main claims made in the abstract and introduction accurately reflect the paper's contributions and scope? [Yes]\\n   (b) Did you describe the limitations of your work? [Yes] We can not handle queries with the universal quantifier, meaning that we can not cover all queries that have been proposed by previous dataset and benchmarks.\\n   (c) Did you discuss any potential negative societal impacts of your work? [Yes] We have discussed the possible negative social impact, see Appendix I.\\n   (d) Have you read the ethics review guidelines and ensured that your paper conforms to them? [Yes]\\n\\n2. If you are including theoretical results...\\n   (a) Did you state the full set of assumptions of all theoretical results? [Yes] Clear assumptions are made in Section 3 to define the scope of the query we investigate.\\n   (b) Did you include complete proofs of all theoretical results? [Yes] All the proofs are provided in Appendix D.1.\\n\\n3. If you ran experiments (e.g. for benchmarks)...\\n   (a) Did you include the code, data, and instructions needed to reproduce the main experimental results (either in the supplemental material or as a URL)? [Yes] We have given the link in the abstract.\\n   (b) Did you specify all the training details (e.g., data splits, hyperparameters, how they were chosen)? [Yes] This is in Appendix F.\"}"}
{"id": "r8PnfcWQol", "page_num": 21, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"the embedding for each node in the query graph Algorithm 1, the final embedding of every free node are gotten to be the predicted answer. Especially, the node ordering we got in Algorithm 2 coincides with the natural topology ordering induced by the directed acyclic operator tree, so we can compute the embedding in the same order as the original implementation. Then, in Algorithm 1, we implement each set operation in the operator tree, including intersection, negation, and set projection. By the merit of the Disjunctive Normal Form (DNF), the union is tackled in the final step. Thus, our implementation can coincide with the original implementation in the original dataset [28].\\n\\nFor CQD [2] and LMPNN [35], their original implementation does not require the operator tree, so we just use their original implementation. Specifically, in a query graph with multiple free variables, for CQD we predict the answer for each free variable individually as taking others free variables as existential variables, for LMPNN, we just got all embedding of nodes that represent free variables.\\n\\nFor FIT [39], though it is proposed to solve EFO queries, it is computationally costly: it has a complexity of $O(p^2q)$ in the acyclic graphs and is even not polynomial in the cyclic graphs, the reason is that FIT degrades to enumeration to deal with cyclic graph. In our implementation, we further restrict FIT to at most enumerate 10 possible candidates for each node in the query graph, this practice has allowed FIT to be implemented in the dataset FB15k-237 [32]. However, it cost 20 hours to evaluate FIT on our EFOk-CQA dataset while other models only need no more than two hours.\\n\\nMoreover, for larger knowledge graph, including NELL [7] and FB15k [5], we have also encountered an out-of-memory error in a Tesla V100 GPU with 32G memory when implementing FIT, thus, we omit its result in these two knowledge graphs.\\n\\nG Extension to more complex query answering\\n\\nIn this section, we discuss possible further development in the task of complex query answering and how our work, especially our framework proposed in Section 4 can help with future development. We list some new features that may be of interest and show the maximum versatility our framework can reach. Our analysis and characterization of future queries inherit the outlook in [37] and also is based on the current development.\\n\\nInductive Reasoning\\n\\nInductive reasoning is a new trend in the field of complex query answering. Some entities [9] or even relations [15] are not seen in the training period, namely they can not be found by the observed knowledge graph $G_o$ therefore, the inductive generalization is essential for the model to infer answers. We note that our framework is powerful enough to sample inductive queries with the observed knowledge graph $G_o$ given. Therefore, the functionality of sampling inductive query is easily contained and implemented in our framework, see https://github.com/HKUST-KnowComp/EFOK-CQA. We note there we have already provided our EFOk-CQA dataset in this setting as discussed in Appendix D.4.\\n\\nN-ary relation\\n\\nN-ary relation is a relation that has $n \\\\geq 2$ corresponding entities, therefore, the factual information in the knowledge graph is not a triple but a $p^n-1$-tuple. Moreover, the query graph is also a hypergraph, making the corresponding CSP problem even harder. This is a newly introduced topic [23, 1] in complex query answering, which our framework has limitations in representing.\\n\\nKnowledge graph with attribute\\n\\nCurrently, there has been some research that has taken the additional attribute of the knowledge graph into account. Typical attributes include entity types [14], numerical literals [4], triple timestamps [16, 30], and triple probabilities [7]. We note that attributes expand the entity set $E$ from all entities to entities with attribute values, it is also possible that the relation set $R$ is also extended to contain corresponding relations, like \u201cgreater\u201d, \u201cless\u201d when dealing with numerical literals. Then, our framework can represent queries on such extended knowledge graphs like in [4], where no function like \u201cplus\u201d, or \u201cminus\u201d is considered and the predicates are also binary.\\n\\nOverall, our framework can be applied to some avant-garde problem settings given certain properties, thus those functionalities proposed in Section 4 can be useful. We hope our discussion helps with the future development of complex query answering.\"}"}
{"id": "r8PnfcWQol", "page_num": 22, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"In this section, we offer another experiment result not available to be shown in the main paper. For the purpose of supplementation, we select some representative experiment result as the experiment result is extremely complex to be categorized and be shown. We present the further benchmark result of the following: the analysis of benchmark result in detail, more than just the averaged score in Table 1 and Table 2, which is provided in Appendix H.1; result of different knowledge graphs, including NELL and FB15k, which is provided in Appendix H.2 and H.3, the situation of more constant entities since we only discuss when there are two constant entities in Table 2, the result is provided in Appendix H.4, and finally, all queries (including the queries without marginal hard answers), in Appendix H.5.\\n\\nWe note that we have explained in Section 4.5 and Appendix E that for a query with multiple free variables, some or all of the free variables may not have their marginal hard answer and thus the marginal metric can not be computed. Therefore, in the result shown in Table 2 in Section 5.3, we only conduct evaluation on those queries that both of their free variables have marginal hard answers, and we offer the benchmark result of all queries in Appendix H.5 where only two kinds of metrics are available.\\n\\nH.1 Further result and analysis of the experiment in main paper\\n\\nTo supplement the experiment result already shown in Section 5.2 and Section 5.3, we have included more benchmark results in this section. Though the averaged score is a broadly-used statistic to benchmark the model performance on our EFO queries, this is not enough and we have offered much more detail in this section.\\n\\nWhole combinatorial space helps to develop trustworthy machine learning models. Firstly, we show more detailed benchmark results of the relative performance between our selected six CQA models, the result is shown in Table 4. Specifically, we plot two boxes, the black one, including the most difficult query types, and the red box, including the easiest query types. In the easiest part, we find that even the worst model and the best model have pretty similar performance despite that they...\"}"}
{"id": "r8PnfcWQol", "page_num": 23, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 8: Query type distribution in three different datasets, BetaE one, FIT one, and the EFO 1 part in our EFO k-CQA dataset. The left part shows the histogram that represents the probability density function of each dataset. The ranking of query types is also determined by the mean HIT@10 score as in Figure 4, with the standard deviation of the performance of the six CQA models shown as the light blue error bar.\\n\\n- The performance in the most difficult query types is more important when the users are risk-sensitive and desire a trustworthy machine-learning model that does not crash in extreme cases [33] and we highlight it in the black box. In the black box, we note that CQD [2], though designed in a rather general form, is pretty unstable when comes to empirical evaluation, as it has a clear downward curve and deviates from other model's performance enormously in the most difficult query types. Therefore, though its performance is better than LMPNN and comparable to BetaE on average as reported in Table 1, its unsteady performance suggests its inherent weakness.\\n\\n- On the other hand, ConE [40] is much more steady and outperforms BetaE and LogicE consistently. We also show the result when there are two free variables in Figure 7, where the model performance is much less steady but the trend is similar to the EFO 1 case in general.\\n\\n- Empirical hardness of query types and incomplete discussion of the previous dataset. Moreover, we also discuss the empirical hardness of query types themselves and compare different datasets accordingly in Figure 8. We find the standard deviation of the six representative CQA models increases in the most difficult part and decreases in the easiest part, corroborating our discussion in the first paragraph. We also highlight those query types that have already been investigated in BetaE dataset [28] and FIT dataset [39]. We intuitively find that the BetaE dataset does not include very challenging query types while the FIT dataset mainly focuses on them. This can be explained by the fact that nine out of ten most challenging query types correspond to multigraph, which the BetaE dataset totally ignores while the FIT dataset highlights it as a key feature. To give a quantitative analysis of whether their hand-crafted query types are sampled from the whole combinatorial space, we have adopted the Kolmogorov\u2013Smirnov test to test the distribution discrepancy between their distribution and the query type distribution in EFO k-CQA since EFO k-CQA enumerates all possible query types in the given combinatorial space and is thus unbiased. We find that the BetaE dataset is indeed generally easier and its p-value is 0.78, meaning that it has a 78 percent possibility to be unbiased, while the FIT dataset is significantly harder and its p-value is 0.27. Therefore, there is\"}"}
{"id": "r8PnfcWQol", "page_num": 24, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 5: MRR scores(%) for inferring queries with one free variable on FB15k-237. We denote $e$ as the number of existential variables and $c$ as the number of constant entities. SDAG represents the Simple Directed Acyclic Graph, Multi for multigraph, and Cyclic for the cyclic graph. A VG.($c$) and A VG.($e$) is the average score of queries with the number of constant entities / existential variables fixed.\\n\\n| Model | $c$ | $e$ | SDAG | SDAG Multi | Cyclic |\\n|-------|-----|-----|------|------------|--------|\\n| BetaE | 1   | 16.2| 17.9 | 10.9       | 8.5    |\\n|       | 2   | 20.7| 35.6 | 20.2       | 15.7   |\\n|       | 3   | 53.3| 32.4 | 33.1       | 21.7   |\\n| LogicE| 1   | 17.4| 19.0 | 11.5       | 8.5    |\\n|       | 2   | 21.3| 36.7 | 21.2       | 16.5   |\\n|       | 3   | 55.5| 34.6 | 34.5       | 22.3   |\\n| ConE  | 1   | 18.6| 19.9 | 11.8       | 9.3    |\\n|       | 2   | 23.1| 39.1 | 22.4       | 18.1   |\\n|       | 3   | 58.8| 36.4 | 37.0       | 24.6   |\\n| CQD   | 1   | 22.2| 19.5 | 9.0        | 9.2    |\\n|       | 2   | 21.9| 35.3 | 20.1       | 16.4   |\\n|       | 3   | 40.3| 32.9 | 34.3       | 24.4   |\\n| LMPNN | 1   | 20.5| 21.4 | 11.2       | 8.7    |\\n|       | 2   | 20.5| 42.0 | 22.6       | 16.5   |\\n|       | 3   | 62.3| 35.9 | 31.6       | 22.1   |\\n| FIT   | 1   | 22.2| 25.0 | 17.4       | 11.7   |\\n|       | 2   | 22.2| 30.3 | 18.0       | 16.4   |\\n|       | 3   | 64.5| 44.8 | 45.4       | 33.3   |\\n\\nno significant statistical evidence to prove they are sampled from the whole combinatorial space unbiasedly.\\n\\nH.2 Further benchmark result of $k = 1$ Firstly, we present the benchmark result when there is only one free variable, since the result in FB15k-237 is provided in Table 1, we provide the result for other standard knowledge graphs, FB15k and NELL, their result is shown in Table 6 and Table 7, correspondingly. We note that FIT is out of memory with the two large graphs FB15k and NELL as explained in Appendix F and we do not include its result. As FB15k and NELL are both reported to be easier than FB15k-237, the models have better performance. The trend and analysis are generally similar to our discussion in Section 5.2 with some minor, unimportant changes that LogicE [24] has outperformed ConE [40] in the knowledge graph NELL, indicating one model may not perform identically well in all knowledge graphs.\\n\\nH.3 Further benchmark result for $k = 2$ in more knowledge graphs Then, similar to Section 5.3, we provide the result for other standard knowledge graphs, FB15k and NELL, when the number of constant entities is fixed to two, their result is shown in Table 8 and Table 9, correspondingly.\\n\\n24\"}"}
{"id": "r8PnfcWQol", "page_num": 29, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 12: HIT@10 scores(%) of two different types for answering queries with two free variables on FB15k (including queries without the marginal hard answer). The constant number is fixed to be two. The notation of $e$, SDAG, Multi, and Cyclic is the same as Table 2.\\n\\n| Model | HIT@10 Type | $e$ | $e$ | $e$ |\\n|-------|-------------|-----|-----|-----|\\n|       |             | 0   | 1   | 2   |\\n|       |             | SDAG | Multi | SDAG | Multi | Cyclic | SDAG | Multi | Cyclic |\\n| BetaE | Multiply    | 42.1 | 57.2 | 26.5 | 66.5 | 15.5 | 34.6 | 134.9 | 100.0 | 35.0 |\\n|       | Joint       | 6.6 | 9.4 | 4.5 | 10.2 | 4.6 | 4.3 | 16.7 | 26.0 | 9.2 |\\n| LogicE| Multiply    | 48.2 | 65.6 | 31.0 | 71.6 | 16.8 | 37.8 | 143.9 | 105.8 | 38.1 |\\n|       | Joint       | 7.5 | 11.2 | 5.6 | 12.5 | 5.3 | 5.6 | 20.4 | 28.5 | 10.5 |\\n| ConE  | Multiply    | 50.2 | 72.2 | 32.8 | 74.6 | 18.3 | 38.3 | 149.3 | 114.3 | 40.4 |\\n|       | Joint       | 6.8 | 10.0 | 5.2 | 12.5 | 5.5 | 5.2 | 19.4 | 30.4 | 11.0 |\\n| CQD   | Multiply    | 48.1 | 55.9 | 31.9 | 69.0 | 15.8 | 29.5 | 93.5 | 103.2 | 37.6 |\\n|       | Joint       | 9.4 | 11.4 | 6.6 | 14.8 | 4.8 | 5.5 | 17.5 | 27.2 | 12.0 |\\n| LMPNN | Multiply    | 58.4 | 79.5 | 43.1 | 94.6 | 21.3 | 40.9 | 146.2 | 135.9 | 45.0 |\\n|       | Joint       | 8.6 | 12.9 | 6.8 | 15.6 | 6.2 | 5.4 | 19.3 | 31.7 | 11.6 |\\n\\nTable 13: HIT@10 scores(%) of two different types for answering queries with two free variables on NELL (including queries without the marginal hard answer). The constant number is fixed to be two. The notation of $e$, SDAG, Multi, and Cyclic is the same as Table 2.\\n\\n| Model | HIT@10 Type | $e$ | $e$ | $e$ |\\n|-------|-------------|-----|-----|-----|\\n|       |             | 0   | 1   | 2   |\\n|       |             | SDAG | Multi | SDAG | Multi | Cyclic | SDAG | Multi | Cyclic |\\n| BetaE | Multiply    | 21.2 | 47.3 | 22.0 | 51.9 | 14.7 | 24.1 | 80.5 | 79.7 | 33.4 |\\n|       | Joint       | 4.2 | 19.6 | 6.8 | 19.1 | 5.1 | 6.8 | 26.7 | 24.0 | 14.1 |\\n| LogicE| Multiply    | 26.6 | 52.8 | 28.8 | 63.4 | 16.0 | 32.8 | 103.1 | 88.5 | 38.9 |\\n|       | Joint       | 3.8 | 21.5 | 9.7 | 26.0 | 5.9 | 11.5 | 36.9 | 27.3 | 16.5 |\\n| ConE  | Multiply    | 25.3 | 51.4 | 23.9 | 53.9 | 16.9 | 27.3 | 90.7 | 90.6 | 36.7 |\\n|       | Joint       | 3.4 | 20.2 | 6.4 | 17.0 | 6.1 | 7.2 | 27.0 | 27.1 | 14.2 |\\n| CQD   | Multiply    | 30.3 | 48.9 | 30.6 | 64.3 | 15.9 | 33.1 | 88.9 | 91.2 | 40.9 |\\n|       | Joint       | 4.4 | 21.9 | 9.8 | 27.5 | 5.6 | 12.0 | 37.6 | 28.1 | 18.0 |\\n| LMPNN | Multiply    | 33.4 | 58.3 | 33.7 | 65.3 | 19.4 | 30.7 | 85.1 | 105.0 | 41.8 |\\n|       | Joint       | 4.4 | 23.7 | 10.0 | 21.9 | 5.8 | 8.2 | 23.2 | 28.8 | 15.7 |\"}"}
{"id": "r8PnfcWQol", "page_num": 25, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 6: MRR scores(%) for inferring queries with one free variable on FB15k. The notation of e, c, SDAG, Multi, Cyclic, AVG.\\\\((c)\\\\) and AVG.\\\\((e)\\\\) are the same as Table 1.\\n\\n| Model | BetaE | LogicE | ConE | CQD | LMPNN |\\n|-------|-------|--------|------|-----|-------|\\n|       |       |        |      |     |       |\\n| 1     | 38.6  | 46.0   | 52.5 | 74.6| 63.7  |\\n| 3     | 63.5  | 64.5   | 70.6 | 53.3| 79.8  |\\n| AVG.\\\\((c)\\\\) | 63.5  | 64.5   | 70.6 | 53.3| 79.8  |\\n| AVG.\\\\((e)\\\\) | 63.5  | 64.5   | 70.6 | 53.3| 79.8  |\\n\\nWe note that though in some breakdowns, the marginal score is over 90 percent, almost close to 100 percent, the joint score is pretty slow, which further corroborates our findings that joint metric is significantly harder and more challenging in Section 5.3.\\n\\nH.4 Further benchmark result for \\\\(k=2\\\\) with more constant numbers.\\n\\nAs the experiment in Section 5.3 only contains the situation where the number of constant entity is fixed as one, we offer the further experiment result in Table 10. The result shows that models perform worse with fewer constant variables when compares to the result in Table 2, this observation is the same as the previous result with one free variable that has been discussed in Section 5.2.\\n\\nH.5 Further benchmark result for \\\\(k=2\\\\) including all queries\\n\\nFinally, as we have explained in Section 4.5 and Appendix E, there are some valid EFO \\\\(k\\\\) queries without marginal hard answers when \\\\(k \\\\geq 1\\\\). Thus, there is no way to calculate the marginal scores, all our previous experiments are therefore only conducted on those queries that all their free variables have marginal hard answers. In this section, we only present the result of the Multiply and Joint score, as they can be computed for any valid EFO \\\\(k\\\\) queries, and therefore this experiment is conducted on the whole EFO \\\\(k\\\\)-CQA dataset. We follow the practice in Section 5.3 that fixed the number of constant entities as two, as the impact of constant entities is pretty clear, which has been further corroborated in Appendix H.4. The experiments are conducted on all three knowledge graphs, FB15k-237, FB15k, and NELL, the result is shown in Table 11, Table 12, and Table 13, correspondingly.\"}"}
{"id": "r8PnfcWQol", "page_num": 26, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"### Table 7: MRR scores(%) for inferring queries with one free variable on NELL.\\n\\n| Model | $c$ | $e$ | SDAG | Multi | Cyclic | AVG.($c$) | AVG.($e$) |\\n|-------|-----|-----|------|-------|--------|----------|----------|\\n| BetaE | 1   | 13.9| 26.4 | 35.0  | 8.6    | 14.9     | 19.1     |\\n|       | 2   | 33.62| 58.8 | 31.5  | 43.8   | 22.4     | 30.6     |\\n|       | 3   | 78.8 | 48.6 | 58.3  | 29.6   | 39.0     | 47.0     |\\n| AVG.($e$) | 53.1 | 38.5 | 48.3 | 25.2  | 33.3   | 38.2     |          |\\n| LogicE| 1   | 18.3 | 29.2 | 39.6  | 12.1   | 19.0     | 20.4     |\\n|       | 2   | 36.92| 63.5 | 34.4  | 47.3   | 26.4     | 34.0     |\\n|       | 3   | 79.6 | 51.2 | 59.3  | 33.1   | 42.2     | 50.1     |\\n| AVG.($e$) | 56.3 | 41.3 | 50.9 | 28.8  | 36.7   | 41.0     |          |\\n| ConE  | 1   | 16.7 | 26.9 | 36.6  | 11.1   | 16.9     | 22.3     |\\n|       | 2   | 36.62| 60.5 | 33.6  | 46.6   | 25.3     | 33.1     |\\n|       | 3   | 79.9 | 50.6 | 59.2  | 33.2   | 42.2     | 52.6     |\\n| AVG.($e$) | 54.9 | 40.3 | 50.0 | 28.4  | 36.2   | 43.4     |          |\\n| CQD   | 1   | 22.3 | 30.6 | 37.3  | 13.3   | 17.9     | 20.7     |\\n|       | 2   | 38.22| 59.8 | 34.0  | 45.2   | 28.8     | 35.4     |\\n|       | 3   | 62.7 | 48.8 | 59.9  | 36.4   | 44.1     | 52.6     |\\n| AVG.($e$) | 50.1 | 40.2 | 49.9 | 31.6  | 38.1   | 42.7     |          |\\n| LMPNN | 1   | 20.7 | 29.8 | 33.3  | 13.4   | 16.5     | 21.8     |\\n|       | 2   | 35.12| 63.5 | 35.4  | 43.3   | 27.0     | 30.2     |\\n|       | 3   | 80.8 | 50.7 | 56.0  | 33.6   | 39.2     | 47.6     |\\n| AVG.($e$) | 57.4 | 41.5 | 46.7 | 29.4  | 33.6   | 40.0     |          |\\n\\nInterestingly, comparing the result in Table 2 and Table 11, the multiple scores actually increase while the joint scores are similar. This may be explained by the fact that if one free variable has no marginal hard answer, then it can be easily predicted, leading to a better performance for the whole query.\\n\\n### Society impact\\n\\nThis paper addresses the topic of complex query answering on knowledge graphs, a subject that has garnered attention within the machine learning community for approximately four years. This paper mainly focuses on extending the scope of the complex query given the same knowledge graph and also presents systematic benchmarks and convenient implementation for the whole pipeline of complex query answering, which holds the potential to significantly advance the development of complex query answering models.\\n\\nThe outcomes of this work have practical applications, particularly in areas such as fraud detection, where queries involving multiple free variables and cyclic patterns are necessary. Furthermore, since this study utilizes publicly available knowledge graphs without incorporating new information sources, concerns regarding data leakage are unlikely to arise. However, it's still important to note that this work may lead to unexpected negative societal impact which we are unable to foresee in the current stages. We recognize the necessity of ongoing evaluation and responsible oversight to identify and address any unintended consequences that may arise as a result of this research.\\n\\nAdditionally, the figure of the real-world KG in Figure 3 is taken from [https://medium.com/@fakrami/re-evaluation-of-knowledge-graph-completion-methods-7dfe2e981a77](https://medium.com/@fakrami/re-evaluation-of-knowledge-graph-completion-methods-7dfe2e981a77).\"}"}
{"id": "r8PnfcWQol", "page_num": 27, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 8: HIT@10 scores(%) of three different types for answering queries with two free variables on FB15k. The constant number is fixed to be two. The notation of e, SDAG, Multi, and Cyclic is the same as Table 2.\\n\\n| Model | HIT@10 | Type | e = 0 | e = 1 | e = 2 |\\n|-------|--------|------|-------|-------|-------|\\n|       |        | SDAG | Multi | Cyclic | SDAG | Multi | Cyclic |\\n| BetaE |        |      |       |        |       |       |        |\\n| Marginal | 76.9  | 77.2 | 68.9  | 69.3  | 75.1  | 55.0  | 57.4  | 73.6  | 63.6  |\\n| Multiply | 41.7  | 41.6 | 31.7  | 31.0  | 38.7  | 25.2  | 25.9  | 36.1  | 29.7  |\\n| Joint | 11.6  | 13.7 | 8.7   | 8.6   | 17.8  | 4.9   | 5.4   | 14.3  | 8.4   |\\n| LogicE |        |      |       |        |       |       |        |\\n| Marginal | 82.9  | 80.9 | 73.6  | 72.9  | 76.6  | 58.9  | 60.7  | 75.7  | 66.9  |\\n| Multiply | 47.5  | 45.0 | 36.3  | 34.1  | 40.4  | 28.5  | 29.0  | 38.0  | 32.7  |\\n| Joint | 12.7  | 13.9 | 10.0  | 9.9   | 19.2  | 6.1   | 6.5   | 15.9  | 9.6   |\\n| ConE |        |      |       |        |       |       |        |\\n| Marginal | 84.1  | 84.8 | 76.5  | 76.3  | 81.4  | 61.8  | 63.8  | 79.7  | 70.2  |\\n| Multiply | 48.7  | 48.1 | 37.7  | 35.9  | 44.2  | 29.9  | 30.4  | 41.4  | 34.6  |\\n| Joint | 14.2  | 15.6 | 10.3  | 10.4  | 20.6  | 6.2   | 6.6   | 16.9  | 10.1  |\\n| CQD |        |      |       |        |       |       |        |\\n| Marginal | 73.8  | 76.8 | 69.0  | 71.9  | 76.3  | 51.1  | 54.4  | 77.0  | 62.9  |\\n| Multiply | 45.0  | 46.6 | 37.4  | 36.9  | 43.9  | 28.1  | 29.2  | 41.9  | 34.0  |\\n| Joint | 17.1  | 19.0 | 13.1  | 13.0  | 20.6  | 7.7   | 8.6   | 18.1  | 11.9  |\\n| LMPNN |        |      |       |        |       |       |        |\\n| Marginal | 89.2  | 80.1 | 80.3  | 78.2  | 84.2  | 65.6  | 63.7  | 80.2  | 71.3  |\\n| Multiply | 56.6  | 50.5 | 45.7  | 42.4  | 49.0  | 37.6  | 34.8  | 44.6  | 39.7  |\\n| Joint | 18.9  | 17.2 | 12.9  | 12.4  | 22.4  | 8.0   | 7.5   | 16.9  | 11.2  |\\n\\nTable 9: HIT@10 scores(%) of three different types for answering queries with two free variables on NELL. The constant number is fixed to be two. The notation of e, SDAG, Multi, and Cyclic is the same as Table 2.\\n\\n| Model | HIT@10 | Type | e = 0 | e = 1 | e = 2 |\\n|-------|--------|------|-------|-------|-------|\\n|       |        | SDAG | Multi | Cyclic | SDAG | Multi | Cyclic |\\n| BetaE |        |      |       |        |       |       |        |\\n| Marginal | 81.3  | 95.9 | 72.8  | 85.5  | 79.9  | 57.2  | 66.7  | 77.0  | 71.2  |\\n| Multiply | 48.2  | 56.7 | 41.3  | 46.1  | 47.6  | 33.1  | 36.5  | 42.9  | 39.6  |\\n| Joint | 19.2  | 31.8 | 21.2  | 26.5  | 21.7  | 13.8  | 17.5  | 18.5  | 18.8  |\\n| LogicE |        |      |       |        |       |       |        |\\n| Marginal | 87.1  | 99.8 | 81.0  | 91.8  | 83.2  | 65.7  | 74.0  | 81.0  | 77.7  |\\n| Multiply | 52.5  | 60.3 | 47.6  | 51.7  | 50.2  | 39.4  | 42.6  | 46.0  | 44.8  |\\n| Joint | 21.1  | 32.8 | 25.4  | 30.5  | 23.3  | 18.0  | 21.5  | 20.5  | 22.3  |\\n| ConE |        |      |       |        |       |       |        |\\n| Marginal | 82.6  | 96.4 | 76.0  | 87.8  | 88.1  | 60.0  | 69.3  | 83.0  | 74.7  |\\n| Multiply | 48.7  | 56.9 | 41.9  | 46.3  | 52.2  | 34.5  | 38.1  | 47.7  | 41.7  |\\n| Joint | 17.0  | 30.9 | 19.3  | 25.0  | 24.9  | 12.9  | 17.2  | 20.3  | 18.8  |\\n| CQD |        |      |       |        |       |       |        |\\n| Marginal | 79.5  | 96.3 | 83.2  | 92.2  | 83.5  | 65.8  | 75.7  | 84.8  | 79.4  |\\n| Multiply | 49.2  | 57.8 | 51.1  | 53.1  | 51.4  | 40.6  | 45.1  | 50.6  | 47.4  |\\n| Joint | 23.0  | 38.0 | 29.7  | 34.2  | 26.4  | 21.4  | 25.4  | 24.0  | 26.0  |\\n| LMPNN |        |      |       |        |       |       |        |\\n| Marginal | 88.5  | 96.6 | 81.5  | 90.9  | 85.3  | 65.0  | 70.7  | 83.1  | 76.7  |\\n| Multiply | 55.7  | 62.4 | 50.3  | 53.3  | 54.0  | 40.8  | 42.6  | 50.3  | 46.5  |\\n| Joint | 23.4  | 36.4 | 25.5  | 29.4  | 24.0  | 16.6  | 19.7  | 21.5  | 21.5  |\"}"}
{"id": "r8PnfcWQol", "page_num": 28, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"Table 10: HIT@10 scores(%) of three different types for answering queries with two free variables on FB15k-237. The constant number is fixed to be one. The notation of e, SDAG, Multi, and Cyclic is the same as Table 2.\\n\\n| Model   | HIT@10 | Type     | Marginal | Multiply | Joint |\\n|---------|--------|----------|----------|----------|-------|\\n| BetaE   |        | e<sub>0</sub> | 37.5 | 29.7 | 33.4 | 28.1 | 35.6 | 30.0 | 25.9 | 41.2 | 31.2 |\\n|         |        | e<sub>1</sub> | 18.9 | 13.7 | 15.3 | 10.3 | 15.2 | 17.7 | 13.3 | 17.2 | 14.3 |\\n|         |        | e<sub>2</sub> | 0.9  | 1.1  | 1.4  | 0.9  | 3.3  | 1.1  | 0.9  | 3.9  | 1.7  |\\n| LogicE  |        | e<sub>0</sub> | 40.6 | 30.7 | 36.0 | 29.1 | 34.6 | 29.8 | 25.3 | 41.5 | 31.4 |\\n|         |        | e<sub>1</sub> | 21.1 | 14.3 | 17.2 | 10.9 | 16.3 | 17.8 | 13.3 | 17.5 | 14.7 |\\n|         |        | e<sub>2</sub> | 1.4  | 1.4  | 1.6  | 0.9  | 3.7  | 1.4  | 1.0  | 4.3  | 1.9  |\\n| ConE    |        | e<sub>0</sub> | 40.8 | 32.4 | 37.3 | 30.4 | 40.7 | 31.1 | 26.9 | 45.0 | 33.5 |\\n|         |        | e<sub>1</sub> | 22.1 | 15.2 | 18.4 | 11.7 | 19.3 | 18.5 | 14.8 | 20.9 | 16.5 |\\n|         |        | e<sub>2</sub> | 1.4  | 1.0  | 1.7  | 1.0  | 4.3  | 1.4  | 1.0  | 4.4  | 2.0  |\\n| CQD     |        | e<sub>0</sub> | 73.8 | 76.8 | 69.0 | 71.9 | 76.3 | 51.1 | 54.4 | 77.0 | 62.9 |\\n|         |        | e<sub>1</sub> | 23.3 | 9.1  | 18.5 | 9.2  | 16.2 | 14.6 | 9.2  | 19.1 | 12.9 |\\n|         |        | e<sub>2</sub> | 1.5  | 0.6  | 2.0  | 1.1  | 3.4  | 1.5  | 0.9  | 4.4  | 1.9  |\\n| LMPNN   |        | e<sub>0</sub> | 39.0 | 27.6 | 40.0 | 29.5 | 39.3 | 30.6 | 24.8 | 42.7 | 32.0 |\\n|         |        | e<sub>1</sub> | 25.1 | 13.9 | 24.3 | 13.3 | 21.6 | 20.0 | 14.0 | 21.1 | 17.1 |\\n|         |        | e<sub>2</sub> | 1.6  | 1.3  | 2.5  | 1.3  | 3.9  | 1.5  | 1.0  | 4.0  | 2.0  |\\n\\nTable 11: HIT@10 scores(%) of two different types for answering queries with two free variables on FB15k-237 (including queries without the marginal hard answer). The constant number is fixed to be two. The notation of e, SDAG, Multi, and Cyclic is the same as Table 2.\\n\\n| Model   | HIT@10 | Type     | Multiply | Joint |\\n|---------|--------|----------|----------|-------|\\n| BetaE   |        | e<sub>0</sub> | 29.1 | 29.1 | 18.3 | 37.5 | 10.4 | 28.0 | 93.6 | 74.6 | 24.1 |\\n|         |        | e<sub>1</sub> | 2.1  | 2.2  | 1.7  | 3.0  | 2.4  | 1.8  | 5.8  | 14.2 | 4.6  |\\n| LogicE  |        | e<sub>0</sub> | 31.6 | 32.9 | 19.8 | 39.6 | 10.9 | 28.7 | 96.3 | 73.8 | 25.4 |\\n|         |        | e<sub>1</sub> | 2.6  | 2.5  | 2.1  | 3.1  | 2.5  | 2.2  | 6.4  | 15.6 | 5.0  |\\n| ConE    |        | e<sub>0</sub> | 32.6 | 31.9 | 20.5 | 41.0 | 12.6 | 29.0 | 99.7 | 86.8 | 27.0 |\\n|         |        | e<sub>1</sub> | 3.0  | 2.1  | 1.9  | 3.3  | 2.7  | 2.2  | 6.6  | 16.8 | 5.4  |\\n| CQD     |        | e<sub>0</sub> | 34.5 | 23.4 | 22.3 | 36.8 | 10.6 | 26.4 | 75.3 | 77.3 | 25.6 |\\n|         |        | e<sub>1</sub> | 2.9  | 1.4  | 2.1  | 3.3  | 2.3  | 2.0  | 5.0  | 15.0 | 5.6  |\\n| LMPNN   |        | e<sub>0</sub> | 36.8 | 29.3 | 27.5 | 45.8 | 13.9 | 31.2 | 97.0 | 86.5 | 27.9 |\\n|         |        | e<sub>1</sub> | 2.7  | 2.2  | 2.7  | 3.9  | 2.5  | 2.1  | 5.8  | 14.6 | 5.0  |\\n| FIT     |        | e<sub>0</sub> | 41.5 | 44.4 | 28.9 | 56.8 | 10.2 | 39.4 | 139.7 | 100.3 | 35.0 |\\n|         |        | e<sub>1</sub> | 2.4  | 2.3  | 2.1  | 3.4  | 1.6  | 2.2  | 7.4  | 15.4 | 5.9  |\"}"}
{"id": "r8PnfcWQol", "page_num": 17, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Figure 6: Illustration of the comparison between the EFO\\\\textsubscript{k}-CQA dataset (navy blue box) and the previous dataset (three yellow boxes), where the BetaE and EFO-1-QA aim to investigate the tree form query, explained in Appendix C, while the FIT dataset aims to investigate EFO\\\\textsubscript{1} query that is not tree form. FIT is not a subset of EFO\\\\textsubscript{k}-CQA because its \\\"3pm\\\" query is not included in EFO\\\\textsubscript{k}-CQA.\\n\\nE\\\\textsubscript{1} and e connects to u. Then \\n\\\\[ G_p = p \\\\cup V_1, E_1, f, g \\\\]. We note that because of Proposition 20, if a node \\\\[ u \\\\in P \\\\cup V_1 \\\\], then we know node \\\\[ u \\\\] must be a constant entity.\\n\\nThen we sample the grounding for the positive subgraph \\\\[ G_p \\\\], we also compute the CSP answer \\\\[ A_p \\\\] for this subgraph.\\n\\nThen we ground what is left in the positive subgraph, we split each negative edge in \\\\[ E \\\\] into two categories:\\n\\n1. This edge \\\\[ e \\\\] connects two nodes \\\\[ u, v \\\\], and \\\\[ u, v \\\\in P \\\\cup V_1 \\\\]. In this case, we sample the relation \\\\[ r \\\\] to be the grounding of \\\\[ e \\\\] such that it negates some of the answers in \\\\[ A_p \\\\].\\n\\n2. This edge \\\\[ e \\\\] connects two nodes \\\\[ u, v \\\\], where \\\\[ u \\\\in P \\\\cup V_1 \\\\], while \\\\[ v \\\\in R \\\\cup V_1 \\\\]. In this case, we sample the relation \\\\[ r \\\\] for \\\\[ e \\\\] and entity \\\\[ a \\\\] for \\\\[ v \\\\] such that they negate some answer in \\\\[ A_p \\\\], we note we only need to consider the possible candidates for node \\\\[ u \\\\] and it is quite efficient.\\n\\nWe note that there is no possibility that neither of the endpoints is in \\\\[ V_1 \\\\] because as we have discussed above, this means that both nodes are constant entities, but in Proposition 18 we have asserted that no edge is connected between two entities.\\n\\nD.3 The comparison to previous benchmark\\n\\nTo give an intuitive comparison of our EFO\\\\textsubscript{k}-CQA dataset against those previous datasets and benchmark, including the BetaE dataset [28], the EFO-1-QA benchmark [36] that extends BetaE dataset, and the FIT dataset [39] that explores 10 more new query types, we offer a new figure in Figure 6. It can be clearly observed that EFO-1-QA covers the BetaE dataset and has provided a quite systematic investigation in tree form query, while FIT deviates from them and studies ten new query types that are in EFO\\\\textsubscript{1} but not tree form.\\n\\nAs discussed in Section 3, the scope of the formula investigated in our EFO\\\\textsubscript{k}-CQA dataset surpasses the previous EFO-1-QA benchmark and FIT dataset because of three reasons: (1). We include the EFO\\\\textsubscript{k} formula with multiple free variables that has never been investigated (the bottom part of...\"}"}
{"id": "r8PnfcWQol", "page_num": 18, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 3: The number of abstract query graphs with one free variable. We denote $e$ as the number of existential variables and $c$ as the number of constant entities. SDAG represents the Simple Directed Acyclic Graph, Multi for multigraph, and Cyclic for the cyclic graph. $\\\\text{Sum}$.($c$) and $\\\\text{Sum}$.($e$) is the total number of queries with the number of constant entities / existential variables fixed.\\n\\n| $c$ | $e$ | SDAG | SDAG | Multi | SDAG | Multi | Cyclic |\\n|-----|-----|------|------|-------|------|-------|--------|\\n| 1   | 1   | 2    | 4    | 4     | 16   | 4     | 31     |\\n| 2   | 2   | 2    | 6    | 6     | 20   | 40    | 8      | 82     |\\n| 3   | 2   | 8    | 8    | 36    | 72   | 12    | 138    |\\n\\nSum.($e$) 5 18 18 60 128 24\\n\\nWe systematically investigate those EFO queries that are not tree form while the previous FIT dataset only discusses ten hand-crafted query types (the navy blue part between two white lines in Figure 6); (3) Our assumption is more systematic than previous ones as shown by the example in Figure 2 (the top navy blue part above two white lines in Figure 6). Though we only contain 741 query types while the EFO-1-QA benchmark contains 301 query types, we list reasons for the number of query types is not significantly larger than the previous benchmark: (1). EFO-1-QA benchmark relies on the operator tree that contains union, which represents the logic conjunction ($\\\\land$), however, we only discuss the conjunctive queries because we always utilize the DNF of a query. We notice that there are only 129 query types in EFO-1-QA without the union, significantly smaller than the EFO-k-CQA dataset. (2). In the construction of EFO-k-CQA dataset, we restrict the query graph to have at most one negative edge to avoid the total number of query types growing quadratically, while in EFO-1-QA benchmark, their restrictions are different than ours and it contains queries that have two negative atomic formulas as indicated by the right part of yellow box is not contained in the navy blue box.\\n\\nD.4 EFO-k-CQA statistics\\n\\nThe statistics of our EFO-k-CQA dataset are shown in Table 3 and Table 4, they show the statistics of our abstract query graph by their topology property, the statistics are split into the situation that the number of free variable $k = 1$ and the number of free variable $k = 2$, correspondingly. We note abstract query graphs with seven nodes have been excluded as the setting of hyperparameters discussed in Appendix D.1, we make these restrictions to control the quadratic growth in the number of abstract query graphs.\\n\\nFinally, in FB15k-237, we sample 1000 queries for an abstract query graph without negation, 500 queries for an abstract query graph with negation; in FB15k, we sample 800 queries for an abstract query graph without negation, 400 queries for an abstract query graph with negation; in NELL, we sample 400 queries for an abstract query graph without negation, 100 queries for an abstract query graph with negation. As we have discussed in Appendix D.2, sample negative query is computationally costly, thus we sample less of them.\\n\\nMoreover, we provide our EFO-k-CQA dataset an inductive version, with the same query types as the transductive version, while the number of queries per query type is set to 400 for positive ones and 100 for negative ones. The inductive ratio is set to 175%, following the setting in [9].\\n\\nE Evaluation details\\n\\nWe explain the evaluation protocol in detail for Section 4.5. Firstly, we explain the computation of common metrics, including Mean Reciprocal Rank (MRR) and HIT@K, given the full answer $A$ in the whole KG and the observed answer $A_o$ in the observed KG, we focus on the hard answer $A_h$ as it requires more than memorizing the observed KG and serves as the indicator of the capability of reasoning.\"}"}
{"id": "r8PnfcWQol", "page_num": 19, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 4: The number of abstract query graphs with two free variables. The notation of $e$, $c$, SDAG, Multi, and Cyclic are the same as Table 3. And \\\"-\\\" means that this type of abstract query graph is not included.\\n\\n| $e$ | SDAG | Multi | SDAG | Multi | Cyclic | SDAG | Multi | Cyclic |\\n|-----|------|-------|------|-------|--------|------|-------|--------|\\n| 0   | 1    | 2     | 7    | 18    | 4      | 6    | 32    | 26     | 96     |\\n| 1   | 4    | 4     | 20   | 36    | 8      | 38   | 108   | 64     | 282    |\\n| 2   | 4    | 4     | 32   | 60    | -      | -    | -     | -      | 112     |\\n\\nAlgorithm 1\\n\\nEmbedding computation on the query graph.\\n\\nRequire: The query graph $G$.\\n\\nCompute the ordering of the nodes as explained in Algorithm 2.\\n\\nCreate a dictionary $E$ to store the embedding for each node in the query graph.\\n\\nfor $i \\\\leftarrow 1$ to $n$ do\\n  if node $u_i$ is a constant entity\\n    then\\n      The embedding of $u_i$, $E_{r_i}$ is gotten from the entity embedding\\n    else\\n      Then we know node $u_i$ is either free variable or existential variable\\n      Compute the set of nodes $\\\\{u_j \\\\mid t \\\\leq j \\\\leq i\\\\}$ that are previous to $i$ and adjacency to node $u_i$.\\n      Create a list to store projection embedding $L$.\\n      for $j \\\\leftarrow 1$ to $t$ do\\n        Find the relation $r$ between node $u_i$ and $u_{ij}$, get the embedding of node $u_{ij}$ as $E_{r_i}$. \\n        if $E_{r_i}$ is not None\\n          if The edge between $u_i$ and $u_{ij}$ is positive\\n            then\\n              Compute the embedding of projection($E_{r_i}$, $r$), add it to the list $L$.\\n            else\\n              Compute the embedding of the negation of the projection($E_{r_i}$, $r$), add it to the list $L$.\\n          end if\\n        end if\\n      end for\\n    end if\\n  else\\n    if The list $L$ has no element\\n      then $E_{r_i}$ is set to none.\\n    elseif The list $L$ has one element\\n      then $E_{r_i}$ = $L_0$\\n    else\\n      Compute the embedding as the intersection of the embedding in the list $L$, and set $E_{r_i}$ as the outcome.\\n    end if\\n  end if\\nend for\\n\\nreturn The embedding dictionary $E$ for each node in the query graph.\\n\\nSpecifically, we rank each hard answer $a \\\\in P_A$ against all non-answers $A'$, the reason is that we need to neglect other answers so that answers do not interfere with each other, finally, we get the ranking for $a$ as $r$. Then its MRR is $\\\\frac{1}{\\\\{r \\\\in r \\\\mid r \\\\leq k\\\\}}$, and its HIT@k is $\\\\{r \\\\in r \\\\mid r \\\\leq k\\\\}$, thus, the score of a query is the mean of the scores of every its hard answer. We usually compute the score for a query type (which corresponds to an abstract query graph) as the mean score of every query within this type. As the marginal score and the multiply score have already been explained in Section 4.5, we only mention one point that it is possible that every free variable does not have marginal hard answer. Assume that for a query with two free variables, its answer set $A'' = \\\\{a_1, a_2\\\\}$, $A'' = \\\\{a_4, a_2\\\\}$ and its observed answer set $A'' = \\\\{a_1, a_3\\\\}$, $A'' = \\\\{a_4, a_2\\\\}$. In this case, $a_1$ is not the marginal hard answer for the first free variable and $a_2$ is not the marginal hard answer for the second free variable, in general, no free variable has its own marginal hard answer.\"}"}
{"id": "r8PnfcWQol", "page_num": 20, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Algorithm 2\\nNode ordering on the abstract query graph.\\n\\nRequire:\\nThe abstract query graph $G = \\\\langle V, E, f, g \\\\rangle$ consists of $m$ nodes, $u_1, \\\\ldots, u_m$.\\n\\n1. Creates an empty list $L$ to store the ordering of the nodes.\\n2. Creates another two sets $S_1$ and $S_2$ to store the nodes that are to be explored next.\\n\\nfor $i = 1$ to $m$ do\\n    if The type of node $f_p u_i$ is constant entity then\\n        list $L$ append the node $u_i$\\n    for Node $u_j$ that connects to $u_i$ do\\n        if $f_p u_j$ is existential variable then\\n            $u_j$ is added to set $S_1$\\n        else\\n            $u_j$ is added to set $S_2$\\n        end if\\n    end for\\n    end if\\nend for\\n\\nwhile Not all node is included in $L$ do\\n    if Set $S_1$ is not empty then\\n        We sort the set $S_1$ by the sum of their distance to every free variable in $G$, choose the most remote one, and if there is a tie, randomly choose one node, $u_i$ to be the next to explore.\\n        We remove $u_i$ from set $S_1$.\\n    else\\n        In this case, we know set $S_2$ is not empty because of the connectivity of $G$.\\n        We randomly choose a node $u_i \\\\in S_2$ to be the next node to explore.\\n        We remove $u_i$ from set $S_2$.\\n    end if\\nend for\\n\\nNode $u_j$ that connects to $u_i$ do\\n    if $f_p u_j$ is existential variable then\\n        $u_j$ is added to set $S_1$\\n    else\\n        $u_j$ is added to set $S_2$\\n    end if\\nend for\\n\\nList $L$ append the node $u_i$\\nend while\\nend for\\n\\nreturn The list $L$ as the ordering of nodes in the whole abstract query graph $G$.\\n\\nThen we only discuss the joint metric, specifically, we only explain how to estimate the joint ranking by the individual ranking of each free variable. For each possible $k$-tuple $p_{a_1}, \\\\ldots, a_k$, if $a_i$ is ranked $r_i$ among the whole entity set $E$, we compute the score of this tuple as $\\\\sum_{i=1}^{k} r_i$, then we sort the whole $E_k$-tuple by their score, for the situation of a tie, we just use the lexicographical order.\\n\\nAfter the whole joint ranking is got, we use the standard evaluation protocol that ranks each hard answer against all non-answers. It can be confirmed that this estimation method admits a closed-form solution for the sorting in $E_k$ space, thus the computation cost is affordable.\\n\\nWe just give the closed-form solution when there are two free variables: for the tuple $p_{r_1}, r_2$, the possible combinations that sum less than $r_1`$ is $r_1`, then, there is $r_1`$ tuple that ranks before $p_{r_1}, r_2$ because of lexicographical order, thus, the final ranking for the tuple $p_{r_1}, r_2$ is just $r_1`$ that can be computed efficiently.\\n\\nF Implementation details of CQA models\\nIn this section, we provide implementation details of CQA models that have been evaluated in our paper. For query embedding methods that rely on the operator tree, including BetaE [28], LogicE [24], and ConE [40], we compute the ordering of nodes in the query graph in Algorithm 2, then we compute...\"}"}

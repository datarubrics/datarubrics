{"id": "emnlp-2024-main-748", "page_num": 33, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"# Filter the data for the years 2011-2016 and for the users 'soc' and 'xeno-by'\\nfiltered_pulls = pulls[(pulls['date'].dt.year >= 2011) & (pulls['date'].dt.year <= 2016) & (pulls['user'].isin(['soc', 'xeno-by']))]\\n\\n# Group by year and user, then count the number of pull requests\\npulls_by_year_and_user = filtered_pulls.groupby([filtered_pulls['date'].dt.year, 'user']).size().reset_index(name='count')\\n\\n# Pivot the result to have years as rows and users as columns, filling missing values with 0\\npivot_table = pulls_by_year_and_user.pivot(index='date', columns='user', values='count').fillna(0).reset_index()\\n\\n# Ensure that 'soc' and 'xeno-by' columns exist, adding them if they don't\\nif 'soc' not in pivot_table:\\npivot_table['soc'] = 0\\nif 'xeno-by' not in pivot_table:\\npivot_table['xeno-by'] = 0\\n\\n# Rename the columns to match the template file\\npivot_table.rename(columns={'date': 'date'}, inplace=True)\\n\\n# Load the template file\\ntemplate = pd.read_csv('pull_requests_by_year_and_author.csv')\\n\\n# Merge the results with the template\\nresult = template.merge(pivot_table, on='date', how='left').fillna(0)\\n\\n# Save the result\\nresult.to_csv('pull_requests_by_year_and_author.csv', index=False)\\n\\n[Step 8]* observation: ./analyze_pulls.py executed successfully. No output.\\n[Step 9]* observation: date,soc_x,xeno-by_x,soc_y,xeno-by_y\\n2011,0.0,0.0,12.0,20.0\\n2012,0.0,0.0,44.0,271.0\\n2013,0.0,0.0,117.0,123.0\\n2014,0.0,0.0,20.0,60.0\\n2015,0.0,0.0,24.0,3.0\\n2016,0.0,0.0,21.0,0.0\"}"}
{"id": "emnlp-2024-main-748", "page_num": 34, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"thought: The output shows that the merge operation has created additional columns with suffixes `_x` and `_y`. This is likely because the merge operation found columns with the same name in both dataframes and automatically added suffixes to differentiate them.\\n\\nI need to adjust the script to ensure that the merge operation does not create these additional columns and that the data is correctly placed under the 'soc' and 'xeno-by' columns as specified in the template.\\n\\n```\\nimport pandas as pd\\n# Load the CSV file that needs fixing\\ndata = pd.read_csv('pull_requests_by_year_and_author.csv')\\n# We only need the 'date' column and the counts for 'soc' and 'xeno-by'\\n# The correct counts are in the columns with suffix '_y'\\n# Rename '_y' columns to remove the suffix and drop '_x' columns\\ndata.rename(columns={\\n    'soc_y': 'soc',\\n    'xeno-by_y': 'xeno-by',\\n}, inplace=True)\\ndata.drop(columns=[\\n    'soc_x',\\n    'xeno-by_x',\\n], inplace=True)\\n# Save the corrected data back to the CSV file\\ndata.to_csv('pull_requests_by_year_and_author.csv', index=False)\\n```\\n\\n```\\n# Load the CSV file that needs fixing\\ndata = pd.read_csv('pull_requests_by_year_and_author.csv')\\n# We only need the 'date' column and the counts for 'soc' and 'xeno-by'\\n# The correct counts are in the columns with suffix '_y'\\n# Rename '_y' columns to remove the suffix and drop '_x' columns\\ndata.rename(columns={\\n    'soc_y': 'soc',\\n    'xeno-by_y': 'xeno-by',\\n}, inplace=True)\\ndata.drop(columns=[\\n    'soc_x',\\n    'xeno-by_x',\\n], inplace=True)\\n# Save the corrected data back to the CSV file\\ndata.to_csv('pull_requests_by_year_and_author.csv', index=False)\\n```\\n\\n* observation: ./fix_csv.py executed successfully. No output.\\n\\n* thought: The script to fix the CSV file has been executed successfully. Now, I should check the contents of the `pull_requests_by_year_and_author.csv` file again to confirm that the data is now correctly formatted according to the template.\\n\\n```\\ncat pull_requests_by_year_and_author.csv\\n```\\n\\n13520\"}"}
{"id": "emnlp-2024-main-748", "page_num": 35, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"* observation: date,soc,xeno-by\\n2011,12.0,20.0\\n2012,44.0,271.0\\n2013,117.0,123.0\\n2014,20.0,60.0\\n2015,24.0,3.0\\n2016,21.0,0.0\\n\\n* thought: The contents of the `pull_requests_by_year_and_author.csv` file now correctly show the number of pull requests made by the users \\\"soc\\\" and \\\"xeno-by\\\" for each year between 2011 and 2016. The task is complete, and I can now provide the path to the updated CSV file as the final output.\\n\\n* action: Terminate(output=\\\"pull_requests_by_year_and_author.csv\\\")\\n* code:\\n\\n13521\"}"}
{"id": "emnlp-2024-main-748", "page_num": 17, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"### Experiments Details\\n\\nThis section includes a detailed agent action space in Table 5.\\n\\n| Action Name          | Action Description |\\n|----------------------|--------------------|\\n| File Viewing         | The ability to access and review the contents of files, including but not limited to YAML (.yml) files, CSV (.csv) files, Markdown (.md) files, and text (.txt) files. |\\n| File Operating       | Performing operations on files such as creating, opening, editing, moving, and deleting. |\\n| Data Processing      | The manipulation and transformation of data to extract insights or prepare it for storage and further analysis. |\\n| System Operations    | Tasks related to the maintenance and management of computer systems, including monitoring performance, configuring settings, and troubleshooting issues. |\\n| Package Management   | The process of installing, upgrading, configuring, and managing software packages in an operating system. |\\n| SQL Query            | Executing read operations on databases using Structured Query Language (SQL) commands to retrieve specific data or summaries. |\\n| SQL Update           | Updating, modifying, or deleting data in a database using SQL commands, including insert, update, and delete operations. |\\n| SQL Debug            | The process of locating and resolving issues or bugs within SQL scripts or databases to ensure accurate data manipulation and retrieval. |\\n| Python Writing       | Writing, executing scripts and programs in the Python programming language for a wide range of applications. |\\n| Python Debug         | Identifying and fixing errors or bugs within Python code to ensure correct execution and output of Python programs. |\\n| Other Activities     | Other Activities or tasks that do not fall into the predefined categories, encompassing a miscellaneous range of actions. |\\n\\nTable 5: Summary of DA-Agent actions with descriptions.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 18, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"C Evaluation details\\n\\nC.1 Plot based Evaluation\\n\\nCurrently, existing methods for evaluating data visualizations include analyzing code correctness and using VLMs to score visualizations. The former relies on understanding the logic and structure of the code, which may lead to lower accuracy, while the latter has shown poor performance and high costs.\\n\\nWe propose a more reasonable and reliable evaluation method for visualizations. This method involves embedding scripts into code and executing them to directly obtain data, types, and other information corresponding to the chart.\\n\\nSpecifically, given the following inputs: chart data $d$, image metadata $J$, the code used for generation, and the corresponding script. By embedding and executing the script within the generating code, we extract the predicted chart's metadata $\\\\hat{J}$ and data $\\\\hat{d}$. The score is then calculated as follows:\\n\\n$$\\\\text{Score} = \\\\begin{cases} \\n1 & \\\\text{if } d = \\\\hat{d} \\\\text{ and } J = \\\\hat{J} \\\\\\\\\\n0 & \\\\text{otherwise}\\n\\\\end{cases}$$\\n\\nHere, if the task does not explicitly restrict the order or scale of the data, $d'$ and $\\\\hat{d}'$ are the sorted or scaled versions of $d$ and $\\\\hat{d}$. Additionally, $j \\\\subset J$ and $\\\\hat{j} \\\\subset \\\\hat{J}$, which are specific pieces of image information explicitly specified in the instructions, are compared from $J$ and $\\\\hat{J}$, respectively.\\n\\nC.1.1 Image Information Description\\n\\nTo provide a comprehensive understanding, we will use an example to introduce all the relevant information involved in data visualization tasks in DA-Code.\\n\\nFigure 8: Example in data visualization task\\n\\n`figsize` specifies the shape or dimensions of the image. It determines the width and height of the plot in inches. In our example, it is set to (10, 6) (not explicitly shown in the image, but set in the code).\"}"}
{"id": "emnlp-2024-main-748", "page_num": 19, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"\u201ccolor\u201d represents the color scheme used within the graph or visualization. It defines the hues applied to different data elements for differentiation or emphasis, like blue and orange in the example above.\\n\\n\u201cgraph_title\u201d provides the overarching title or caption for the graph. It succinctly summarizes the purpose or main findings depicted in the visual representation, for example, \u201cComparison of Animal Counts in the group\u201d.\\n\\n\u201clegend_title\u201d describes the title of the legend, which typically explains the meaning of different colors or symbols used in the graph. It aids in understanding the data categories or groups represented, such as \u201cAnimal\u201d.\\n\\n\u201clabels\u201d refers to the labels associated with the visualized data points or categories. These labels provide context for interpreting the data. In the example above, it is \u201cCat\u201d and \u201cDog\u201d.\\n\\n\u201cx_label\u201d indicates the title for the x-axis, representing the horizontal dimension of the graph. It clarifies what the x-axis measures or represents, e.g., \u201cGroup\u201d.\\n\\n\u201cy_label\u201d represents the title for the y-axis, which denotes the vertical dimension of the graph. It clarifies what the y-axis measures or represents, e.g., \u201cCount\u201d.\\n\\n\u201cxtick_labels\u201d refers to the specific labels assigned to individual ticks or points along the x-axis. These labels provide scale and context to the data points plotted on the x-axis, e.g., \u201cGroup 1\u201d, \u201cGroup 2\u201d, \u201cGroup 3\u201d, \u201cGroup 4\u201d, \u201cGroup 5\u201d.\\n\\n\u201cytick_labels\u201d represents the specific labels assigned to ticks or points along the y-axis. Similar to xtick_labels, these labels provide scale and context to the data points plotted on the y-axis, e.g., 0, 5, 10, 15, 20, 25, 30, 35.\\n\\nIn this example, the task explicitly specifies the bar chart\u2019s colors, graph_title, x_label, xtick_labels, y_label, legend_title, and labels. Therefore, during evaluation, we will filter out and compare these specific pieces of information.\\n\\nC.2 ML Task Evaluation\\n\\nTo achieve consistent evaluation scores across machine learning tasks of varying difficulty levels and dataset sizes, we normalize evaluation metrics to a scale of 0-1 by setting basic and best bounds. The best bound is determined by the top solutions in the dataset and the highest-ranked metric in the competition. The basic bound is established using baseline methods: for classification tasks, the metric of a Proportional Classifier; for regression tasks, the metric of mean prediction; for clustering tasks, the metric of random clustering. In competition scenarios, the 80th percentile metric is used to determine the basic bound.\\n\\nGiven the best bound $S_{\\\\text{best}}$, the basic bound $S_{\\\\text{baseline}}$, and the predicted score $\\\\hat{s}$ under the corresponding metric calculation, the scaled score is calculated as follows:\\n\\n$$\\\\text{Score} = \\\\min\\\\left(\\\\max\\\\left(\\\\frac{\\\\hat{s} - S_{\\\\text{baseline}}}{S_{\\\\text{best}} - S_{\\\\text{baseline}}}, 0\\\\right), 1\\\\right)$$\\n\\nThis formula ensures that the score is normalized between 0 and 1, adjusting for whether higher or lower values indicate better performance.\\n\\nNext, we will introduce the machine learning metrics used in DA-Code for classification, clustering, and regression tasks.\\n\\nC.2.1 Classification Tasks\\n\\nA detailed description of the metrics used in classification tasks, including their definitions and formulas, is provided below:\\n\\n**Accuracy**\\n\\nAccuracy is defined as the proportion of correctly predicted instances out of the total instances:\\n\\n$$\\\\text{Accuracy} = \\\\frac{\\\\text{Number of correctly predicted instances}}{\\\\text{Total number of instances}}$$\"}"}
{"id": "emnlp-2024-main-748", "page_num": 20, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"The F1 Score is a key evaluation metric for classification tasks, especially with imbalanced datasets. It is the harmonic mean of precision and recall, balancing the two. The F1 Score is calculated as follows:\\n\\n$$F_1 = \\\\frac{2 \\\\times \\\\text{precision} \\\\times \\\\text{recall}}{\\\\text{precision} + \\\\text{recall}}$$\\n\\nPrecision measures the accuracy of positive predictions, while recall measures the ability to identify all positive instances.\\n\\nLogarithmic Loss (LogLoss) is a metric used to evaluate the performance of a classification model by measuring the accuracy of its predicted probabilities. It penalizes incorrect predictions, particularly those that are confidently incorrect. To avoid extremes, predicted probabilities are clipped using the formula:\\n\\n$$\\\\max(\\\\min(p, 1 - e^{-15}), 1 - e^{-15})$$\\n\\nLogLoss can be computed in two primary ways:\\n\\n- One method involves averaging each class separately and then aggregating these averages.\\n\\n$$\\\\text{LogLoss} = -\\\\frac{1}{M} \\\\sum_{j=1}^{M} \\\\frac{1}{N_j} \\\\sum_{i=1}^{N_j} y_{ij} \\\\log(p_{ij})$$\\n\\nwhere $M$ is the number of classes, $N_j$ is the number of samples in class $j$, $y_{ij}$ is a binary indicator (0 or 1) if class label $j$ is the correct classification for sample $i$, and $p_{ij}$ is the predicted probability of sample $i$ being in class $j$.\\n\\n- Additionally, the other method involves averaging directly over all predictions without distinction by class.\\n\\n$$\\\\text{LogLoss} = -\\\\frac{1}{N} \\\\sum_{i=1}^{N} \\\\sum_{j=1}^{M} y_{ij} \\\\log(p_{ij})$$\\n\\nwhere $N$ is the total number of samples, $M$ is the number of classes, $y_{ij}$ is a binary indicator (0 or 1) if class label $j$ is the correct classification for sample $i$, and $p_{ij}$ is the predicted probability of sample $i$ being in class $j$.\\n\\nROC AUC Score (Receiver Operating Characteristic Area Under the Curve) is a performance metric for binary classification tasks that evaluates the ability of a model to distinguish between classes. It measures the area under the ROC curve, which plots the true positive rate (sensitivity) against the false positive rate (1 - specificity) at various threshold settings.\\n\\n$$\\\\text{ROC AUC Score} = \\\\frac{N_{pos}}{N_{pos} \\\\cdot N_{neg}} \\\\sum_{i \\\\in \\\\text{pos}} \\\\sum_{j \\\\in \\\\text{neg}} I(\\\\hat{y}_i > \\\\hat{y}_j)$$\\n\\nwhere $N_{pos}$ and $N_{neg}$ are the numbers of positive and negative samples respectively, $\\\\hat{y}_i$ and $\\\\hat{y}_j$ are the predicted scores for samples $i$ and $j$, and $I(\\\\cdot)$ is the indicator function that returns 1 if the condition is true and 0 otherwise.\\n\\nQuadratic Weighted Kappa (QWK) is a metric used to assess the agreement between two ratings or annotations. It measures the extent of agreement beyond chance, considering both the magnitude of disagreement and its quadratic impact.\\n\\n$$\\\\kappa = 1 - \\\\frac{\\\\sum_{i,j} w_{ij} O_{ij}}{\\\\sum_{i,j} w_{ij} E_{ij}}$$\\n\\nwhere $O_{ij}$ is the observed agreement, $E_{ij}$ is the expected agreement, $w_{ij} = (i - j)^2 / (N - 1)^2$ represents the squared difference between ratings $i$ and $j$, and $N$ is the total number of categories.\\n\\nC.2.2 Clustering Tasks\\n\\nThe evaluation metric used for clustering tasks is introduced below.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 21, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Silhouette Score\\n\\nSilhouette score is a metric used to evaluate the quality of clustering in unsupervised learning. It measures how similar each sample is to its cluster compared to other clusters. The score ranges from -1 to 1, where a higher value indicates that samples are well-clustered, with tight clusters and distinct separation between them.\\n\\nThe formula for the Silhouette score for a single sample $i$ is:\\n\\n$$s(i) = \\\\frac{b(i) - a(i)}{\\\\max(a(i), b(i))}$$\\n\\nwhere $a(i)$ is the average distance from sample $i$ to other samples within the same cluster (intra-cluster distance), and $b(i)$ is the average distance from sample $i$ to samples in the nearest neighboring cluster (inter-cluster distance).\\n\\nThe overall Silhouette score is the mean of $s(i)$ for all samples in the dataset.\\n\\nC.2.3 Regression Tasks\\n\\nThe evaluation metrics used for regression tasks are introduced below.\\n\\nThe Coefficient of Determination\\n\\nThe coefficient of determination ($R^2$) is used to evaluate the proportion of variance in the dependent variable that is predictable from the independent variables. It indicates how well the regression predictions approximate the real data points.\\n\\nThe formula for $R^2$ is:\\n\\n$$R^2 = 1 - \\\\frac{\\\\sum_{i=1}^{N} (y_i - \\\\hat{y}_i)^2}{\\\\sum_{i=1}^{N} (y_i - \\\\bar{y})^2}$$\\n\\nwhere $N$ is the number of observations, $y_i$ is the actual value, $\\\\hat{y}_i$ is the predicted value, and $\\\\bar{y}$ is the mean of the actual values. An $R^2$ value closer to 1 indicates a better fit of the model to the data.\\n\\nRoot Mean Squared Error\\n\\nRoot Mean Squared Error (RMSE) is used to evaluate the accuracy of regression models by measuring the square root of the average squared differences between predicted and actual values. It emphasizes larger errors due to squaring the differences.\\n\\nThe formula for RMSE is:\\n\\n$$RMSE = \\\\sqrt{\\\\frac{1}{N} \\\\sum_{i=1}^{N} (\\\\hat{y}_i - y_i)^2}$$\\n\\nwhere $N$ is the number of observations, $\\\\hat{y}_i$ is the predicted value, and $y_i$ is the actual value. Lower RMSE values indicate better model performance, with a greater penalty for larger errors.\\n\\nRoot Mean Squared Logarithmic Error\\n\\nRoot Mean Squared Logarithmic Error (RMSLE) is used to evaluate the performance of regression models by measuring the logarithmic differences between predicted and actual values. It is particularly useful when the target variable spans several orders of magnitude.\\n\\nThe formula for RMSLE is:\\n\\n$$RMSLE = \\\\sqrt{\\\\frac{1}{N} \\\\sum_{i=1}^{N} (\\\\log(\\\\hat{y}_i + 1) - \\\\log(y_i + 1))^2}$$\\n\\nwhere $N$ is the number of observations, $\\\\hat{y}_i$ is the predicted value, and $y_i$ is the actual value.\\n\\nMean Absolute Error\\n\\nMean Absolute Error (MAE) is used to evaluate the accuracy of regression models by measuring the average magnitude of errors in predictions, irrespective of their direction. It provides a straightforward measure of the average prediction error.\\n\\nThe formula for MAE is:\\n\\n$$MAE = \\\\frac{1}{N} \\\\sum_{i=1}^{N} |\\\\hat{y}_i - y_i|$$\\n\\nwhere $N$ is the number of observations, $\\\\hat{y}_i$ is the predicted value, and $y_i$ is the actual value. Lower MAE values indicate better model performance.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 22, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Median Absolute Error\\n\\nMedian Absolute Error (MedAE) is used to evaluate the accuracy of regression models by measuring the median of the absolute differences between predicted and actual values. It provides a robust metric that is less sensitive to outliers.\\n\\nThe formula for MedAE is:\\n\\n$$\\\\text{MedAE} = \\\\text{median}(|\\\\hat{y}_i - y_i|)$$\\n\\nwhere $\\\\hat{y}_i$ is the predicted value and $y_i$ is the actual value. Lower MedAE values indicate better model performance, with the metric focusing on the central tendency of errors.\\n\\nSymmetric Mean Absolute Percentage Error\\n\\nSymmetric Mean Absolute Percentage Error (SMAPE) is used to evaluate the accuracy of regression models by measuring the percentage error between predicted and actual values, treating over- and under-predictions equally.\\n\\nThe formula for SMAPE is:\\n\\n$$\\\\text{SMAPE} = \\\\frac{100%}{N} \\\\sum_{i=1}^{N} \\\\frac{|\\\\hat{y}_i - y_i|}{(|\\\\hat{y}_i| + |y_i|)/2}$$\\n\\nwhere $N$ is the number of observations, $\\\\hat{y}_i$ is the predicted value, and $y_i$ is the actual value. Lower SMAPE values indicate better model performance, with the metric providing a balanced view of relative prediction errors.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 23, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Prompts of DA-Agent\\n\\nFollowing the ReAct (Yao et al., 2022) prompting framework, which guides models in breaking down complex problems into manageable steps through an iterative chain of reasoning (Reasoning), action (Action), and observation (Observation) phases, where the current state is observed after each action before proceeding to the next step of reasoning, we build the DA-Agent. Below, we will introduce the system messages and actions used within this framework.\\n\\nD.1 System Prompt\\n\\n# Context #\\nYou are a data scientist proficient in analyzing data. You excel at using Bash commands and Python code to solve data-related problems. You are working in a Bash environment with all necessary Python libraries installed. If you need to install additional libraries, you can use the 'pip install' command. You are starting in the {work_dir} directory, which contains all the data needed for your tasks. You can only use the actions provided in the ACTION SPACE to solve the task. The maximum number of steps you can take is {max_steps}.\\n\\n# ACTION SPACE #\\n{action_prompts}\\n\\n# NOTICE #\\n1. You need to fully understand the action space and its arguments before using it.\\n2. You should first understand the environment and conduct data analysis on the given data before handling the task.\\n3. You can't take some problems for granted. For example, you should check the existence of files before reading them.\\n4. If the function execution fails, you should analyze the error and try to solve it.\\n5. For challenging tasks like ML, you may need to verify the correctness of the method by checking the accuracy or other metrics, and try to optimize the method.\\n6. Before finishing the task, ensure all instructions are met and verify the existence and correctness of any generated files.\\n\\n# RESPONSE FORMAT #\\nFor each task input, your response should contain:\\n1. One analysis of the task and the current environment, reasoning to determine the next action (prefix \\\"Thought: \\\").\\n2. One action string in the ACTION SPACE (prefix \\\"Action: \\\").\\n\\n# EXAMPLE INTERACTION #\\nObservation: ...(the output of last actions, as provided by the environment and the code output, you don't need to generate it)\u21aa\u2192\\nThought: ...\\nAction: ...\\n\\n# TASK #\\n{task}\"}"}
{"id": "emnlp-2024-main-748", "page_num": 24, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"D.2 Action Prompts\\n\\nBash Action\\n## Bash Action\\n* Signature: Bash(code=\\\"shell_command\\\")\\n* Description: This action string will execute a valid shell command in the `code` field. Only non-interactive commands are supported. Commands like \\\"vim\\\" and viewing images directly (e.g., using \\\"display\\\") are not allowed.\\n* Example: Bash(code=\\\"ls -l\\\")\\n\\nPython Action\\n## Python Action\\n* Signature: Python(file_path=\\\"path/to/python_file\\\"):\\n```\\npython\\nexecutable_python_code\\n```\\n* Description: This action will create a python file in the field `file_path` with the content wrapped by paired ````` symbols. If the file already exists, it will be overwritten. After creating the file, the python file will be executed.\\n* Example: Python(file_path=\\\"./hello_world.py\\\"):\\n```\\npython\\nprint(\\\"Hello, world!\\\")\\n```\\n\\nSQL Action\\n## SQL Action\\n* Signature: SQL(file_path=\\\"path/to/database_file\\\", command=\\\"sql_command\\\", output=\\\"path/to/output_file.csv\\\" or \\\"direct\\\")\\n* Description: Executes an SQL command on the specified database file. If `output` is set to a file path, the results are saved to this CSV file; if set to 'direct', results are displayed directly.\\n* Constraints:\\n  - The database file must be accessible and in a format compatible with SQLite (e.g., .sqlite, .db).\\n  - SQL commands must be valid and safely formatted to prevent security issues such as SQL injection.\\n* Examples:\\n- Example1: SQL(file_path=\\\"data.sqlite\\\", command=\\\"SELECT name FROM sqlite_master WHERE type='table'\\\", output=\\\"directly\\\")\\n- Example2: SQL(file_path=\\\"data.db\\\", command=\\\"SELECT * FROM users\\\", output=\\\"users_output.csv\\\")\"}"}
{"id": "emnlp-2024-main-748", "page_num": 25, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"**Terminate Action**\\n\\n* Signature: `Terminate(output=\\\"literal_answer_or_output_path\\\")`\\n\\n* Description: This action denotes the completion of the entire task and returns the final answer or the output file/folder path. Make sure the output file is located in the initial workspace directory.\\n\\n* Examples:\\n  - Example1: `Terminate(output=\\\"New York\\\")`\\n  - Example2: `Terminate(output=\\\"result.csv\\\")`\\n  - Example3: `Terminate(output=\\\"FAIL\\\")`\"}"}
{"id": "emnlp-2024-main-748", "page_num": 26, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"This section provides action trajectory examples based on DA-Agent framework powered by GPT-4.\\n\\n## Example 1\\n\\n* Task: This is a dataset titled \\\"The-GitHub-History-of-the-Scala-Language,\\\" with detailed descriptions provided in the README.md file. I want to know the number of pull requests made by two users with the nicknames \\\"soc\\\" and \\\"xeno-by\\\" for each year between 2011 and 2016. Please fill in your statistical results in the provided template file pull_requests_by_year_and_author.csv.\\n\\n* Observation: You are in the folder now.\\n\\n* Thought: Before I can analyze the data, I need to understand the structure of the dataset and the contents of the README.md file to know how the data is organized. I will use the `cat` command to display the contents of the README.md file.\\n\\n* Action: Bash(code=\\\"cat README.md\\\")\\n\\n* code: cat README.md\\n\\n* Observation: # The-GitHub-History-of-the-Scala-Language\\n\\n## Project Description\\n\\nOpen source projects contain entire development histories - who made changes, the changes themselves, and code reviews. In this project, will be challenged to read in, clean up, and visualize the real-world project repository of Scala that spans data from a version control system (Git) as well as a project hosting site (GitHub). With almost 30,000 commits and a history spanning over ten years, Scala is a mature language. Will find out who has had the most influence on its development and who are the experts.\\n\\nThe dataset includes the project history of Scala retrieved from Git and GitHub as a set of CSV files.\\n\\n* Thought: The README.md file indicates that the dataset consists of CSV files containing the project history of Scala from Git and GitHub. However, it does not specify the exact filenames or their contents. To proceed, I need to list the files in the current directory to identify the CSV files that might contain the pull request data.\\n\\n* Action: Bash(code=\\\"ls -l\\\")\\n\\n* code: ls -l\\n\\n13512\"}"}
{"id": "emnlp-2024-main-748", "page_num": 27, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Thought: There are two CSV files that could contain the pull request data: `pull_files.csv` and `pulls.csv`. The `pull_requests_by_year_and_author.csv` file is likely the template I need to fill in with the statistical results. To determine which CSV file contains the pull request data and the information about the authors and dates, I should take a look at the first few lines of each CSV file. I will start by examining the `pulls.csv` file using the `head` command.\\n\\n```\\n163314316,hrhino,2018-01-16T23:29:16Z\\n163061502,joroKr21,2018-01-15T23:44:52Z\\n163057333,mkeskells,2018-01-15T23:05:06Z\\n162985594,lrytz,2018-01-15T15:52:39Z\\n162838837,zuvizudar,2018-01-14T19:16:16Z\\n162765232,howtonotwin,2018-01-13T04:37:17Z\\n162643301,hrhino,2018-01-12T14:29:49Z\\n162256029,mkeskells,2018-01-10T23:20:03Z\\n162197834,SethTisue,2018-01-10T18:31:25Z\\n```\\n\\nThought: The `pulls.csv` file contains the columns `pid`, `user`, and `date`, which are the pull request ID, the username of the person who made the pull request, and the date the pull request was made, respectively. Since the task requires the number of pull requests made by the users \\\"soc\\\" and \\\"xeno-by\\\" for each year between 2011 and 2016, this file seems to contain the necessary information. I will now write a Python script to read this CSV file, filter the data for the two users and the specified years, and count the number of pull requests per year for each user. Then, I will fill in the results in the `pull_requests_by_year_and_author.csv` template file.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 28, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"```python\\nimport pandas as pd\\n\\n# Load the pull requests data\\npulls = pd.read_csv('pulls.csv')\\n\\n# Convert the date column to datetime\\npulls['date'] = pd.to_datetime(pulls['date'])\\n\\n# Filter the data for the years 2011-2016 and for the users 'soc' and 'xeno-by'\\nfiltered_pulls = pulls[(pulls['date'].dt.year >= 2011) & (pulls['date'].dt.year <= 2016) & (pulls['user'].isin(['soc', 'xeno-by']))]\\n\\n# Group by year and user, then count the number of pull requests\\npulls_by_year_and_user = filtered_pulls.groupby([filtered_pulls['date'].dt.year, 'user']).size().reset_index(name='count')\\n\\n# Load the template file\\ntemplate = pd.read_csv('pull_requests_by_year_and_author.csv')\\n\\n# Merge the results with the template\\nresult = template.merge(pulls_by_year_and_user, how='left', left_on=['year', 'author'], right_on=['date', 'user']).fillna(0)\\n\\n# Drop the extra columns and save the result\\nresult = result[['year', 'author', 'count']]\\nresult.to_csv('pull_requests_by_year_and_author.csv', index=False)\\n```\"}"}
{"id": "emnlp-2024-main-748", "page_num": 29, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"# Merge the results with the template\\n```\\nresult = template.merge(pulls_by_year_and_user, how='left',\\n left_on=['year', 'author'], right_on=['date', 'user']).fillna(0)\\n```\\n\\n# Drop the extra columns and save the result\\n```\\nresult = result[['year', 'author', 'count']].to_csv('pull_requests_by_year_and_author.csv', index=False)\\n```\\n\\n* **Step 5**\\n\\n* **Observation:** Traceback (most recent call last):\\n```\\nFile \"/workspace/./analyze_pulls.py\", line 19, in <module>\\nresult = template.merge(pulls_by_year_and_user, how='left',\\n left_on=['year', 'author'], right_on=['date', 'user']).fillna(0)\\n```\\n->\\n```\\nFile \"/usr/local/lib/python3.9/site-packages/pandas/core/frame.py\", line 10832, in merge\\n  return merge(\\nFile \"/usr/local/lib/python3.9/site-packages/pandas/core/reshape/merge.py\", line 170, in merge\\n    op = _MergeOperation(\\nFile \"/usr/local/lib/python3.9/site-packages/pandas/core/reshape/merge.py\", line 794, in __init__\\n    left_keys.append(left._get_label_or_level_values(lk))\\nFile \"/usr/local/lib/python3.9/site-packages/pandas/core/generic.py\", line 1911, in _get_label_or_level_values\\n  raise KeyError(key)\\nKeyError: 'year'\\n```\\n\\n* **Thought:** The error indicates that the 'year' column is not present in the `pull_requests_by_year_and_author.csv` template file, which means I cannot merge on this column. I need to check the contents of the `pull_requests_by_year_and_author.csv` template file to understand its structure and correct the merge operation accordingly.\\n\\n* **Action:** Bash(code=\\\"cat pull_requests_by_year_and_author.csv\\\")\\n\\n```\\n# cat pull_requests_by_year_and_author.csv\\n\\ndate,soc,xeno-by\\n2011,,\\n2012,,\\n2013,,\\n2014,,\\n2015,,\\n2016,\\n```\\n\\n* **Step 6**\\n\\n* **Observation:** date,soc,xeno-by\\n```\\n2011,,\\n2012,,\\n2013,,\\n2014,,\\n2015,,\\n2016,,\\n```\\n\\n# Merge the results with the template\\n```\\nresult = template.merge(pulls_by_year_and_user, how='left',\\n left_on=['year', 'author'], right_on=['date', 'user']).fillna(0)\\n```\\n\\n# Drop the extra columns and save the result\\n```\\nresult = result[['year', 'author', 'count']].to_csv('pull_requests_by_year_and_author.csv', index=False)\\n```\"}"}
{"id": "emnlp-2024-main-748", "page_num": 30, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Thought: The template file `pull_requests_by_year_and_author.csv` has columns for 'date', 'soc', and 'xeno-by', with the 'date' column representing the year. The error occurred because I tried to merge on a 'year' column that does not exist in the template. Instead, I should use the 'date' column for merging. I need to adjust the Python script to correctly merge the data based on the 'date' column and fill in the counts for 'soc' and 'xeno-by' in their respective columns.\\n\\n```python\\nimport pandas as pd\\n\\n# Load the pull requests data\\npulls = pd.read_csv('pulls.csv')\\n\\n# Convert the date column to datetime\\npulls['date'] = pd.to_datetime(pulls['date'])\\n\\n# Filter the data for the years 2011-2016 and for the users 'soc' and 'xeno-by'\\nfiltered_pulls = pulls[(pulls['date'].dt.year >= 2011) & (pulls['date'].dt.year <= 2016) & (pulls['user'].isin(['soc', 'xeno-by']))]\\n\\n# Group by year and user, then count the number of pull requests\\npulls_by_year_and_user = filtered_pulls.groupby([filtered_pulls['date'].dt.year, 'user']).size().reset_index(name='count')\\n\\n# Pivot the result to have years as rows and users as columns\\npivot_table = pulls_by_year_and_user.pivot(index='date', columns='user', values='count').reset_index().fillna(0)\\n\\n# Rename the columns to match the template file\\npivot_table.columns = ['date', 'soc', 'xeno-by']\\n\\n# Load the template file\\ntemplate = pd.read_csv('pull_requests_by_year_and_author.csv')\\n\\n# Merge the results with the template\\nresult = template.merge(pivot_table, on='date', how='left').fillna(0)\\n\\n# Drop the extra columns and save the result\\nresult = result[['date', 'soc', 'xeno-by']]\\nresult.to_csv('pull_requests_by_year_and_author.csv', index=False)\\n```\"}"}
{"id": "emnlp-2024-main-748", "page_num": 31, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Filter the data for the years 2011-2016 and for the users 'soc' and 'xeno-by'.\\n\\n```python\\nfiltered_pulls = pulls[(pulls['date'].dt.year >= 2011) & (pulls['date'].dt.year <= 2016) & (pulls['user'].isin(['soc', 'xeno-by']))]\\n```\\n\\nGroup by year and user, then count the number of pull requests:\\n\\n```python\\npulls_by_year_and_user = filtered_pulls.groupby([filtered_pulls['date'].dt.year, 'user']).size().reset_index(name='count')\\n```\\n\\nPivot the result to have years as rows and users as columns:\\n\\n```python\\npivot_table = pulls_by_year_and_user.pivot(index='date', columns='user', values='count').reset_index().fillna(0)\\n```\\n\\nRename the columns to match the template file:\\n\\n```python\\npivot_table.columns = ['date', 'soc', 'xeno-by']\\n```\\n\\nLoad the template file:\\n\\n```python\\ntemplate = pd.read_csv('pull_requests_by_year_and_author.csv')\\n```\\n\\nMerge the results with the template:\\n\\n```python\\nresult = template.merge(pivot_table, on='date', how='left').fillna(0)\\n```\\n\\nDrop the extra columns and save the result:\\n\\n```python\\nresult = result[['date', 'soc', 'xeno-by']]\\nresult.to_csv('pull_requests_by_year_and_author.csv', index=False)\\n```\\n\\n**Step 7**\\n\\n* Observation: Traceback (most recent call last):\\n\\n```python\\nFile \"/workspace/./analyze_pulls.py\", line 28, in <module>\\nresult = result[['date', 'soc', 'xeno-by']]\\nFile \"/usr/local/lib/python3.9/site-packages/pandas/core/frame.py\", line 4108, in __getitem__\\nindexer = self.columns._get_indexer_strict(key, \\\"columns\\\")[1]\\nFile \\\"/usr/local/lib/python3.9/site-packages/pandas/core/indexes/base.py\\\", line 6200, in _get_indexer_strict\\nself._raise_if_missing(keyarr, indexer, axis_name)\\nFile \\\"/usr/local/lib/python3.9/site-packages/pandas/core/indexes/base.py\\\", line 6252, in _raise_if_missing\\nraise KeyError(f\\\"{not_found} not in index\\\")\\nKeyError: \\n```\\n\\n* Thought: The error indicates that the columns 'soc' and 'xeno-by' are not found in the merged result, which suggests that the pivot operation did not produce these columns. This could be because the pivot operation did not find any data for these users in the specified years, or because the pivot operation was not performed correctly. I need to ensure that the pivot operation creates the columns for 'soc' and 'xeno-by' even if there are no pull requests for them in the data. I will modify the script to handle cases where there are no pull requests for these users by explicitly adding these columns if they are missing after the pivot operation.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 32, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"```python\\nimport pandas as pd\\n\\n# Load the pull requests data\\npulls = pd.read_csv('pulls.csv')\\n\\n# Convert the date column to datetime\\npulls['date'] = pd.to_datetime(pulls['date'])\\n\\n# Filter the data for the years 2011-2016 and for the users 'soc' and 'xeno-by'\\nfiltered_pulls = pulls[(pulls['date'].dt.year >= 2011) &\\n                        (pulls['date'].dt.year <= 2016) &\\n                        (pulls['user'].isin(['soc', 'xeno-by']))]\\n\\n# Group by year and user, then count the number of pull requests\\npulls_by_year_and_user = filtered_pulls.groupby([filtered_pulls['date'].dt.year, 'user']).size().reset_index(name='count')\\n\\n# Pivot the result to have years as rows and users as columns, filling missing values with 0\\npivot_table = pulls_by_year_and_user.pivot(index='date', columns='user', values='count').fillna(0).reset_index()\\n\\n# Ensure that 'soc' and 'xeno-by' columns exist, adding them if they don't\\nif 'soc' not in pivot_table:\\npivot_table['soc'] = 0\\nif 'xeno-by' not in pivot_table:\\npivot_table['xeno-by'] = 0\\n\\n# Rename the columns to match the template file\\npivot_table.rename(columns={'date': 'date'}, inplace=True)\\n\\n# Load the template file\\ntemplate = pd.read_csv('pull_requests_by_year_and_author.csv')\\n\\n# Merge the results with the template\\nresult = template.merge(pivot_table, on='date', how='left').fillna(0)\\n\\n# Save the result\\nresult.to_csv('pull_requests_by_year_and_author.csv', index=False)\\n```\"}"}
{"id": "emnlp-2024-main-748", "page_num": 1, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Abstract\\n\\nWe introduce DA-Code, a code generation benchmark specifically designed to assess LLMs on agent-based data science tasks. This benchmark features three core elements: First, the tasks within DA-Code are inherently challenging, setting them apart from traditional code generation tasks and demanding advanced coding skills in grounding and planning. Second, examples in DA-Code are all based on real and diverse data, covering a wide range of complex data wrangling and analytics tasks. Third, to solve the tasks, the models must utilize complex data science programming languages, to perform intricate data processing and derive the answers. We set up the benchmark in a controllable and executable environment that aligns with real-world data analysis scenarios and is scalable. The annotators meticulously design the evaluation suite to ensure the accuracy and robustness of the evaluation. We develop the DA-Agent baseline. Experiments show that although the baseline performs better than other existing frameworks, using the current best LLMs achieves only 30.5% accuracy, leaving ample room for improvement. We release our benchmark at https://github.com/yiyihum/dabench.\\n\\n1 Introduction\\n\\nData science is pivotal in extracting insights from data (Wang et al., 2021), fundamentally shaping decision-making and knowledge discovery. Traditionally, this field has required high proficiency in programming and specialized knowledge, which poses significant barriers to non-experts. However, the rapid advancement of Large Language Models (LLMs) (OpenAI, 2023; Anthropic, 2024; Team et al., 2023) has greatly enhanced their capabilities in code generation, grounding, and planning. This raises an intriguing question: Can LLMs become...\"}"}
{"id": "emnlp-2024-main-748", "page_num": 2, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"autonomous data scientists, capable of independent decision-making and solving agent data science problems?\\n\\nWe define the agent data science task as one that encompasses a challenging task, diverse data source, and complex solution, as shown in Figure 1. First, a code agent task is designed to explore data and utilize programming techniques to tackle challenging objectives, rather than simply translating explicit natural language instructions into code. Unlike previous benchmarks like DS-1000 (Lai et al., 2023) and Arcade (Yin et al., 2023), which focus on natural language grounding (Xie et al., 2022) and transforming instructions into executable code, our approach aligns more closely with real-world programming scenarios. Second, the data source is diverse, encompassing a variety of information and data from real programming scenarios\u2014beyond just a notebook environment (Yin et al., 2023) or code-completion tasks (Lai et al., 2023). It includes different data types such as databases, spreadsheets, documents, code, and more. Moreover, these resources can be replete with distractions and extraneous information. Third, for task solutions, data analysts must engage in a step-by-step thinking and reasoning process while programming. This involves inspecting data, writing minimal code, and continuous debugging. Additionally, they utilize Python, SQL, and Bash, which are commonly used programming languages in data science, to complete the tasks.\\n\\nTo achieve this goal, we introduce DA-Code, a benchmark for evaluating LLM data analysis ability, with carefully defined task scenarios. DA-Code contains 500 complex task examples, originating from real, challenging data analysis tasks, encompassing three main categories: data wrangling (DW), machine learning (ML) and exploratory data analysis (EDA). It covers the entire data analysis pipeline. Data wrangling includes a variety of tasks such as data loading, data cleaning, and data merging, specifically targeting raw data in files and databases. EDA aims to gain insights and analysis using the given information and resources. It includes a wide variety of data analysis tasks using programming languages such as SQL and Python to get insights from data. For ML tasks, how the model governs the entire ML pipeline is a promising research direction. Each example in DA-Code is meticulously designed according to the standards of the code agent task mentioned above, ensuring high quality and complexity. We meticulously design an evaluation suite for each example, and conduct red teaming experiments to validate the robustness of the evaluations.\\n\\nDA-Code is inspired by the definitions used in intercode (Yang et al., 2024b). We create an interactive sandbox environment and implement DA-Code within this setting. This setup allows LLMs/Agents to explore the environment and engage in autonomous reasoning to complete tasks. This enables researchers to conduct their explorations in this user-friendly interactive environment. Based on this setting, we develop a code agent baseline framework. This is capable of writing Python and SQL code and can interact with command lines, databases, and other interfaces. As shown in Figure 1, for this EDA task, the agent needs to explore all the resources provided to it, decide which files to use, write the code, and autonomously complete the task step by step.\\n\\nWe evaluate multiple state-of-the-art language models on DA-Code, and the experimental results indicate that achieving high scores on these tasks is challenging. For LLMs and LLM-Agents, autonomously completing real and complex data science tasks continues to be a significant challenge. Overall, DA-Code represents an agent data science benchmark with challenging real-world settings, providing valuable data resources for current LLM-agents aspiring to become data scientists.\\n\\n2 Data Science Agent Task\\n\\nIn this section, we introduce the data science agent task and categories of tasks for DA-Code.\\n\\n2.1 Task Definition\\n\\nThe traditional coding task can be represented as:\\n\\n$$\\\\text{code} = f(C,I)$$\\n\\nwhere code is the result of a function $f$ that translates contextual information $C$ (environmental factors, constraints) and specific instructions $I$ (requirements, tasks) into executable code.\\n\\nIn our coding task, interaction with the environment involves iterative code modification. The following sets are defined:\\n\\n- $S$ (state space),\\n- $A$ (action space),\\n- $O$ (observation space),\\n- $C$ (code space), and\\n- $H$ (history space) defined as $H: A \\\\times C \\\\times O$.\\n\\nThe process can be represented as follows:\\n\\n**Action Generation.** The agent takes the memory $m_t \\\\in H$ and current state $s_t \\\\in S$ to generate the next action $a_{t+1} \\\\in A$ and the updated code $\\\\text{code}_{t+1} \\\\in C$. We use the function $f^* : H \\\\times S \\\\rightarrow$.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 3, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Manually Selecting Data Source Rewrite Task or Define New Task  \\nTask Implementation Evaluation Setup Cross Validation ... Is the task design reasonable?  \\n2. Is the environment setup appropriate?  \\n3. Is the evaluation robust?  \\nScore-function\\n\\nFigure 2: Annotation pipeline of DA-Code. See the start of Section 3.5 for a detailed description.\\n\\nA\u00d7C  \\n\\nAction Execution. The environment then interprets the agent's actions and code, executing them on the current state to update the environment and obtain the new state and the observation . This process can be represented by the function .\\n\\nMemory Update. Subsequently, the agent's memory is updated to with the action , code and observation . This update is constrained by the memory window size . If the updated memory length exceeds the agent will discard the earliest memory. This process can be represented by the function .\\n\\nThis iterative process allows the agent to continually adapt and improve its code based on the evolving historical context until the agent takes an action that marks the completion of the task or reaches the maximum time set by the environment.\\n\\n2.2 Task Categories\\nDA-Code focuses on data science tasks and categorizes them into three major categories: data wrangling, machine learning, and exploratory data analysis.\\n\\nData Wrangling. Data wrangling is the process of transforming and mapping raw data from one form into another to prepare it for analysis. It involves cleaning, loading, and transforming raw data into a more usable format. This can include handling missing values, correcting errors, and merging datasets from different sources. The goal of data wrangling is to ensure that the data is consistent and easily accessible for tasks such as analytics, reporting, or machine learning applications. The examples are shown in Figure 2 and Figure 4.\\n\\nExploratory Data Analysis. Exploratory Data Analysis is a technique used in data analysis to understand the main characteristics and get insights from a dataset. There are many types of EDA tasks, which require LLMs to use a combination of various Python libraries and SQL to complete complex data analysis tasks. The types of tasks included in DA-Code are statistical analysis, data manipulation, data insights, and data visualization. The example in Figure 1 is typical of this type of task.\\n\\n\u2022 Data Manipulation is designed to perform intricate data operations using SQL and Pandas, efficiently processing large datasets. It primarily focuses on counting, summarizing data, and refining presentation formats.\\n\\n\u2022 Data Insights focuses on tasks involving real data and issues encountered in actual scenarios. These problems do not provide clear solutions, necessitating thoughtful consideration and autonomous decision-making in coding for data analysis. The results are presented primarily in tables, or alternatively, in text format, to address and answer these questions.\\n\\n\u2022 Visualization is similar to the previous category, with the unique aspect being that the results are presented in the form of charts.\\n\\n\u2022 Statistical Analysis typically requires advanced knowledge of statistics and mathematics, involving the use of mathematical indicators for analysis.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 4, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Table 1: Comparisons of several data science code generation benchmarks.\\n\\n| Benchmark          | Evaluation Method | Total Tasks | Data Wrangling | Machine Learning | Data Manipulation | Data Insights | Visualization | Statistical Analysis | Overall Evaluation |\\n|--------------------|-------------------|-------------|----------------|------------------|-------------------|---------------|----------------|----------------------|-------------------|\\n| DS-1000 (Lai et al., 2023) |                  | 1000        | 100 (20.0%)    | 100 (20.0%)      | 73 (14.6%)       | 79 (15.8%)   | 70 (14.0%)    | 78 (15.6%)            |                   |\\n| Arcade (Yin et al., 2023)   |                  | 1078        | 100 (20.0%)    | 100 (20.0%)      | 79 (15.8%)       | 70 (14.0%)   | 78 (15.6%)    | Output Match         |                   |\\n| MLAgentBench (Huang et al., 2023) | \u2713 \u2713         | 4.8         | 13 - Evaluation Scripts |                   |                   |               |               |                      |                   |\\n| DA-Bench (Hu et al., 2024)  |                  | 257         | 100 (20.0%)    | 100 (20.0%)      | 73 (14.6%)       | 79 (15.8%)   | 70 (14.0%)    | Output Match         |                   |\\n| DA-Code               |                  | 500         | 100 (20.0%)    | 100 (20.0%)      | 73 (14.6%)       | 79 (15.8%)   | 70 (14.0%)    | 78 (15.6%)            |                   |\\n\\nTable 2: Data Statistics of Examples in DA-Code.\\n\\nMachine Learning.\\nML is a crucial data analysis technique, indispensable for automating and enhancing decision-making processes. In DA-Code, we select three foundational task categories: classification, regression, and clustering, from two sources: regular dataset tasks and competition tasks. The reference solutions for these tasks require the use of corresponding ML algorithms (excluding deep learning) to complete the tasks. The details and examples of all task types are provided in Appendix A.\\n\\n3 DA-Code\\nIn this section, we describe the statistical information and construction pipeline of DA-Code.\\n\\n3.1 Challenging Tasks and Diverse Data\\nIn Table 1 and 2, we conduct a statistical analysis where the distribution of tasks among DW, ML, and EDA is in a 1:1:3 ratio. In contrast, DA-Code integrates a diverse array of agent tasks across the entire data science pipeline, covering a broad spectrum of task types and data types (Figure 7), and result formats (such as Tables, Databases, Charts, Text, etc.). During the annotation process, our experienced annotators also categorize the difficulty of each task into three levels: easy, medium, and hard. Additionally, each example in DA-Code involves multiple files, averaging 5.7 files per task. This setup more closely mirrors real data analysis scenarios.\\n\\n3.2 Complex Solution\\nAs shown in Table 1, we curate solution codes for each example, requiring an average of 85 lines of code to complete the tasks. Unlike previous benchmarks, DA-Code uses a controllable executable environment to construct complex coding tasks that require interaction with the environment, planning and coding to complete tasks. Many tasks require the use of languages like SQL and Python, which aligns closely with real-world data science analysis scenarios.\\n\\n3.3 Evaluation Suite\\nWe meticulously develop an accompanying evaluation suite that ensures a comprehensive and systematic assessment of the LLM-Agent performance on DA-Code.\\n\\n3.4 Score Calculation\\nBuilding on the evaluation suite, we develop a scoring methodology to assess LLM-Agent performance across various outputs, including tables, charts, and machine learning predictions. Each output type has tailored metrics for comprehensive evaluation.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 5, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"evaluation. Detailed scoring processes are provided in Appendix C.\\n\\nTable match score. The evaluation of tables involves comparing CSV files or databases, as well as the JSON format for text-based outputs, by matching two tables. The task instructions clearly specify the expected format, and the evaluation checks for an exact match between the task-specified columns in the predicted table $M'$ and the reference table $M$. The score is defined as:\\n\\n$$\\\\text{Score} = \\\\begin{cases} 1, & \\\\text{if } M' = M \\\\\\\\ 0, & \\\\text{otherwise} \\\\end{cases}$$\\n\\nA perfect match results in a score of 1, while any discrepancy results in a score of 0.\\n\\nChart match score. For chart evaluations, our script extracts key metadata from the predicted chart, including both the numerical data $D'$ and plot configurations $I'$ as specified in the task instructions. These components are then compared with the reference chart's true values for numerical data $D$ and plot configurations $I$. The chart match score is calculated using the following rule:\\n\\n$$\\\\text{Score} = \\\\begin{cases} 1, & \\\\text{if } D' = D \\\\text{ and } I' = I \\\\\\\\ 0, & \\\\text{otherwise} \\\\end{cases}$$\\n\\nML normalized score. For machine learning tasks, we utilize several standard metrics, including F1 Score, MAE, Silhouette Score, etc. Given the diverse nature of these metrics across different tasks, we apply a normalization process to map the original scores onto a 0-1 scale, ensuring consistency and comparability. The normalized score is computed using the following formula:\\n\\n$$\\\\text{Score} = \\\\min(1, \\\\max(0, \\\\frac{\\\\hat{s} - S_{\\\\text{baseline}}}{S_{\\\\text{best}} - S_{\\\\text{baseline}}}))$$\\n\\nHere, $\\\\hat{s}$ represents the original score, $S_{\\\\text{best}}$ is the upper performance limit, and $S_{\\\\text{baseline}}$ is the lower bound.\\n\\n3.5 Annotation Pipeline\\nWe recruit ten annotators who are highly proficient in data analysis, SQL, and Python to carry out data collection and annotation. As shown in Figure 2, the data annotation pipeline consists of the following steps:\\n\\nManually Selecting Data Source. The data must come from actual data analysis and engineering projects. We require the datasets to be genuinely large and real, not simulated tables or texts. The data source must meet four principles: (1) real-world relevance, (2) complexity, (3) timeliness, and (4) coding intensity. We collect the most recent data sources from Kaggle, Github, and Other Web Sources. When collecting data, strive to select datasets that come with corresponding code and carefully verify their quality.\\n\\nRewrite Task or Define New Task. According to the definition of data science agent task in Section 2, we have two ways to define tasks. The first method, rewrite task, involves completely redefining discovered task resources by transforming explicit code instructions into abstract agent task descriptions. The second method requires manually annotating new tasks based on these discovered resources. The majority of tasks are derived from conversions of the first type.\\n\\nTask Implementation. DA-Code tasks are set up in a specialized Sandbox environment. The most critical step involves collecting the necessary resources for data analysis. The data we gather is noisy (a task may involve multiple files), and we ensure that this noisy data serves as the initial resource. For the examples shown in Figure 2, which originally only involved a few databases, we create a realistic setting by providing files required in real tasks, such as \\\"data_standard.md\\\" or \\\"schema.yml\\\". The agent needs to extract useful information from these files to complete the task. Unlike traditional language grounding tasks, this process is challenging, requiring decision-making and reasoning.\\n\\nEvaluation Setup. Each example's evaluation configuration is meticulously designed based on our evaluation suite, as detailed in Section 3.3.\\n\\nCross Validation and Red Team Test. We ask annotators to perform cross-validation to ensure each example has a reasonable task design, appropriate environment setup, and robust evaluation. Additionally, they are required to conduct red team testing to determine if there are any false positives or false negatives.\\n\\n4 DA-Agent\\nTo effectively address the challenges of the DA-Code benchmark, we develop an LLM-based agent, depicted in Figure 1, which operates within a versatile and robust framework designed for dynamic interaction and execution with the environment.\\n\\n4.1 Environment\\nInspired by the work of Yang et al. (2024b), the environment of DA-Agent is built on the Docker\"}"}
{"id": "emnlp-2024-main-748", "page_num": 6, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"platform, ensuring a consistent and isolated setting crucial for replicable and independent data science experiments. This Linux environment comes equipped with essential data science tools, including Python, SQL, Conda, and database engines.\\n\\n4.2 Action Space\\n\\nPrevious approaches typically define actions in terms of editing or executing files. However, in our system, we innovatively combine these stages into single, streamlined actions that edit and execute code simultaneously. This approach not only reduces the complexity of interactions but also minimizes the number of steps required, thereby saving computational resources and enhancing model comprehension. Our action space is designed to efficiently manage diverse tasks, encompassing the following actions:\\n\\n- **Bash(command)**: Executes single-line bash commands directly. This enables quick file and directory manipulation and system command execution, providing direct interaction with the operating system.\\n\\n- **Python(save_path, code)**: Requires path and code content of the Python code, allowing the agent to handle complex data processing tasks and utilize Python's extensive libraries.\\n\\n- **SQL(file_path, command, output)**: Executes SQL queries by specifying the database file, SQL command, and the output format. Results can be saved to a specified file or displayed directly.\\n\\n- **Terminate(output)**: Concludes the task, specifying the result file or output text. This final action ensures that results are summarized and appropriately directed, marking a clear end to the session.\\n\\nThis diverse range of actions equips the agent with the capabilities to handle complex tasks across different environments, making it a versatile tool in data manipulation and system operations.\\n\\n4.3 Response Mechanism\\n\\nResponses of the agent are categorized into these types based on the system's feedback to executed actions:\\n\\n- **Standard Output.** The output from successfully executed commands, providing direct feedback or results from the executed actions.\\n\\n- **Error Message.** In cases where execution fails, error messages are generated to aid in debugging and corrective measures.\\n\\n- **Execution Success without Output.** Some commands execute successfully without producing visible output, in which case the system simply acknowledges their successful execution.\\n\\n- **Unacceptable Action.** When the output format does not match the Action format, or the action is the same as the last one, please provide a different action.\\n\\n- **Execution Timeout.** The action execution time has exceeded the time limit.\\n\\n4.4 Memory Windows\\n\\nTo manage the context for the agent's operations, a memory window records the history of actions taken, constrained by a max history length parameter. This parameter limits the number of previous steps the agent can recall. If the required context exceeds this limit, the history is automatically truncated to maintain efficient memory management and focus on the most recent relevant actions.\\n\\n5 Experiment and Analysis\\n\\nIn this section, we present the experimental results and analysis of several LLMs evaluated using our DA-Agent baseline on DA-Code benchmark.\\n\\n5.1 Experiment Settings\\n\\nWe experiment with state-of-the-art LLMs from open-source representatives such as Mixtral-8x22B (Jiang et al., 2024), DeepseekCoder-V2.5 (Zhu et al., 2024), Qwen2.5-72B-Instruct (Team, 2024) and closed-source ones including Claude-3-Opus (Anthropic, 2024) and GPT (OpenAI, 2023) families.\\n\\nWe also compare our DA-Agent with three widely-used agent frameworks, namely OpenDevin (OpenDevin Team, 2024), AutoGen (Wu et al., 2023) and X-Agent (Team, 2023).\\n\\nFor all experiments, we employ a greedy sampling strategy with a maximum step length of 20 and a max history length of up to 15 steps. The action execution time limitation is 300 seconds.\\n\\n5.2 Main Results\\n\\nDA-Agent with Different LLMs. In Table 3, we compare the performances of DA-Agent based on advanced LLMs. In Figure 3, we conduct fine-grained performance statistics for the DA-Code categories. From the score results, we can conclude that 1) Existing data agents are far from satisfactory in completing these data science coding tasks.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 7, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":true,\"is_diagram\":false,\"natural_text\":\"| Machine       | Model      | Score | Completion Rate (%) | # Avg Steps | Executable Code (%) |\\n|---------------|------------|-------|----------------------|-------------|---------------------|\\n| DW ML EDA     | Easy       | 30.4  | 48.4                 | 24.6        | 45.4                |\\n|               | Medium     | 48.4  | 27.8                 | 23.4        | 30.5                |\\n|               | Hard       | 27.8  | 23.4                 | 30.5        | 99.4                |\\n|               | Total      | 7.3   | 76.8                 | 27.8        | 30.5                |\\n|               | GPT-4o     | 33.3  | 48.0                 | 21.3        | 46.2                |\\n|               |            | 25.6  | 21.7                 | 29.1        | 97.4                |\\n|               |            | 6.8   | 77.7                 | 29.1        | 97.4                |\\n|               | Claude-3-Opus | 29.3  | 46.8                 | 20.7        | 44.7                |\\n|               |            | 23.8  | 19.0                 | 27.6        | 97.7                |\\n|               |            | 8.9   | 75.7                 | 27.6        | 97.7                |\\n|               | Qwen2.5-72B | 24.9  | 41.8                 | 15.4        | 31.9                |\\n|               |            | 19.4  | 22.3                 | 22.6        | 93.8                |\\n|               |            | 8.6   | 72.2                 | 22.6        | 93.8                |\\n|               | Deepseek-Coder-V2.5 | 25.1  | 34.1                 | 14.7        | 32.8                |\\n|               |            | 18.7  | 14.1                 | 20.7        | 89.8                |\\n|               |            | 7.1   | 59.0                 | 20.7        | 89.8                |\\n|               | Mixtral-8x22B | 14.8  | 31.6                 | 10.2        | 17.6                |\\n|               |            | 16.8  | 8.6                  | 15.4        | 67.2                |\\n|               | Deepseek-Coder-33B | 9.1   | 22.1                 | 7.6         | 12.4                |\\n|               |            | 11.3  | 7.9                  | 10.8        | 31.9                |\\n|               |            | 11.6  | 10.8                 | 31.9        | 31.9                |\\n\\nTable 3: Experiments results of some LLMs using DA-Agent baseline. The Completion Rate (%) represents the proportion of tasks for which the model produces results within 20 steps. #Avg Steps indicates the number of steps the agent requires to complete these tasks. Executable Code (%) reflects the proportion of code generated by LLMs that successfully executes.\\n\\nFigure 3: Detailed performance analysis of DA-Agent across various categories on DA-Code. The most advanced model, GPT-4, achieves only a 30.5% score. 2) Although closed-source models generate high-performance executable code, they have a significant gap compared to open-source LLMs in terms of overall score. 3) We classify task difficulty into three levels. Experimental results indicate that model performance decreases with increasing difficulty, validating our grading approach. 4) The models perform poorly on data wrangling tasks but fare better in machine learning challenges. This disparity could be linked to the training corpus, as DW and EDA tasks are less common and more complex to understand.\\n\\n5.3 Ablation Study of DA-Agent\\n\\nReference Plan. DA-Code aims to assess the combined abilities of planning and grounding in LLM-agents. To further investigate the factors affecting model performance, we asked annotators to annotate the reference plan of DA-Code-100, as shown in Figure 4. This type of instruction describes a step-by-step plan for solving a task, serving as a reference for the LLM Agents. Table 4 shows that LLMs improve with a reference plan, highlighting planning ability as a key performance factor. Additionally, annotating reference plans provides valuable resources for research exploration.\\n\\nMax History Length. We investigate the impact of max history length on the performance of DA-Agent. As shown in Table 4, using the DA-Code-100 dataset, the model's performance shows minimal change with variations.\\n\\n5.4 Step into Trajectories\\n\\nTask Completion Efficiency. We examine the success and incompletion rates across various models over a sequence of steps, as depicted in Figure 5.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 8, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"1. Review the predefined schema to identify the tables and columns; note that there are five tables and record their column names.\\n\\n2. Check which files are present in the ./data folder.\\n\\n3. Examine the file information; since there are no minutes and hours information, data transformation is necessary.\\n\\n4. Get minutes and hours by the trip_duration.\\n\\n5. The columns for rain and snow do not match with those in the raw data; type conversion is required.\\n\\n6. Merge five months of JC data and compare with the schema to identify any missing columns.\\n\\n7. According to the DB schema, create a station table. These already have IDs, so we just need to create a new table with station id, name, latitude, and longitude.\\n\\n8. Write SQL insert statements to insert the data into the database.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 9, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"we identify several recurring issues that contribute to errors:\\n\\n- **Hallucination Issues**: Agents often make incorrect assumptions about the environment, such as presuming file names and directly executing Python or SQL commands without initial exploration of available files.\\n\\n- **Inability to Follow Instructions**: This leads to many non-standard reply formats and unrecognizable actions. Some models often start with non-standard actions but adjust in later steps.\\n\\n- **Persistent Code Errors**: These errors cause failure to debug and correct issues, leading the model to become stuck in a debugging loop.\\n\\n- **Misinterpretation of Task Context**: Agents sometimes misinterpret task details, leading to premature termination and incomplete results.\\n\\nIn conclusion, our findings underscore the current limitations of agents in tackling complex data challenges. This study provides crucial insights that can direct the enhancement of code agent capabilities through the development of more robust and context-aware strategies.\\n\\n**6 Related Work**\\n\\n**Code Generation Benchmark**\\n\\nAs models become increasingly capable, researchers start to build increasingly difficult and general code generation benchmarks. Most coding benchmarks (e.g. SQL-Spider (Yu et al., 2018); Bash - NL2Bash (Lin et al., 2018); Python - HumanEval (Chen et al., 2021); Execution-S3Eval (Lei et al., 2023); Competition code generation (Huang et al., 2024)) frame the coding problem as a sequence-to-sequence problem (from instruction to code). DS-1000 (Lai et al., 2023) and Arcade (Yin et al., 2023) are pioneering works that collected high-quality examples from communities and proposed corresponding data science to define code generation tasks. Intercode (Yang et al., 2024b) was the first to propose defining code generation tasks in an interactive environment. SWE-Bench (Jimenez et al., 2023) proposed numerous repository-level tasks, while MLAgentBench (Huang et al., 2023) defined auto machine learning tasks in an interactive environment. Some researchers have also proposed benchmarks (Xie et al., 2024; Cao et al., 2024) to explore the model's multimodal capabilities in data science and engineering. ML-Bench (Liu et al., 2023) focuses on machine learning bash scripts generation. DA-Bench (Hu et al., 2024) also evaluates agents on data analysis tasks, however its task setting is not fully agentic and advanced. Our work focuses on data science, involving real and challenging tasks that cover the full pipeline.\\n\\n**Code Agent Method**\\n\\nThe value of generative code models and interactive problem solving has motivated a recent proliferation of work to augment reasoning capabilities of existing language models (Yao et al., 2022; Shinn et al., 2024; Chen et al., 2023; Zhang et al., 2022; Wang et al., 2023). Many agent methods have been proposed to solve code generation tasks. Direct interaction of agents with the Linux command line can cause many issues (Yang et al., 2024a). Several works (Yang et al., 2024b; Huang et al., 2023; Zhang et al., 2024; Yang et al., 2024a) have designed special actions to standardize agent operations. OpenDevin (OpenDevin Team, 2024) is a new agent for solving coding tasks. It is based on CodeAct (Wang et al., 2024), a framework that consolidates LLM agents' actions into a unified code action space. We introduce DA-Agent, a competitive agent framework designed for solving coding tasks, based on the DA-Code environment.\\n\\n**7 Conclusion**\\n\\nWe introduce DA-Code, a challenging benchmark designed for agent-based code generation tasks in data science. This benchmark comprises 500 examples characterized by diverse data sources, complex task settings, and an executable environment. We develop DA-Agent, a robust LLM-Agent baseline, to tackle this challenging benchmark. However, experiments reveal that even the most advanced LLMs perform poorly on DA-Code, achieving only about a 30.5% score. Future work will focus on 1) developing a more sophisticated data agent framework, 2) training more effective agents based on open-source LLMs.\\n\\n**Limitations**\\n\\nDA-Code introduces a challenging benchmark for agent code generation. The current version presents the following limitations: While utilizing a substantial amount of data science data to fine-tune LLMs is meaningful, this approach has not been explored in this paper. Although this work proposes a general benchmark for data science, it warrants more thorough investigation. In future efforts, we plan to delve deeper into the performance of fine-tuning open-source LLMs on DA-Code.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 10, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"This work was supported by the National Key R&D Program of China (No. 2022ZD0160503) and the National Natural Science Foundation of China (No. 62376270). This work was also sponsored by CCF-BaiChuan-Ebtech Foundation Model Fund.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 11, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"Xingyao Wang, Yangyi Chen, Lifan Yuan, Yizhe Zhang, Yunzhu Li, Hao Peng, and Heng Ji. 2024. Executable code actions elicit better llm agents. arXiv preprint arXiv:2402.01030.\\n\\nQingyun Wu, Gagan Bansal, Jieyu Zhang, Yiran Wu, Beibin Li, Erkang Zhu, Li Jiang, Xiaoyun Zhang, Shaokun Zhang, Jiale Liu, et al. 2023. Autogen: Enabling next-gen llm applications via multi-agent conversation.\\n\\nTianbao Xie, Chen Henry Wu, Peng Shi, Ruiqi Zhong, Torsten Scholak, Michihiro Yasunaga, Chien-Sheng Wu, Ming Zhong, Pengcheng Yin, Sida I Wang, et al. 2022. Unifiedskg: Unifying and multi-tasking structured knowledge grounding with text-to-text language models. In Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing, pages 602\u2013631.\\n\\nTianbao Xie, Danyang Zhang, Jixuan Chen, Xiaochuan Li, Siheng Zhao, Ruisheng Cao, Toh Jing Hua, Zhoujun Cheng, Dongchan Shin, Fangyu Lei, et al. 2024. Osworld: Benchmarking multimodal agents for open-ended tasks in real computer environments. arXiv preprint arXiv:2404.07972.\\n\\nJohn Yang, Carlos E. Jimenez, Alexander Wettig, Kilian Lieret, Shunyu Yao, Karthik Narasimhan, and Ofir Press. 2024a. Swe-agent: Agent computer interfaces enable software engineering language models.\\n\\nJohn Yang, Akshara Prabhakar, Karthik Narasimhan, and Shunyu Yao. 2024b. Intercode: Standardizing and benchmarking interactive coding with execution feedback. Advances in Neural Information Processing Systems, 36.\\n\\nShunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, Karthik R Narasimhan, and Yuan Cao. 2022. React: Synergizing reasoning and acting in language models. In The Eleventh International Conference on Learning Representations.\\n\\nPengcheng Yin, Wen-Ding Li, Kefan Xiao, Abhishek Rao, Yeming Wen, Kensen Shi, Joshua Howland, Paige Bailey, Michele Catasta, Henryk Michalewski, et al. 2023. Natural language to code generation in interactive data science notebooks. In Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 126\u2013173.\\n\\nTao Yu, Rui Zhang, Kai Yang, Michihiro Yasunaga, Dongxu Wang, Zifan Li, James Ma, Irene Li, Qingning Yao, Shanelle Roman, et al. 2018. Spider: A large-scale human-labeled dataset for complex and cross-domain semantic parsing and text-to-sql task. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 3911\u20133921.\\n\\nKechi Zhang, Jia Li, Ge Li, Xianjie Shi, and Zhi Jin. 2024. Codeagent: Enhancing code generation with tool-integrated agent systems for real-world repo-level coding challenges. arXiv preprint arXiv:2401.07339.\\n\\nShun Zhang, Zhenfang Chen, Yikang Shen, Mingyu Ding, Joshua B Tenenbaum, and Chuang Gan. 2022. Planning with large language models for code generation. In The Eleventh International Conference on Learning Representations.\\n\\nQihao Zhu, Daya Guo, Zhihong Shao, Dejian Yang, Peiyi Wang, Runxin Xu, Y Wu, Yukun Li, Huazuo Gao, Shirong Ma, et al. 2024. Deepseek-coder-v2: Breaking the barrier of closed-source models in code intelligence. arXiv preprint arXiv:2406.11931.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 12, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"In this section, we present diverse examples in DA-Code. We have performed a more detailed classification of tasks into three categories: DW, ML, and EDA, as shown in Figure 7. Data wrangling can be divided into data cleaning, data loading, and data transformation.\\n\\n- **Data Cleaning:** Focuses on enhancing the data's quality by eliminating errors, imputing missing values, normalizing data in databases or raw datasets, and resolving inconsistencies to maintain the accuracy and trustworthiness of the data.\\n\\n- **Data Loading:** Entails the consolidation of data from diverse sources into a unified storage system, loading data according to specified standards and requirements, enabling streamlined access and consistent analytical practices.\\n\\n- **Data Transformation:** Involves reformatting and restructuring data to better suit analytical models for targeted analysis.\\n\\nThe EDA category covers a wide range of tasks. In our benchmark, it is divided into Visualization, Statistical, Data Manipulation, and Data Insights.\\n\\n- **Data Manipulation:** Data Manipulation is designed to perform intricate data operations using SQL and Pandas, efficiently processing large datasets. It primarily focuses on counting, summarizing data, and refining presentation formats.\\n\\n- **Data Insights:** This section focuses on tasks involving real data and issues encountered in actual scenarios. These problems do not provide clear solutions, necessitating thoughtful consideration and autonomous decision-making in coding for data analysis. The results are presented primarily in tables, or alternatively, in text format, to address and answer these questions.\\n\\n- **Visualization:** The format of visualization tasks is similar to the previous category, with the unique aspect being that the results are presented in the form of charts.\\n\\n- **Statistical Analysis:** Statistical analysis tasks typically require advanced knowledge of statistics and mathematics, utilizing mathematical indicators for statistical analysis.\\n\\nML tasks are categorized into three types: Classification, Regression, and Clustering. The reference solutions for these tasks require the use of corresponding ML algorithms to complete the assignments. In DA-Code, we select three foundational task categories: classification, regression, and clustering, from two sources: regular dataset tasks and competition tasks.\\n\\nRegular dataset tasks prioritize real-world applications, emphasizing comprehensive data preprocessing and feature engineering. Conversely, competition tasks present a heightened challenge, requiring advanced algorithmic approaches to meet specific performance metrics. In the instructions, the task category is not directly provided; the model needs to autonomously determine the task's category, design methods, and select models accordingly. Additionally, only traditional machine learning algorithms, such as linear regression and random forests, are permitted, with no deep learning methods allowed. The final outputs consist of predictions on the test dataset provided.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 13, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"A.1 Data Wrangling Example\\n\\nTask Instruction\\nAccording to the pre-defined database information, transform the data in the data folder and load it into the database.\\n\\nVerbose Instruction\\n1. Review the predefined schema to identify the tables and columns; note that there are five tables and record their column names.\\n2. Check which files are present in the ./data folder.\\n3. Examine the file information; since there are no minutes and hours information, data transformation is necessary.\\n4. Get trip_minutes and trip_hours by the trip_duration.\\n5. The columns for rain and snow do not match with those in the raw data; type conversion is required.\\n6. Merge five months of JC data and compare with the schema to identify any missing columns.\\n7. Split the table JC by columns to match it with the database schema.\\n8. Write SQL insert statements to insert the data into the database.\\n\\nEnvironment Settings\\n|--- DATA_STANDARD.yml\\n|--- data\\n| |--- JC-202401-citibike-tripdata.csv\\n| |--- JC-202402-citibike-tripdata.csv\\n| |--- JC-202403-citibike-tripdata.csv\\n| |--- JC-202404-citibike-tripdata.csv\\n| |--- JC-202405-citibike-tripdata.csv\\n|--- newark_airport_2024.csv\\n|--- database.db\\n|--- schema.yml\\n\\nA.2 Machine Learning Task\\n\\nTask Instruction\\nThis is a dataset for a Bank customer data for churn prediction competition, with the description available in README.md. You are now a contestant in this competition and need to design a method to predict the data in test.csv according to the competition requirements. Write the results into submission.csv according to the format of sample_submission.csv.\\n\\nVerbose Instruction\\n1. Load the training, testing, and submission datasets from CSV files.\\n2. Check the dimensions and basic statistics of each dataset, including the number of rows, columns, and presence of null values.\\n3. Handle missing values in the datasets using appropriate methods such as imputation or removal.\\n4. Scale numeric columns to ensure consistent ranges.\\n5. Encode categorical text features using TF-IDF vectorization to transform them into numerical representations.\\n6. Use a One-hot encoder to encode categorical features to convert them into a format suitable for machine learning models.\\n7. Define feature columns for training the model, excluding non-predictive columns.\\n8. Utilize CatBoostClassifier within a StratifiedKFold cross-validation framework to train and validate the model, ensuring robustness and performance assessment.\\n9. Use the trained model to make predictions, and prepare the submission file by mapping predicted probabilities to the 'Exited' column for submission.\\n\\nEnvironment Settings\\n|--- README.md\\n|--- Churn_Modelling.csv\\n|--- train.csv\"}"}
{"id": "emnlp-2024-main-748", "page_num": 14, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"A.3 Exploratory Data Analysis (EDA)\\n\\nA.3.1 Visualization\\n\\nTask Instruction\\nCreate a stacked horizontal bar chart, which illustrates the average days per order stage for the top 10 cities by sales. Save the chart as 'result.png' with settings from 'plot.yaml'.\\n\\nVerbose Instruction\\n1. Check Available Resources and Current Directory: View the resources provided and examine the contents of the current directory.\\n2. Database Content Review: Read what is contained in the database and identify the tables present.\\n3. Identify Top 10 Cities by Sales: To determine the top 10 cities by sales, join the 'orders' and 'customers' tables using the 'customer_id'. Record the names of these cities.\\n4. Create an SQL query to evaluate order processing times in the top 10 cities by joining the 'orders' and 'customers' tables using 'customer_id'. Calculate average durations for key milestones in the order process and include only orders from these cities, identified possibly via a subquery based on order volumes. Group and display results by 'customer_city', showing averages for each stage.\\n5. Read Plot Configuration: Load the 'plot_config.yml' file to review plotting requirements.\\n6. Create a Pie Chart of Average Order Processing Times: Prepare a summarized DataFrame, configure the pie chart with appropriate labels and colors, enhance its aesthetics with a title and legend, and then save and display the result.\\n\\nEnvironment Settings\\n\\n--- DATASET_INFO.md\\n--- E-commerce.db\\n--- plot_config.yml\\n\\nA.3.2 Data Manipulation\\n\\nTask Instruction\\nUtilize the Open Food Facts database. Identify the list of ingredients and their countries of origin, and record the results in the ingredient_origins.csv file.\\n\\nVerbose Instruction\\n1. Read in the avocado data. Read the avocado data from a tab-delimited CSV file. Subset the DataFrame to include only a smaller number of relevant columns. Read in the relevant category tags for avocados from a text file.\\n2. Filter avocado data using relevant category tags - Drop rows with null values in the 'categories_tags' column. Convert the 'categories_tags' column from comma-separated strings to lists. Filter the DataFrame to keep only rows with relevant category tags.\\n3. Determine the top origin country for UK avocados. Filter the avocado DataFrame for rows where 'countries' equals \\\"United Kingdom\\\". Count and order the unique values in the 'origins_tags' column. Identify the top country of origin for avocados in the UK. Lean up the country string to remove any leading characters or hyphens.\\n4. Create a user-defined function for ingredient analysis Create a function called 'read_and_filter_data()' that: Takes a filename and a list of relevant categories as arguments. Performs the same steps as above to read, subset, filter, and analyze the data. Returns the top country of origin for the ingredient.\\n5. Analyze other ingredients. Use the relevant categories data to determine the top origin countries for olive oil and sourdough by calling the 'read_and_filter_data()' function.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 15, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"A.3.3 Statistical Analysis\\n\\nTask Instruction\\n\\nYou have a Statistical thinking dataset, with details described in the README.md file. Calculate 10,000 bootstrap replicates of the variance in annual rainfall at the Sheffield Weather Station. Divide the data into 50 bins, compute the bin center and corresponding probability density function (PDF) for each bin. For convenience, convert the variance to units of square centimeters. Save the results to a file named result.csv, following the template provided in sample_result.csv. (Set the random seed to 42)\\n\\nVerbose Instruction\\n\\n1. Bootstrap Helper Functions:\\n   - Define a function 'bootstrap_replicate_1d(data, func)' to generate a bootstrap replicate of 1D data.\\n   - Define another function 'draw_bs_reps(data, func, size=1)' to draw multiple bootstrap replicates.\\n\\n2. Data Preparation:\\n   - Read the weather station CSV file considering it is space-delimited and does not have a header.\\n   - Assign appropriate column names.\\n   - Remove the first several rows if it contains non-numeric data.\\n   - Convert the year column to integers and rain column to floats, handling conversion errors gracefully and dropping any resulting NaN values.\\n   - Compute the total annual rainfall by grouping data by year and summing the rain values for each year.\\n   - Convert the resulting annual rainfall sums to a NumPy array.\\n\\n3. Bootstrap Analysis:\\n   - Generate 10,000 bootstrap replicates of the variance of annual rainfall using the 'draw_bs_reps' function.\\n   - Adjust the variance units if needed (e.g., put the variance in units of square centimeters).\\n\\n4. Probability Density Function (PDF):\\n   - Create a histogram of the bootstrap replicates with 50 bins, normalized to represent a PDF.\\n   - Calculate the center points for each bin and the corresponding PDF values.\\n   - Store the bin centers and PDF values in a DataFrame.\\n\\n5. Save Results.\"}"}
{"id": "emnlp-2024-main-748", "page_num": 16, "content": "{\"primary_language\":\"en\",\"is_rotation_valid\":true,\"rotation_correction\":0,\"is_table\":false,\"is_diagram\":false,\"natural_text\":\"2. Review Data Quality: Open and review files to check their formats (CSV, JSON, etc.) and data quality. Identify any missing values or inconsistencies.\\n\\n3. Load Data: Import necessary files into an SQLite database.\\n\\n4. Identify Popular Garages: Write a SQL query to count distinct users per garage, focusing on shared users to determine high-traffic garages.\\n\\n5. Analyze Peak Times: Develop a SQL query to find peak charging times by analyzing sessions by day and hour.\\n\\n6. Calculate Charging Durations: Create a SQL query to calculate average charging durations per user, focusing on those exceeding specific thresholds.\\n\\n7. Analyze User Behavior: Identify patterns in long-duration charging by examining frequency and preferred times.\\n\\n8. Segment User Data: If applicable, segment data by user type (commercial, personal, shared) to tailor improvements to different user needs.\\n\\nEnvironment Settings\\n\\n| README.md |\\n|--- analysis.md |\\n| charging_sessions.csv |\\n| historical_usage_2022.csv |\\n| forecast_analysis_2023.md |\\n| user_feedback_logs.md |\\n| pricing_updates.json |\\n| maintenance_records |\\n| january_2023.txt |\\n| february_2023.txt |\\n| march_2023.txt |\"}"}
